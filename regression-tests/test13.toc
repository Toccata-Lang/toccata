
(defn boom []
  (inline Maybe
   "abort();
    return(nothing);"))

(defn int-= [x y]
    (inline "return(integer_EQ(x_0, y_1));"))

(defn inc-int [x]
  (inline Integer "
    if (x_0->refs == 1) {
      ((Integer *)x_0)->numVal++;
      return x_0;
    } else {
      Value *numVal = integerValue(((Integer *)x_0)->numVal + 1);
      dec_and_free(x_0, 1);
      return(numVal);
    } "))

(defn unwrap-maybe [mv]
  (inline "return(maybeExtract(mv_0));"))

(main [_]
  (and (int-= 0 0)
       ;; a comment
       (int-= (inc-int 0) (inc-int 0))
       (maybe (pr* "'and' works\n")))
  (or (int-= 0 1)
      ;; a comment
      (maybe (pr* "'or' works\n")))
  (or (and (int-= 0 0)
           (maybe (pr* "'and' in 'or' works\n")))
      (maybe (pr* "'and' in 'or' works\n")))
  (or (and (int-= 1 0)
           (maybe (pr* "'and' in 'or' works\n")))
      (and (int-= 0 0)
           (maybe (pr* "2 'and' in 'or' works\n"))))
  (and (or (int-= 0 0)
           (maybe (pr* "'or' in 'and' works\n")))
       (maybe (pr* "'or' in 'and' works\n")))
  (and (or (int-= 0 0)
           (maybe (pr* "2 'or' in 'and' works\n")))
       (or (int-= 1 0)
           (maybe (pr* "2 'or' in 'and' works\n"))))
  (let [x (maybe 3)]
    (and x (unwrap-maybe x)))
  (let [x (maybe 8)]
    (and x (let [y (unwrap-maybe x)]
             (maybe (inc-int y))))
    (or x (let [y (unwrap-maybe x)]
             (maybe (inc-int y)))))
  (let [w (maybe 99)]
    (or (let [_ w
              mv (inc-int 7)]
          (maybe mv))
        nothing))
  (and nothing
       (do
         (pr* "FAIL!!!\n")
         (boom)))
  (let [max (maybe 0)]
    (and (maybe 0)
         max))
  (let [max (maybe 0)]
    (or (maybe 0)
         max))
  (pr* "and/or works\n")
  )
