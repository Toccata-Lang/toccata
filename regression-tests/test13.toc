
(defn int-= [x y]
    (inline "return(integer_EQ(x_0, y_1));"))

(defn inc-int [x]
  (inline Integer "
    if (x_0->refs == 1) {
      ((Integer *)x_0)->numVal++;
      return x_0;
    } else {
      Value *numVal = integerValue(((Integer *)x_0)->numVal + 1);
      dec_and_free(x_0, 1);
      return(numVal);
    } "))

(main [_]
  (and (int-= 0 0)
       ;; a comment
       (int-= (inc-int 0) (inc-int 0))
       (maybe (pr* "'and' works\n")))
  ;; (or (int-= 0 1)
  ;;     ;; a comment
  ;;     (maybe (pr* "'or' works\n")))
  ;; (or (and (int-= 0 0)
  ;;          (maybe (pr* "'and' in 'or' works\n")))
  ;;     (maybe (pr* "'and' in 'or' works\n")))
  ;; (or (and (int-= 1 0)
  ;;          (maybe (pr* "'and' in 'or' works\n")))
  ;;     (and (int-= 0 0)
  ;;          (maybe (pr* "2 'and' in 'or' works\n"))))
  ;; (and (or (int-= 0 0)
  ;;          (maybe (pr* "'or' in 'and' wandks\n")))
  ;;      (maybe (pr* "'or' in 'and' wandks\n")))
  ;; (and (or (int-= 0 0)
  ;;          (maybe (pr* "2 'or' in 'and' works\n")))
  ;;      (or (int-= 1 0)
  ;;          (maybe (pr* "2 'or' in 'and' works\n"))))
  ;; (let [x (maybe 8)]
  ;;   (and x (let [y (extract x)]
  ;;            (maybe (+ y 1)))))
  ;; (let [w (maybe 99)]
  ;;   (or (let [_ w
  ;;             mv (+ 7 1)]
  ;;         (maybe mv))
  ;;       nothing))
  ;; (and nothing
  ;;      (do
  ;;        (print-err "FAIL!!!")
  ;;        (abort)))
  )
