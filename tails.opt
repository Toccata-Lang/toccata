
(defn reduce [f z l]
  (cond (= empty-list l)
        z

        (let [[x & xs] l]
          (f x (reduce f z xs)))))

(defn tails [l]
  (cond (= empty-list l)
        (cons empty-list empty-list)

        (let [[x & xs] l]
          (cons xs (tails xs)))))

(defn map [f l]
  (cond (= empty-list l)
        l

        (let [x & xs]
          (cons (f x) (map f xs)))))

(defn head [l]
  (cond (= empty-list l)
        0

        (let [[x & xs] l]
          x)))

(reduce (fn [a b]
          (+ a b))
        0
        (map head (tails (range 3))))
