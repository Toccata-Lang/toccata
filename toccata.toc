
;; TODO: benchmarks to implement
;; https://github.com/christianscott/levenshtein-distance-benchmarks
;; https://github.com/darklang/fizzboom/

;; libs to implement
;; ZIO and associated
;; shpadoinkle https://gitlab.com/fresheyeball/Shpadoinkle/-/tree/master

;; things to remember and aspire to
;; https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/
;; https://github.com/hasura/eff

;; TODO:
;; As soon as possible, implement
;; https://github.com/smarr/are-we-fast-yet/

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "db280f6"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ca7e20c"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "4f87b5e"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "4846add"))
;; (add-ns ev (git-dependency "https://github.com/Toccata-Lang/eval.git"
;;                            "eval.toc"
;;                            :sha "29cf820"))
;; (add-ns interp (git-dependency "https://github.com/Toccata-Lang/eval.git"
;;                                "interpreter.toc"
;;                                :sha "29cf820"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "73df64c"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "eccb64f"))
(add-ns strm (git-dependency "https://github.com/Toccata-Lang/stream.git"
                             "stream.toc"
                             :sha "4aa15f9"))
(add-ns sh (git-dependency "https://github.com/Toccata-Lang/shell-proc.git"
                           "shell-proc.toc"
                           :sha "1e413ea"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "a1bad99"))

(def symbols-sym (ast/tag "#symbols"))
(def protocols-sym (ast/tag "#protocols"))
(def invoke-sym (ast/tag 'invoke 'core 0))
(def Type-sym (ast/tag 'Type 'core 0))
(def Function-sym (ast/tag 'Function 'core 0))
(def Container-sym (ast/tag 'Container 'core 0))
(def Stringable-sym (ast/tag 'Stringable 'core 0))
(def type-name-sym (ast/tag 'type-name 'core 0))
(def type-mapping-sym (ast/tag 'type-mapping 'core 0))
(def =*-sym (ast/tag '=* 'core 0))
(def apply-sym (ast/tag 'apply 'core 0))
(def get-type-sym (ast/tag 'default-get-type 'core 0))
(def extract-sym (ast/tag 'extract 'core 0))
(def instance?-sym (ast/tag 'instance? 'core 0))
(def string-list-sym (ast/tag 'string-list 'core 0))
(def list-sym (ast/tag 'list 'core 0))
(def has-field-sym (ast/tag 'has-field 'core 0))
(def identical-sym (ast/tag 'identical 'core 0))
(def Eq-sym (ast/tag 'Eq 'core 0))
(def Associative-sym (ast/tag 'Associative 'core 0))
(def get-symb (ast/tag 'get 'core 0))
(def maybe-sym (ast/tag 'maybe 'core 0))
(def HashMapNode-sym (ast/tag 'HashMapNode 'core 0))
(def Hashable-sym (ast/tag 'Hashable 'core 0))
(def sha1-sym (ast/tag 'sha1 'core 0))
(def sha1-update-sym (ast/tag 'sha1-update 'core 0))
(def sha1-init-sym (ast/tag 'sha1-init 'core 0))
(def sha1-finalize-sym (ast/tag 'sha1-finalize 'core 0))
(def sha1-update-type-sym (ast/tag 'sha1-update-type 'core 0))
(def assoc-sym (ast/tag 'assoc 'core 0))
(def update-field-sym (ast/tag 'update-field 'core 0))
(def store-sym (ast/tag 'store 'core 0))
(def default-type-args-sym (ast/tag 'default-type-args 'core 0))
(def nth-sym (ast/tag 'nth 'core 0))
(def partial-sym (ast/tag 'partial 'core 0))
(def some-sym (ast/tag 'some 'core 0))
(def nothing-sym (ast/tag 'nothing 'core 0))

(def type-counter (int-generator c/TypeCount))

(def rt-exprs (agent []))

;; TODO: replace this with (cata print x)
(defprotocol StringWriter
  (write-str [x]
    (print x)))

(def sm-nop (sm/state-maybe '_))
(def se-nop (se/state-error '_))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(defn safe-pr [& args]
  (send string-writer
        (fn [_]
          (apply print-err args))))

(defn flush-pr []
  (let [p (promise)]
    (send string-writer
          (fn [x]
            (deliver p 'done)
            x))
    (extract p)))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-nop (fn [_]
                (send string-writer
                      (fn [_]
                        (apply print-err args)))
                (flush-pr))))

(defn se-debug [& args]
  (map se-nop
       (fn [_]
         (send string-writer
               (fn [_]
                 (apply print-err args)))
         (flush-pr))))

(def Tagged (any-of Symbol
                    ast/tagged-symbol))

;; TODO: use 'either' here
(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-marker [file-name line-number marker]
  (cond (or (= "" file-name)
            (and (= 'core file-name)
                 (= 0 line-number)))
        "\n#\n"
        ["\n" marker "\n#line "
         (str line-number) " " "\""
         (cond (= 'core file-name)
               path-to-core
               file-name)
         "\"\n"]))

(defn line-macro [ast marker]
  (wrap sm/zero-sm (line-marker (ast/file-name ast) (ast/line-number ast) marker)))

(def type-names {c/IntegerType "Integer"
                 c/StringBufferType "String"
                 c/SubStringType "String"
                 c/FnArityType "FnArity"
                 c/FunctionType "Fn"
                 c/ListType "List"
                 c/MaybeType "Maybe"
                 c/VectorType "Vector"
                 c/VectorNodeType "VectorNode"
                 c/SymbolType "Symbol"
                 c/BitmapIndexedType "BitmapIndexNode"
                 c/ArrayNodeType "ArrayNode"
                 c/HashCollisionNodeType "HashCollisionNode"
                 c/HashSetType "Set"
                 c/PromiseType "Promise"
                 c/FutureType "Future"
                 c/AgentType "Agent"
                 c/OpaqueType "Opaque"
                 c/UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def fn-constraint (c/TypeConstraint {c/FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (c/TypeConstraint {c/SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (c/TypeConstraint {c/VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (c/TypeConstraint {c/ListType #{}} empty-list 'List nothing ""))
(def seq-constraint (c/TypeConstraint {c/ListType #{}
                                       c/VectorType #{}} empty-list 'Sequence nothing ""))
(def string-constraint (c/TypeConstraint {c/StringBufferType #{} c/SubStringType #{}}
                                         empty-list 'String nothing ""))
(def hashmap-constraint (c/TypeConstraint {c/BitmapIndexedType #{}
                                           c/ArrayNodeType #{}
                                           c/HashCollisionNodeType #{}}
                                          empty-list 'HashMap nothing ""))
(def int-constraint (c/TypeConstraint {c/IntegerType #{}} empty-list 'Integer nothing ""))
(def maybe-constraint  (c/TypeConstraint {c/MaybeType #{}} empty-list 'Maybe nothing ""))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (send string-writer
                     (fn [_]
                       (apply print-err msg)
                       (abort)))
               nothing)))

(defprotocol Emitter
  (reify-c [c param-exprs file-name line-number]
    (assert-result r (instance? sm/new-sm r))
    (sm/state-maybe c))

  ;; Unwrap the tail call
  (remove-tail [ast]
    ast)

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

;; how to use
;; (cata all-symbols (.fields ast))
    )

  (dissoc-sym [ast]
    (assert-result x (instance? sm/new-sm x)))

  (new-bound-var [ast]
    (assert-result x (instance? sm/new-sm x)))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (update-syms [ast update-bindings]
    (assert-result x (instance? sm/new-sm x))

    (sm/state-maybe (Right ast)))

  (pop-subs [x]
    (sm/state-maybe x))

  ;; get the constraints for a symbol or params-ast
  (get-param-cs [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (wrap-tail [ast params]
    (assert-result r (instance? Either r))

    (Right ast))

  (to-constraint [c]
    (sm/state-maybe c))

  ;; prepare an ast node for binding an expression to it
  (pre-bind [ast]
    (assert-result x (instance? sm/new-sm x)))

  ;; generate a new local C var for a symbol
  (bind-expr [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind fn parameters
  (bind-param-expr [binding]
    ;; (assert (instance? BindingValue expr))
    (assert-result x (instance? sm/new-sm x)))

  ;; ----- need recursion scheming

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind-expr [binding evalled]
    ;; TODO: re-arrange code to make this possible
    ;; (assert (instance? BindingValue evalled))
    (assert-result x (instance? sm/new-sm x)))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))

  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (encode [m var-prefix])

  (validate-field [c m fields file-name line-number]
    (assert (instance? c/ValueConstraint c))
    (assert (instance? (map-of Symbol c/ValueConstraint) m))
    (assert (instance? (vector-of Symbol) fields))
    (assert (instance? ast/SymbolOrString file-name))
    (assert (instance? Integer line-number))

    m)

  ;; encode a statically initialized representation of a core data structure
  ;; TODO: make sure every impl is needed and constrains the var properly
  (encode-static [m]
    (do
      (print-err 'could-not-encode (type-name m) m)
      sm/zero-sm))

  (runtime-check [constraint value-info file-name line-number checked-var]
    (assert (instance? ast/SymbolOrString file-name))
    (assert (instance? Integer line-number))
    (assert-result r (instance? Vector r))

    ;; generated code must preserve ref counts
    (cond (c/satisfied-by constraint value-info)
          []

          ;; TODO: at some point, check for more instances of 'satisfied-by' that should pass
          ;; (do
          ;;   (or (= c/top-type init-c)
          ;;       (map (= final-c init-c)
          ;;            (fn [x]
          ;;              (safe-pr 'same file-name line-number x)
          ;;              (safe-pr var)))
          ;;       (maybe (do
          ;;                (safe-pr 'not-same file-name line-number)
          ;;                (safe-pr 'final final-c "\n" 'init init-c)))))
          (runtime-check constraint value-info
                         (cond (= "" file-name)
                               ["\"\""]
                               ["\"at " file-name ": " line-number "\""])
                         checked-var)))

  (runtime-check [constraint value-info sym-location checked-var]
    (assert (instance? (any-of c/NoValues
                               c/ResultConstraint
                               c/ValueConstraint)
                       constraint))
    (assert (instance? c/ValueConstraint value-info))
    (assert (instance? String checked-var))
    (assert-result r (instance? Vector r)))

  (runtime-check [constraint value-info checked-var]
    (assert (instance? (any-of c/NoValues
                               c/ResultConstraint
                               c/ValueConstraint)
                       constraint))
    (assert (instance? c/ValueConstraint value-info))
    (assert (instance? String checked-var))
    (assert-result r (instance? Vector r)))

  (old-reify-c [c param-exprs file-name line-number]
    (sm/state-maybe c))

  (get-result-constraint [_ num-args]
    (assert-result r (instance? sm/new-sm r)))

  (cache-static-constant [v expr]
    '_)

  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  (emit-recursive-call [ast params]
    sm/zero-sm)

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    sm/zero-sm)

  (clear-init [expr]
    ;; TODO: re-arrange code to make this possible
    ;; (assert (instance? BindingValue expr))
    ))

;; (defn extract-collection-of [ast]
;;   (let [x (old-extract-collection-of ast)
;;         y (cata collection-of ast)]
;;     (or (= x y)
;;         (maybe (print-err 'diff-coll-of (ast/file-name ast) (ast/line-number ast) "\n\n" x "\n\n" y))))
;;     y))

(defn all-syms [params]
  (assert (instance? ast/BindingTarget params))

  (cata all-symbols params))

(defn bind-param [params]
  (assert (instance? ast/params-ast params))
  (cond (.variadic params)
        (map (hylo pre-bind bind-param-expr params sm/state-maybe)
             vector)

        (map (.fixed params)
             (fn [ast]
               (hylo pre-bind bind-param-expr ast sm/state-maybe))
             sm/state-maybe)))

(defn lookup-constraint [c]
  (hylo to-constraint (comp sm/state-maybe c/trim)
        c sm/state-maybe))

(defn tail-call [ast params]
  (apo (fn [ast]
         (wrap-tail ast params))
       ast))

(defn get-param-constraints [ast]
  (for [y (cata get-param-cs ast sm/state-maybe)]
    (c/update-path y (ast/file-name ast) (ast/line-number ast))))

(defn replace-syms [ast subs]
  (assert (instance? HashMap subs))

  (cond (empty? subs)
        ast

        (either (flat-map (or ((elgot (fn [ast]
                                        (update-syms ast dissoc-sym))
                                      pop-subs
                                      ast sm/state-maybe)
                               (list subs))
                              nothing)
                          first)
                ast)))

(defn replace-bound-vars [ast]
  (either (flat-map (or ((elgot (fn [ast]
                                  (update-syms ast new-bound-var))
                                pop-subs
                                ast sm/state-maybe)
                         (list {}))
                        (do
                          (print-err 'boom (ast/file-name ast) (ast/line-number ast)
                                     ast)
                          nothing))
                    first)
          ast))

(defn unwrap-tail [ast]
  (cata remove-tail ast))

(defn reify-constraint [c param-exprs file-name line-number]
  (for [x (old-reify-c c param-exprs file-name line-number)
        ;; new-c (ana (fn [c]
        ;;              (reify-c c param-exprs file-name line-number))
        ;;            c sm/state-maybe)
        ]
    (let [;; x (cata c/trim x)
          new-c (cata c/trim x)]
      ;; (or (= x new-c)
      ;;     (do
      ;;       (print-err 'diff-reify-c 'c c "\n\n" 'params param-exprs "\n\n" x "\n\n" new-c)
      ;;       ;; (abort)
      ;;       nothing
      ;;       ))
      new-c)))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? String seq-c-var))
  (assert (instance? String dest-args))

  ;; TODO: inline destructuring of sequences if type is known
  (let [elem-count (count elem-c-vars)]
    (cond (= 1 elem-count)
          (let [[tail-var] elem-c-vars]
            ["Value *" tail-var " = seq((FnArity *)0, " seq-c-var ");" line-sep])

          [(map elem-c-vars (fn [var]
                              ["Value *" var ";" line-sep]))
           "Value **" dest-args "[" elem-count "] = {"
           (interpose (map elem-c-vars (partial vector "&")) ", ")
           "};" line-sep "destructValue(\"" file-name "\", \"" line-num
           "\", (Value *)" seq-c-var ", " elem-count ", "
           dest-args ");" line-sep])))

(deftype FnValPtr [var]
  ;; pointer to a Fn struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var struct]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispatcher [prototype-name path p-impls]
  (assert (instance? Symbol prototype-name))
  (assert (instance? String path))
  (assert (instance? HashMap p-impls))

  Type
  (type-name [_]
    (str "ProtoDispatcher: " prototype-name))

  Stringable
  (string-list [_]
    (list (str prototype-name))))

(def CFnPtr (any-of StaticFnPtr
                    ProtoDispFnPtr))

(def PointerVar (any-of FnValPtr
                        ArityValPtr
                        CFnPtr))

(extend-type PointerVar
  Emitter
  (encode-static [x]
    (emit (.var x)))

  Stringable
  (string-list [x]
    (list (str (.var x))))

  Eq
  (=* [x y]
    (and (=* y (str (.var x)))
         (maybe x)))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? c/Constraints x)))

  (expr-constraints [expr new-const]
    (assert (instance? c/Constraints new-const))

    expr)

  (collapse-expressions* [x y]
    (assert-result r (instance? sm/new-sm r))))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init refs-map]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

(def empty-c-code (empty-code "" [] {}))

(deftype c-code [c-var init refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<c-code " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-reified [type-num c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Reified " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-constructor [c-var init refs-map constraints c-struct type-num fields]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Type-Constructor " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ", " (str type-num) ">")))

(deftype c-static-str [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-String " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-int [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Int " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-sym [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Symbol " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-vector-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Vector-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-maybe-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Maybe-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-list-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-List-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-protocol-fn [c-var init refs-map c-struct proto-sym arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Protocol-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-static-arity [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "(c-static-arity " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ")")))

(deftype c-static-fn [c-var init refs-map c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "(c-static-fn " (str c-var) ", " (str (count init)) ", "
          (str refs-map) ", " (str arities) ")")))

(deftype c-static-val [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Static-Value " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(extend-type c-code
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type)))

(def C-Static-Value (any-of c-static-int
                            c-static-str
                            c-static-sym
                            c-static-reified
                            c-constructor
                            c-list-fn
                            c-maybe-fn
                            c-vector-fn
                            c-static-fn
                            c-static-arity
                            c-protocol-fn
                            c-static-val))

(extend-type C-Static-Value
  Emitter
  (encode-static [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init refs-map constraints file-name line-number]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

(deftype c-field [c-var init refs-map constraints parent]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? HashMap refs-map))
  (assert (instance? c/Constraints constraints))
  (assert (instance? String parent))

  Stringable
  (string-list [_]
    (list "<C-Field " (str c-var) ", "
          (str (count init)) ">"))

  Emitter
  (emit [x]
    (sm/state-maybe x))

  Collection
  (empty? [c] nothing))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
;; TODO: should add a constraint field
(deftype c-init [c-var init refs-map file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-init', but specifically for anon closure functions
(deftype c-closure-fn [c-var init refs-map arities file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Closure " (str c-var) ", "
          (str (count init)) ", " (str refs-map) " " (str arities) ">"))

  Collection
  (empty? [c] nothing))


(def C-Value (any-of c-code
                     c-closure-fn
                     c-param
                     C-Static-Value))

(extend-type C-Value
  Collection
  (empty? [c]
    (empty? (.init c)))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

(def C-expr (any-of empty-code
                    C-Value
                    c-param
                    c-init))

(def BindingValue (any-of C-expr
                          c-field))


(extend-type BindingValue
  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

(defn bind
  ([ast]
   (hylo pre-bind bind-expr ast sm/state-maybe))
  ([ast expr]
   (bind-expr ast expr)))

(defn collapse-expressions [cs]
  (assert (instance? (sequence-of BindingValue) cs))
  (assert-result r (instance? sm/new-sm r))

  (either (or (and (empty? cs)
                   (maybe (sm/state-maybe empty-c-code)))
              (and (empty? (rest cs))
                   (map (first cs) sm/state-maybe)))
          (let [[c & cs] cs]
            (flat-map (collapse-expressions cs)
                      (partial collapse-expressions* c)))))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (sm/state-maybe y)))

(extend-type c-init
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))
                         c-var (.c-var x)
                         file-name (.file-name x)
                         line-number (.line-number x)
                         init [(.init x)
                               (either (or (for [refs (get-in y [.refs-map c-var])]
                                             [(cond (< refs 2)
                                                    ""
                                                    ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                                           (= "" c-var))
                                       [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                               (.init y)]
                         refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                                          c-var)]
                     (-> y
                         (.init init)
                         (.refs-map refs-map)))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)

          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          init [(.init x)
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(cond (< refs 2)
                                     ""
                                     ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]]
      (-> (cond (instance? empty-code y)
                (c-code "" [] {} c/top-type)
                y)
          (.init init)
          (.refs-map refs-map)
          sm/state-maybe))))

(extend-type C-Value
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> (cond (instance? empty-code y)
                               x
                               y)
                         (.init [(.init x) (.init y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [x (cond (empty? (.init x))
                  (.refs-map x {})
                  x)]
      (-> (cond (instance? empty-code y)
                (c-code "" [] {} c/top-type)
                y)
          (.init [(.init x) (.init y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          sm/state-maybe))))

(deftype Closures [closures refs-map]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map)))

(def empty-closures (Closures [] {}))

(deftype ConstantValues [numbers strings symbols type-names encoded other]
  ;; numbers                static numbers
  (assert (instance? (map-of Integer String) numbers))
  ;; strings                static strings
  (assert (instance? (map-of String String) strings))
  ;; symbols                static symbols
  (assert (instance? (map-of Symbol String) symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? (map-of Integer String) type-names))
  ;; encoded                cache of values that have been statically encoded
  (assert (instance? HashMap encoded)))

(def constants (agent (ConstantValues {} {} {} type-names {} {})))

(deftype FnSpec [arity-info param-vars]
  (assert (instance? HashMap arity-info))
  (assert (instance? (map-of String c-param) param-vars)))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [fn-spec sym-count syms context-syms closed-over decl subs field-constrs]
  ;; fn-spec       info about the function arity being emitted
  (assert (instance? FnSpec fn-spec))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; C code to declare stuff needed for fn arity
  (assert (instance? Vector decl))
  ;; Substitutions for checking types
  (assert (instance? (map-of String c/ValueConstraint) subs))
  ;; constraints for fields in type-ast implementations
  (assert (instance? (maybe-of c/ItemsConstraint) field-constrs))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype ConstrainedAST [ast constraint]
  Stringable
  (string-list [_]
    (list "(ConstrainedAST " (either (and (instance? ast/tagged-symbol ast)
                                          (maybe (str "'" ast " ")))
                                     (str ast "\n"))
          (str constraint) ")"))

  Container
  (map [x f]
    (ConstrainedAST (f ast) constraint))

  (map [x f embed]
    (map (f ast)
         (fn [new-ast]
           (ConstrainedAST new-ast constraint)))))

;; information that must be tracked for each module
(deftype Module [path index values protocols declarations namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(def core-agent (agent (Module 'core 0 {} {} {} {} {} empty-list)))

(deftype ModuleSetup [init cleanup]
  ;; init               strings to initialize the module
  (assert (instance? Vector init))
  ;; cleanup            strings to initialize the module
  (assert (instance? Vector cleanup)))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context rt-init module constants reify-fn-index loaded setup mod-files]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? FunctionArityContext rt-init))
  ;; module                info for each module compiled
  (assert (instance? Module module))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))
  ;; loaded                 promise to hold finished module
  (assert (instance? Promise loaded))
  ;; setup               strings to initialize the module
  (assert (instance? ModuleSetup setup))
  ;; mod-files              map from filename to module
  (assert (instance? (map-of String Module) mod-files))

  Stringable
  (string-list [_] (list "<GlobalContext "
                         (str module) ">")))

;; TODO: use later
;; (def protocols (agent {}))
;; (defn get-in-protos [path]
;;   (let [result (promise)]
;;     (send protocols (fn [protos]
;;                       (deliver result (get-in protos path))
;;                       protos))
;;     (extract result)))

(def modules (agent {}))
;; TODO: to be added later
;; (assert (instance? (agent-of (map-of String (agent-of GlobalContext)))))

(defn get-subs []
  (sm/get-in-val [.fn-context .subs] {}))

(defn get-constraint [var]
  ;; TODO: this doesn't get promoted up through append-constraint it seems
  (assert (instance? String var))

  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               ;; TODO: this doesn't get promoted up through append-constraint it seems
               ;; assuming the one above is not there
               ;; and it should come from update-var anyway
               (assert (instance? String var))

               (-> (either (-> s
                               .fn-context
                               .subs
                               (get var))
                           c/top-type)
                   (c/update-var var)
                   (vector s)
                   maybe))))

(defn set-constraint [var constraint]
  (cond (= c/top-type constraint)
        sm-nop
        (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (let [constraint (c/update-var constraint var)]
                       (maybe [constraint (assoc-in s [.fn-context .subs var] constraint)]))))))

(defn append-constraint [var constraint file-name line-number]
  (let [constraint (c/update-path constraint file-name line-number)]
    (cond (= constraint c/top-type)
          sm-nop
          (flat-map (get-constraint var)
                    (fn [curr-const]
                      (set-constraint var (either (c/compose-constraints file-name line-number
                                                                         constraint curr-const)
                                                  (abort))))))))

(defn propogate-constraint [src-var dest-var f file-name line-number]
  (flat-map (get-constraint src-var)
            (fn [arg-c]
              (append-constraint dest-var (f arg-c) file-name line-number))))

(defn constraint-type-num [c]
  (let [type-nums (either (map (c/extract-type-map c) keys)
                          [])]
    (either (and (= 1 (count type-nums))
                 (first type-nums))
            c/UnknownType)))

(defn var-type-num [var]
  (map (get-constraint var)
       constraint-type-num))

(defn declare [new-decl]
  (sm/update-in-val [.fn-context .decl] (fn [decl]
                                          (conj decl new-decl))))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      subs (either (get curr-fn-context .subs)
                                   {})
                      new-context (reduce (vec (.syms curr-fn-context))
                                          (.context-syms curr-fn-context)
                                          (fn [syms [sym expr]]
                                            (assoc syms sym
                                                   (expr-constraints expr (either (get subs (.c-var expr))
                                                                                  c/top-type)))))]
                  (maybe [(.decl curr-fn-context [])
                          (.fn-context s (FunctionArityContext (FnSpec {} {})
                                                               0 {} new-context empty-closures
                                                               (.decl curr-fn-context) {}
                                                               (.field-constrs curr-fn-context)))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.decl (.fn-context s) [])
                        (.fn-context s (-> new-fn-context
                                           (.field-constrs (-> s .fn-context .field-constrs))
                                           (.decl (comp (.decl (.fn-context s))
                                                        (.decl new-fn-context)))))])))))

(defn namespace-index [sym]
  (either (map (ast/namespace sym)
               (fn [ns-sym]
                 (sm/get-in-val [.module .namespaces ns-sym .index])))
          (sm/get-in-val [.module .index])))

(defn redef-proto-fn-error [sym]
  (for [ns-index (namespace-index sym)
        path (comp (for [protos (sm/get-in-val [.module .protocols])
                         :when (some (vals protos) (fn [proto] (get proto (ast/untag sym))))
                         path (sm/get-in-val [.module .path])]
                     path)
                   (sm/when (-> (extract core-agent)
                                .protocols
                                vals
                                (some (fn [proto]
                                        (and (get proto (ast/untag sym))
                                             (maybe 'core)))))))
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(def C-var-punct (grmr/any (map (grmr/ignore "*") (constantly "_STAR_"))
                           (map (grmr/ignore ".") (constantly ""))
                           (map (grmr/ignore "#") (constantly "_HASH_"))
                           (map (grmr/ignore "+") (constantly "_PLUS_"))
                           (map (grmr/ignore "?") (constantly "_QM_"))
                           (map (grmr/ignore "!") (constantly "_BANG_"))
                           (map (grmr/ignore "=") (constantly "_EQ_"))
                           (map (grmr/ignore "<") (constantly "_LT_"))
                           (map (grmr/ignore ">") (constantly "_GT_"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (map (grmr/ignore "-") (constantly "_"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (apply-to (fn [start remaining]
                       (to-str (comp [start] remaining)))
                     (grmr/any grmr/alpha
                               (map (grmr/ignore "#") (fn [] ""))
                               (map (grmr/ignore "-") (fn [] "_MINUS_"))
                               C-var-punct)
                     C-var-remaining))

(def C-var (rd/parser C-var))

(defn check-C-var [var-name alt-var]
  (let [parse-result (C-var var-name)]

    ;; TODO: this form doesn't work. 'instance?' fails
    ;; (either (and (instance? se/Failure parse-result)
    ;;              (maybe alt-var))

    ;;       (let [[c-var] parse-result]
    ;;         c-var))

    (cond (instance? Vector parse-result)
          (let [[c-var] parse-result]
            c-var)

          alt-var)))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (check-C-var (str sym "_") arg-name)
                               sym-count)
                          new-ctxt]))))))

(defprotocol ConstrainParams
  (constrain-params [pb]))

(deftype ParamBinding [bound vars tail-var destruct]
  (assert (instance? (vector-of C-expr) destruct))

  ConstrainParams
  (constrain-params [pb]
    (cond (and (empty? vars)
               (= tail-var ""))
          (get-constraint bound)

          (for [tail-const (get-constraint tail-var)
                items-const (sm/traverse vars constrain-params)
                :let [constraint (c/ItemsConstraint items-const tail-const empty-list nothing tail-var)]
                _ (append-constraint bound constraint "" 0)
                ;; TODO: Probably should get the new constraint
                ]
            constraint)))

  Container
  (map [x f]
    (print-err 'ParamBinding-map)
    (abort)
    x)

  (map [x f embed]
    (print-err 'ParamBinding-map-contextual)
    (abort)
    (embed x))

  Stringable
  (string-list [_]
    (cond
     (and (empty? vars)
          (= tail-var ""))
     (list bound)

     (empty? vars)
     (list "[|" tail-var "]")

     (list (str (comp vars [(str "| " tail-var)]))))))


;; generate symbols that are available globally inside the 'state-maybe' container
(defn make-global-var
  ([module-index arg-name]
   (str (gensym (str "m" module-index "_" arg-name))))
  ([module-index sym arg-name]
   (str (gensym (str "m" module-index "_" (check-C-var (str sym "_") arg-name))))))

(defn global-var
  ([arg-name]
   (for [module-index (sm/get-in-val [.module .index])]
     (make-global-var module-index arg-name)))
  ([sym arg-name]
   (for [module-index (sm/get-in-val [.module .index])]
     (make-global-var module-index sym arg-name))))

(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraint c-fn]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast ast))

  ;; TODO: remove these eventually
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) " "
                         (str c-fn) ">"))

  Emitter
  (encode [x]
    (encode-static x))

  (encode-static [_]
    (cond (= "" (.var c-var))
          (do
            (print-err 'could-not-encode 'ProtoImpl)
            (maybe sm/zero-sm))
          (sm/state-maybe (c-static-val (str "(Value *)" c-var) [] {} (.struct c-var))))))

(deftype CollectFieldConsts [fields ast]
  (assert (instance? ast/params-ast fields))

  Stringable
  (string-list [_]
    (list "<CollectFieldConsts" (str fields) "\n" (str ast) ">"))

  Container
  (map [x f]
    (CollectFieldConsts (f fields) (f ast)))

  (map [x f embed]
    (for [new-fields (f fields)
          new-ast (f ast)]
      (CollectFieldConsts new-fields new-ast)))

  ast/IsCode
  (ast/generates-code? [x]
    (maybe x))

  Emitter
  (emit [_]
    (for [expr (emit ast)
          field-constrs (get-param-constraints fields)
          curr-constrs (sm/get-in-val [.fn-context .field-constrs])
          :let [field-constrs (either (map curr-constrs (fn [curr]
                                                          (either (c/compose-constraints
                                                                   (ast/file-name ast)
                                                                   (ast/line-number ast)
                                                                   field-constrs curr)
                                                                  (abort))))
                                      field-constrs)]
          _ (sm/assoc-in-val [.fn-context .field-constrs] (maybe field-constrs))]
      expr))

  (remove-tail [_]
    ast))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraint c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? ArityValPtr var))
  (assert (instance? CFnPtr c-fn))

  (let [ast (unwrap-tail ast)
        new-impl (ProtoImpl dispatch-type var ast param-constraints result-constraint c-fn)
        ns-sym (either (ast/namespace fn-sym)
                       'core)]
    (comp (for [_ (sm/when-not (ast/namespace fn-sym))
                _ (sm/get-in-val [.module .protocols (ast/untag proto-sym) (ast/untag fn-sym)])
                _ (sm/update-in-val [.module .protocols (ast/untag proto-sym) (ast/untag fn-sym)]
                                    (fn [p-disp]
                                      (assert (instance? ProtoDispatcher p-disp))
                                      (assoc-in p-disp [.p-impls arg-count dispatch-type] new-impl)))]
            '_)
          (for [ns-file (either (map (ast/namespace fn-sym)
                                     (fn [sym]
                                       (sm/get-in-val [.module .namespaces sym .path])))
                                (sm/state-maybe 'core))]
            (cond (= ns-file 'core)
                  (send core-agent
                        (fn [mod]
                          (either (update-in mod [.protocols (ast/untag proto-sym) (ast/untag fn-sym)]
                                             (fn [p-disp]
                                               (assert (instance? ProtoDispatcher p-disp))
                                               (assoc-in p-disp [.p-impls arg-count dispatch-type]
                                                         new-impl)))
                                  (do
                                    (print-err "Compiler Error: missing proto dispatcher for"
                                               proto-sym fn-sym)
                                   (abort)))))
                  (either (map (get (extract modules) ns-file)
                               (fn [ast-emitter]
                                 (send ast-emitter
                                       (fn [ctxt]
                                         (update-context
                                          ctxt
                                          (comp (sm/update-in-val
                                                 [.module .protocols
                                                  (ast/untag proto-sym) (ast/untag fn-sym)]
                                                 (fn [p-disp]
                                                   (assert (instance? ProtoDispatcher p-disp))
                                                   (assoc-in p-disp [.p-impls arg-count dispatch-type]
                                                             new-impl)))
                                                (compilation-error "Compiler Error: missing proto dispatcher for"
                                                                   proto-sym fn-sym)))))))
                          (do
                            (print-err "Compiler Error: missing namespace for"
                                       proto-sym fn-sym)
                            (abort))))))))

(defn lookup-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (comp (flat-map (sm/when (ast/namespace proto-sym))
                  (fn [ns-sym]
                    (sm/get-in-val [.module .namespaces ns-sym .protocols
                                    (ast/untag proto-sym)])))
        (sm/get-in-val [.module .protocols  (ast/untag proto-sym)])

        (sm/when (get-in (extract core-agent) [.protocols (ast/untag proto-sym)]))))

(defn get-core-proto-impl [proto-sym fn-sym arg-count type-num]
  (flat-map (sm/get-in-val [.module .index])
            (fn [curr-mod]
              (cond (= curr-mod 0)
                    (sm/get-in-val [.module .protocols (ast/untag proto-sym) (ast/untag fn-sym)
                                    .p-impls arg-count type-num])
                    (sm/new-sm
                     (fn [s]
                       (map (let [core-prom (promise)]
                              (send core-agent
                                    (fn [mod]
                                      (deliver core-prom
                                               (get-in mod [.protocols (ast/untag proto-sym) (ast/untag fn-sym)
                                                            .p-impls arg-count type-num]))
                                      mod))
                              (extract core-prom))
                            (fn [expr]
                              [expr s]))))))))

(defn get-proto-impl [proto-sym fn-sym arg-count type-num]
  (comp (flat-map (sm/when (ast/namespace fn-sym))
                  (fn [ns-sym]
                    (sm/get-in-val [.module .namespaces ns-sym .protocols
                                    (ast/untag proto-sym) (ast/untag fn-sym) .p-impls
                                    arg-count type-num])))
        (sm/get-in-val [.module .protocols  (ast/untag proto-sym)
                        (ast/untag fn-sym) .p-impls arg-count type-num])

        (get-core-proto-impl proto-sym fn-sym arg-count type-num)
        ;; (compilation-error "Invalid protocol fn:"
        ;;                    (str "'" fn-sym "' in")
        ;;                    (str (ast/file-name fn-sym) ",")
        ;;                    (ast/line-number fn-sym))
        ))

(def DefExprs (any-of c-code
                      c-static-reified
                      c-constructor
                      c-static-str
                      c-static-int
                      c-static-fn
                      c-static-sym
                      c-maybe-fn
                      c-list-fn
                      c-vector-fn
                      c-protocol-fn))

(defn new-module-def [sym value]
  (assert (instance? ast/tagged-symbol sym))
  (assert (instance? DefExprs value))

  (comp (redef-proto-fn-error sym)
        (flat-map (sm/assoc-in-val [.module .declarations sym] nothing)
                  (fn [_]
                    (sm/assoc-in-val [.module .values sym] value)))))

(defn lookup-declaration [sym]
  (flat-map (namespace-index sym)
            (fn [ns-index]
              (sm/get-in-val [.module .declarations sym '_]))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  ;; (sm/assoc-in-val [.fn-context .syms sym] expr)
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn constrain-var [file-name line-number var constraint]
  (cond (or (= "" var)
            (instance? c/AllValues constraint))
        sm-nop

        (append-constraint var constraint file-name line-number)))

(defn lookup-closure-sym [sym]
  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (for [sym-info (sm/get-in-val [.fn-context .context-syms sym])
          closures (sm/get-in-val [.fn-context .closed-over .closures])
          expr (either (some closures
                             (fn [[closure-var sym-literal]]
                               (for [_ (= sym sym-literal)]
                                 ;; already added to closures
                                 (map (sm/update-in-val [.fn-context .closed-over .refs-map closure-var]
                                                        inc)
                                      (fn [_]
                                        (-> sym-info
                                            clear-init
                                            (.c-var closure-var)
                                            (.refs-map {closure-var 1})))))))
                       ;; first time sym is closed over
                       (for [sym-count (sm/get-in-val [.fn-context .sym-count])
                             _ (sm/update-in-val [.fn-context .sym-count] inc)
                             :let [constraint (expr-constraints sym-info)
                                   closure-var (str "val" sym-count)]
                             _ (set-constraint closure-var constraint)
                             _ (sm/update-in-val [.fn-context .closed-over .closures]
                                                 (fn [closures]
                                                   (conj closures [closure-var sym])))
                             _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var]
                                                1)]
                         (-> sym-info
                             clear-init
                             (.c-var closure-var)
                             (.refs-map {closure-var 1}))))]
      expr)))

(defn get-sym [sym]
  (assert (instance? ast/tagged-symbol sym))

  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (either (map (ast/namespace sym)
                 (fn [ns-sym]
                   ;; lookup namespace-qual sym
                   (comp (sm/get-in-val [.module .namespaces ns-sym
                                         .values (ast/tag (.base sym))])
                         (sm/get-in-val [.mod-files file-name .namespaces ns-sym
                                         .values (ast/tag (.base sym))]))))
            (comp
             ;; lookup sym in local fn context
             (sm/get-in-val [.fn-context .syms sym])

             ;; lookup symbol in enclosing context of fn
             (lookup-closure-sym sym)

             ;; lookup in current module
             (comp (sm/get-in-val [.module .values sym])
                   (sm/get-in-val [.module .declarations sym '_]))

             ;; lookup in core module
             (sm/new-sm (fn [s]
                          (map (get-in (extract core-agent) [.values sym])
                               (fn [expr]
                                 [expr s]))))

             ;; lookup in imported module by filename of sym
             (sm/get-in-val [.mod-files file-name .values sym])

             ;; last ditch effort to find it in core module
             (sm/new-sm (fn [s]
                          (let [core-prom (promise)]
                            (send core-agent (fn [mod]
                                               (deliver core-prom (get-in mod [.values sym]))
                                               mod))
                            (map (extract core-prom)
                                 (fn [expr]
                                   [expr s])))))))))

(defn lookup-sym [sym]
  (assert (instance? ast/tagged-symbol sym))

  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (for [expr (comp (get-sym sym)
                     (either (map (ast/namespace sym)
                                  (fn [ns-sym]
                                    (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                                       (str file-name ":") line-number)))
                             (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                                (str file-name ":") line-number)))
          _ (comp (constrain-var file-name line-number (.c-var expr) (expr-constraints expr))
                  sm-nop)

          constraint (get-constraint (.c-var expr))]
      (expr-constraints expr constraint))))

(extend-type ConstrainedAST
  Emitter
  (emit [x]
    (let [ast (.ast x)
          constraint (.constraint x)]
      (for [expr (emit ast)
            c (lookup-constraint constraint)
            _ (append-constraint (.c-var expr) c (ast/file-name ast) (ast/line-number ast))]
        expr))))

(extend-type c-field
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    ;; TODO
    (print-err 'c-field 'comp*)
    (abort)
    empty-c-code)

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (either (for [refs (get-in y [.refs-map (.c-var x)])
                  _ (< 0 refs)]
              (-> y
                  (.init [(.init x)
                          "incRef(" (.c-var x) ", " (str refs) ");\n"
                          ;; TODO: it would be nice to remove the need for this dec_and_free
                          ;; do just one after all needed fields are extracted
                          "dec_and_free(" (.parent x) ", 1);\n"
                          (.init y)])
                  (.refs-map (merge-with + {(.parent x) 1}
                                         (dissoc (.refs-map y) (.c-var x))))
                  sm/state-maybe))
            (sm/state-maybe y))))

(extend-type c/Constraints
  Emitter
  (encode-static [x]
    ;; TODO: for some reason, encoding the sym doesn't alwys work,
    ;; fortunately, it's not needed

    (cond (= c/top-type x)
          (sm/state-maybe (c-static-val "all_values" [] {} "all_values_struct"))

          (let [x (either (map (instance? c/SymbolConstraints x)
                               (fn [x]
                                 (-> x
                                     (.var "")
                                     (.sym nothing))))
                          x)]
            (comp (for [args (sm/traverse (type-args x) encode-static)
                        struct (global-var "cnstr_")
                        var (global-var "cnstr_")
                        _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
                                    (str (count args)) (flat-map args (fn [expr]
                                                                        [",(Value *)&" (.c-struct expr)]))
                                    "};" line-sep
                                    "Value *" var " = (Value *)&" struct ";" line-sep])
                        expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
                    expr)
                  ;; TODO remove
                  (for [_ (debug 'missing x)
                        :when nothing]
                    '_))))))

(extend-type c/StaticConstraints
  Emitter
  (runtime-check [constraint value-info checked-var]
    [])

  (runtime-check [constraint value-info sym-location checked-var]
    []))

(extend-type c/NoValues
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["abort();\n#\n"])

  (runtime-check [constraint value-info sym-location checked-var]
    ["abort();\n#\n"]))

(extend-type c/AllValues
  Emitter
  (emit [constraint]
    (wrap sm/zero-sm empty-c-code))

  (runtime-check [constraint value-info checked-var]
    [])

  (runtime-check [constraint value-info sym-location checked-var]
    []))

(defn get-type-sym-info [type-symbol]
  (comp (either (or (map (get-in (extract core-agent) [.types (ast/untag type-symbol)])
                         sm/state-maybe)
                    (map (ast/namespace type-symbol)
                         (fn [sym-ns]
                           (sm/get-in-val [.module .namespaces sym-ns .types
                                           (ast/untag type-symbol)]))))
                (sm/get-in-val [.module .types (ast/untag type-symbol)]))
        (let [result-p (promise)]
          (send core-agent (fn [mod]
                             (deliver result-p (get-in mod [.types (ast/untag type-symbol)]))
                             mod))
          (compilation-error "Invalid type" (str "'" type-symbol "'") (extract result-p) "at"
                             (ast/file-name type-symbol) (ast/line-number type-symbol)))
        (compilation-error "Invalid type" (str "'" type-symbol "'") "at"
                           (ast/file-name type-symbol) (ast/line-number type-symbol))))

(defn emit-sym-constraint [constraint]
  (let [file-name (ast/file-name constraint)
        line-number (ast/line-number constraint)]
    (flat-map (lookup-constraint constraint)
              (fn [constraint]
                (either (for [_ (= "" (c/extract-var constraint))
                              sym (c/extract-sym constraint)]
                          (for [expr (lookup-sym (ast/tag sym file-name line-number))
                                curr-c (get-constraint (.c-var expr))
                                _ (append-constraint (.c-var expr) constraint "" 0)
                                checked-var (genlocal 'checked)]
                            (cond (instance? c-param expr)
                                  empty-c-code
                                  (c-code (.c-var expr)
                                          (let [rt-check (runtime-check (c/update-var constraint (.c-var expr))
                                                                        curr-c "" 0
                                                                        checked-var)]
                                            (either (empty? rt-check)
                                                    [line-sep "if(1){int " checked-var " = 1;" line-sep
                                                     rt-check
                                                     line-sep "if(!" checked-var "){abort();}}" line-sep]))
                                          ;; TODO: change 'c/top-type' to 'constraint'
                                          ;; (and all other calls to c-code
                                          {} c/top-type))))
                        (map (constrain-var "" 0 (c/extract-var constraint) constraint)
                             (fn [_]
                               empty-c-code)))))))

;; TODO: how many of these impls would work for ValueConstraint
(extend-type c/SymbolConstraints
  Emitter
  (validate-field [c m fields file-name line-number]
    (either (map (.sym c)
                 (fn [c-sym]
                   (either (some fields (partial = c-sym))
                           (do
                             (print-err "Invalid field"
                                        (str "'" c-sym "'")
                                        "at:" (str file-name ":")
                                        line-number)
                             (abort)))
                   (-> m
                       (dissoc c-sym)
                       (assoc c-sym (either (c/compose-constraints file-name line-number
                                                                   c
                                                                   (either (get m c-sym)
                                                                           c/top-type))
                                            (abort))))))
            m))

  (update-syms [c _]
    (either (for [old-sym (.sym c)]
              (comp (for [new-sym (sm/get-in-val [0 (ast/tag old-sym)])]
                      ;; if 'new-sym' isn't Tagged, the constraint is
                      ;; no longer needed
                      (Right (cond (instance? Tagged new-sym)
                                   (c/update-sym c (ast/untag new-sym))
                                   c/top-type)))
                    (sm/state-maybe (Right c))))
            (sm/state-maybe (Right c))))

  (emit [constraint]
    (emit-sym-constraint constraint)))

(extend-type c/DynamicFields
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (-> (c/ReifiedFields (rest param-exprs) (.path c) (.sym c) (.var c))
        (c/update-path file-name line-number)
        sm/state-maybe))

  (old-reify-c [c param-exprs file-name line-number]
    (-> (c/ReifiedFields (rest param-exprs) (.path c) (.sym c) (.var c))
        (c/update-path file-name line-number)
        sm/state-maybe)))

(extend-type c/DynamicParamConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (either (map (get param-exprs (.param-index c))
                 (fn [param-expr]
                   (map (get-constraint (.c-var param-expr))
                        (fn [param-c]
                          (-> (reverse (.path c))
                              (reduce param-c (fn [new-c [file line]]
                                                (c/update-path new-c file line)))
                              (c/set-type (.result-type c)))))))
            (sm/state-maybe c/top-type)))

  (old-reify-c [c param-exprs file-name line-number]
    (either (map (get param-exprs (.param-index c))
                 (fn [param-expr]
                   (map (get-constraint (.c-var param-expr))
                        (fn [param-c]
                          (-> (reverse (.path c))
                              (reduce param-c (fn [new-c [file line]]
                                                (c/update-path new-c file line)))
                              (c/set-type (.result-type c)))))))
            (sm/state-maybe c/top-type))))

(extend-type c/DynamicItemConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (comp (for [param-expr (sm/when (get param-exprs (.param-index c)))
                param-c (get-constraint (.c-var param-expr))
                _ (debug 'dyn-item-param-c param-c)
                item-expr (-> param-c
                              c/extract-dynamic-fields
                              ((fn [x]
                                  (print-err 'dyn-fields x)
                                  (print-err 'item-index (.item-index c)
                                             (get x (.item-index c)))
                                  x))
                              (get (.item-index c))
                              sm/when)
                _ (debug 'dyn-item-item-expr item-expr)
                item-c (get-constraint (.c-var item-expr))
                _ (debug 'dyn-item-item-c item-c)]
            (-> (.path c)
                reverse
                (reduce item-c
                        (fn [new-c [file line]]
                          (c/update-path new-c file line)))))
          (sm/state-maybe c/top-type)))

  (old-reify-c [c param-exprs file-name line-number]
    (comp (for [param-expr (sm/when (get param-exprs (.param-index c)))
                param-c (get-constraint (.c-var param-expr))
                item-expr (-> param-c
                              c/extract-dynamic-fields
                              (get (.item-index c))
                              sm/when)
                item-c (get-constraint (.c-var item-expr))]
            (-> (.path c)
                reverse
                (reduce item-c
                        (fn [new-c [file line]]
                          (c/update-path new-c file line)))))
          (sm/state-maybe c/top-type))))


(extend-type c/DynamicResultConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (-> c
        .invokable-c
        c/extract-dynamic-params
        (sm/traverse (fn [dyn-c]
                       (either (or (for [dyn-param (instance? c/DynamicParamConstraint dyn-c)
                                         expr (get param-exprs (.param-index dyn-param))]
                                     (get-result-constraint expr (.num-args c)))
                                   (for [dyn-param (instance? c/DynamicItemConstraint dyn-c)
                                         expr (get-in param-exprs [(.param-index dyn-param)])]
                                     ;; TODO: there could be multiple dyn fields because of a SumConstraint
                                     (for [dynamic-fields (map (get-constraint (.c-var expr))
                                                               c/extract-dynamic-fields)
                                           field-expr (sm/when (get dynamic-fields (.item-index dyn-param)))
                                           rc (get-result-constraint field-expr (.num-args c))]
                                       rc)))
                               sm/zero-sm)))
        (map (fn [dyn-param-cs]
               (c/sum-type dyn-param-cs)))
        (comp (sm/state-maybe c/top-type))
        (map (fn [r]
               (print-err 'dyn-result r)
               r))))

  (old-reify-c [c param-exprs file-name line-number]
    (-> c
        .invokable-c
        c/extract-dynamic-params
        (sm/traverse (fn [dyn-c]
                       (either (or (for [dyn-param (instance? c/DynamicParamConstraint dyn-c)
                                         expr (get param-exprs (.param-index dyn-param))]
                                     (get-result-constraint expr (.num-args c)))
                                   (for [dyn-param (instance? c/DynamicItemConstraint dyn-c)
                                         expr (get-in param-exprs [(.param-index dyn-param)])]
                                     ;; TODO: there could be multiple dyn fields because of a SumConstraint
                                     (for [dynamic-fields (map (get-constraint (.c-var expr))
                                                               c/extract-dynamic-fields)
                                           field-expr (sm/when (get dynamic-fields (.item-index dyn-param)))
                                           rc (get-result-constraint field-expr (.num-args c))]
                                       rc)))
                               sm/zero-sm)))
        (map (fn [dyn-param-cs]
               (c/sum-type dyn-param-cs)))
        (comp (sm/state-maybe c/top-type)))))

(extend-type c/DynamicConstraint
  Emitter
  (runtime-check [constraint value-info checked-var]
    [])

  (runtime-check [constraint value-info sym-location checked-var]
    []))

(extend-type c/ItemsConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (sm/state-maybe (either (or (some (.items-constraints c) (partial = c/bottom-type))
                                (and (= c/bottom-type (.tail-constraint c))
                                     (first (.constraints (.tail-constraint c)))
                                     (maybe (.tail-constraint c))))
                            c)))

  (old-reify-c [c param-exprs file-name line-number]
    (for [new-items (sm/traverse (.items-constraints c)
                                 (fn [c]
                                   (old-reify-c c param-exprs file-name line-number)))
          new-tail (old-reify-c (.tail-constraint c) param-exprs file-name line-number)]
      (either (or (some new-items (partial = c/bottom-type))
                  (and (= c/bottom-type new-tail)
                       (first (.constraints (.tail-constraint c)))
                       (maybe new-tail)))
              (c/ItemsConstraint new-items
                                 new-tail
                                 (.path c) (.sym c) (.var c)))))

  (promote-inferred [c]
    (-> c
        (.tail-constraint (promote-inferred (.tail-constraint c)))
        (.items-constraints (map (.items-constraints c) promote-inferred))))

  (update-syms [ast _]
    (either (map (.sym ast)
                 (fn [old-sym]
                   (comp (map (sm/get-in-val [0 (ast/tag old-sym)])
                              (fn [new-sym]
                                (Right (.sym ast (maybe (ast/untag new-sym))))))
                         (sm/state-maybe (Right ast)))))
            (sm/state-maybe (Right ast))))

  (runtime-check [constraint value-info checked-var]
    (let [items-cs (c/extract-items-constraints constraint)]
      (cond (or (c/satisfied-by constraint value-info)
                (empty? items-cs))
            []

            [(let [rt-check (-> (c/TypeConstraint {c/ListType #{} c/VectorType #{}} (.path constraint) 'Sequence
                                                  (.sym constraint) (.var constraint))
                                (runtime-check value-info checked-var))]
               (either (empty? rt-check)
                       ["if (" checked-var "){" rt-check "}"]))
             (let [min-count (str (count items-cs))]
               ["if (" checked-var " && countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
                checked-var "= 0;" line-sep "}"])
             (let [items (map (range (inc (count items-cs)))
                              (partial str (.var constraint) "_"))
                   rt-checks (for [[constraints item] (zip-lists items-cs items)]
                               (let [constraints (either (map (.sym constraint)
                                                              (partial c/update-sym constraints))
                                                         constraints)]
                                 (-> constraints
                                     (c/update-var item)
                                     (runtime-check value-info checked-var))))]
               (cond (every rt-checks empty?)
                     []

                     ["if (" checked-var ") {" line-sep
                      "incRef(" (.var constraint) ", 1);" line-sep
                      (destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                      rt-checks
                      "if (" checked-var "){"
                      (map items (fn [item]
                                   (str "dec_and_free(" item ", 1);" line-sep)))
                      "}}"]))
             line-sep])))

  (runtime-check [constraint value-info sym-location checked-var]
    (let [items-cs (c/extract-items-constraints constraint)]
      (cond (or (c/satisfied-by constraint value-info)
                (empty? items-cs))
            []

            [(let [rt-check (-> (c/TypeConstraint {c/ListType #{} c/VectorType #{}} (.path constraint) 'Sequence
                                                  (.sym constraint) (.var constraint))
                                (runtime-check value-info sym-location checked-var))]
               (either (empty? rt-check)
                       ["if (" checked-var "){" rt-check "}"]))
             (let [min-count (str (count items-cs))]
               ["if (" checked-var " && countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
                ;; "\n#ifndef EMBEDDED\n"
                "fprintf(stderr, \"Insufficient values for '"
                (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
                "fprintf(stderr, \"Needed " min-count
                ", got %\" PRId64 \"\\n\", ((Integer *)count((FnArity *)0, "
                (.var constraint) "))->numVal);" line-sep
                "fprintf(stderr, \"" (interpose (c/format-path constraint (inc (count (.path constraint))))
                                                "\\n")
                "\\n\");"
                ;; "\n#endif\n"
                checked-var "= 0;" line-sep "}"])
             (let [items (map (range (inc (count items-cs)))
                              (partial str (.var constraint) "_"))
                   rt-checks (for [[constraints item] (zip-lists items-cs items)]
                               (let [constraints (either (map (.sym constraint)
                                                              (partial c/update-sym constraints))
                                                         constraints)]
                                 (-> constraints
                                     (c/update-var item)
                                     (runtime-check value-info sym-location checked-var))))]
               (either (map (every rt-checks empty?) (fn [_] []))
                       ["if (" checked-var ") {" line-sep
                        "incRef(" (.var constraint) ", 1);" line-sep
                        (destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                        rt-checks
                        "if (" checked-var "){"
                        (map items (fn [item]
                                     (str "dec_and_free(" item ", 1);" line-sep)))
                        "}}"]))
             line-sep]))))

(extend-type c/InferredInner
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (sm/state-maybe (either (or (= c/bottom-type (.contents c))
                                (= c/top-type (.contents c)))
                            c)))

  (old-reify-c [c param-exprs file-name line-number]
    (map (old-reify-c (.contents c) param-exprs file-name line-number)
         (fn [new-contents]
           (either (or (= c/bottom-type new-contents)
                       (= c/top-type new-contents))
                   (.contents c new-contents)))))

  (promote-inferred [c]
    (c/extract-coll-constraint c))

  (runtime-check [constraint value-info checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors/HashMaps
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check
                     line-sep "}"]))))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors/HashMaps
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type sym-location checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"])))))

(extend-type c/CollectionOf
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (sm/state-maybe (either (or (= c/bottom-type (.contents c))
                                (= c/top-type (.contents c)))
                            c)))

  (old-reify-c [c param-exprs file-name line-number]
    (map (old-reify-c (.contents c) param-exprs file-name line-number)
         (fn [new-contents]
           (either (or (= c/bottom-type new-contents)
                       (= c/top-type new-contents))
                   (.contents c new-contents)))))

  (promote-inferred [c]
    (.contents c (promote-inferred (.contents c))))

  (emit [constraint]
    (emit-sym-constraint constraint))

  (runtime-check [constraint value-info checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors/HashMaps
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type checked-var)]
            ;; TODO: if there's no chance of it being a Maybe, don't generate a check
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"]))))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors/HashMaps
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type sym-location checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"])))))

(extend-type c/TypeConstraint
  Emitter
  (to-constraint [ast]
    (cond (empty? (.type-maps ast))
          (map (get-type-sym-info (ast/tag (.type-sym ast)))
               (fn [constraint]
                 (-> (either (map (.sym ast)
                                  (partial c/update-sym constraint))
                             constraint)
                     (c/update-var (.var ast))
                     (c/replace-path (.path ast)))))

          (sm/state-maybe ast)))

  (emit [ast]
    (let [untagged (ast/untag (.type-sym ast))]
      (comp (emit-sym-constraint ast)
            (compilation-error "Unknown type" (str "'" (.type-sym ast) "'") "at"
                               (str (ast/file-name ast) ":") (ast/line-number ast)))))

  (runtime-check [constraint value-info checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          ["if (" checked-var "){"
           "switch (" (.var constraint) "->type) {"
           (map (keys (.type-maps constraint)) (fn [type-num]
                                                 ["case " type-num ": " ]))
           "break;\ndefault:"
           checked-var " = 0;}}"]))

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var "){"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Invalid type of value for '"
                     (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Needed " (str (.type-sym constraint))
                     ", got %s\\n\", extractStr(type_name((FnArity *)0, " (.var constraint) ")));"
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MaxValue
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["if (" checked-var " && "
     (str (.max constraint)) " < ((Integer *)" (.var constraint) ")->numVal) {"
     checked-var " = 0;}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var ") {"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
                     "' is too large %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Maximum allowed value is " (str (.max constraint))
                     ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MinValue
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["if (" checked-var " && "
     (str (.min constraint)) " > ((Integer *)" (.var constraint) ")->numVal) {"
     checked-var " = 0;}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var ") {"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
                     "' is too small %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Minimum allowed value is " (str (.min constraint))
                     ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/FieldConstraint
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (let [sym (ast/tag sym)]
                     (for [sym-info (lookup-sym sym)
                           field-var (lookup-sym (ast/tag (.field constraint)))
                           _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                            (.c-var sym-info) (.field-var constraint (.c-var field-var)))]
                       (.refs-map sym-info (dissoc (.refs-map sym-info) (.c-var sym-info)))))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info checked-var]
    ["if(" checked-var ") {\n"
     "Value *dork = hasField((FnArity *)0, incRef(" (.var constraint) ", 1), "
     (.field-var constraint) ");\n" "if (isNothing(dork,\"\",0)) {"
     checked-var " = 0;}" line-sep
     "dec_and_free(dork, 1);}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if(!" checked-var ") {\n"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value '" (either (.sym constraint) "<unknown>")
                     "' of type '%s' does not have field '"
                     (.field constraint) "' %s\\n\", extractStr(type_name((FnArity *)0, "
                     (.var constraint) ")), " sym-location ");" line-sep
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MultiConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (sm/state-maybe (either (some (.constraints c) (partial = c/bottom-type))
                            (let [new-cs (-> (.constraints c)
                                             (flat-map (fn [reified]
                                                         (either (map (instance? c/MultiConstraint reified)
                                                                      .constraints)
                                                                 [reified])))
                                             (remove (partial = c/top-type)))]
                              (either (or (and (empty? new-cs)
                                               (maybe c/top-type))
                                          (and (= 1 (count new-cs))
                                               (first new-cs)))
                                      (reduce new-cs c/top-type c/intersect))))))

  (old-reify-c [constraint param-exprs file-name line-number]
    (for [new-cs (sm/traverse (.constraints constraint)
                              (fn [c]
                                (old-reify-c c param-exprs file-name line-number)))]
      (either (some new-cs (partial = c/bottom-type))
              (let [new-cs (-> new-cs
                               (flat-map (fn [reified]
                                           (either (map (instance? c/MultiConstraint reified) .constraints)
                                                   [reified])))
                               (remove (partial = c/top-type)))]
                (either (or (and (empty? new-cs)
                                 (maybe c/top-type))
                            (and (= 1 (count new-cs))
                                 (first new-cs)))
                        (reduce new-cs c/top-type c/intersect))))))

  (promote-inferred [c]
    (.constraints c (map (.constraints c) promote-inferred)))

  (validate-field [c m fields file-name line-number]
    (either (for [first-c (first (.constraints c))
                  c-sym (c/extract-sym first-c)]
              (do
                (either (some fields (partial = c-sym))
                        (do
                          (print-err "Invalid field"
                                     (str "'" c-sym "'")
                                     "at:" (str file-name ":")
                                     line-number)
                          (abort)))
                (-> m
                    (dissoc c-sym)
                    (assoc c-sym (either (c/compose-constraints file-name line-number
                                                                c
                                                                (either (get m c-sym)
                                                                        c/top-type))
                                         (abort))))))
            m))

  (runtime-check [constraint value-info checked-var]
    (cond (or (some (.constraints constraint)
                    (partial instance? c/StaticConstraints))
              (c/satisfied-by constraint value-info))
          []

          (map (.constraints constraint)
               (fn [c]
                 (runtime-check c value-info checked-var)))))

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (or (some (.constraints constraint)
                    (partial instance? c/StaticConstraints))
              (c/satisfied-by constraint value-info))
          []

          (map (.constraints constraint)
               (fn [c]
                 (runtime-check c value-info sym-location checked-var)))))

  (emit [constraint]
    (map (sm/traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type c/ResultConstraint
  Emitter
  (reify-c [c param-exprs file-name line-number]
    (sm/state-maybe (either (= c/bottom-type (.assertion c))
                            c)))

  (old-reify-c [c param-exprs file-name line-number]
    (map (old-reify-c (.assertion c) param-exprs file-name line-number)
         (fn [new-assertion]
           (either (= c/bottom-type new-assertion)
                   (.assertion c new-assertion)))))

  (update-syms [constraint _]
    (sm/state-maybe (Left constraint)))

  (emit [ast]
    (-> ast .assertion (c/update-var "#result") emit))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Handled other places
    []))

(extend-type Maybe
  Emitter
  (encode-static [v]
    (comp (sm/get-in-val [.constants .encoded v])
          (either (map v (fn [v]
                           (for [_ (debug 'encoding-maybe v (sha1 v))
                                 expr (encode-static v)
                                 struct (global-var "maybe_")
                                 var (global-var "maybe_")
                                 _ (declare ["Maybe " struct " = (Maybe){MaybeType, -2, 0, (Value *)&"
                                             (.c-struct expr) "};" line-sep
                                             "Maybe *" var " = &" struct ";" line-sep])
                                 _ (sm/assoc-in-val [.constants .encoded v] (c-static-val var [] {} struct))]
                             (do
                               ;; TODO: we need to encode the constraints on 'var' as well
                               (comp expr
                                     (c-static-val var [] {} struct))))))
                  (wrap sm/zero-sm
                        (c-static-val "nothing" [] {} "nothing_struct"))))))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str))

  Emitter
  (encode-static [l]
    (comp (sm/get-in-val [.constants .encoded l])
          (either (map (first l)
                       (fn [head]
                         (for [tail-expr (encode-static (rest l))
                               head-expr (encode-static head)
                               struct (global-var "list_")
                               var (global-var "list_")
                               _ (declare ["List " struct " = {ListType, -2, 0, " (str (count l))
                                           ", (Value *)&" (.c-struct head-expr)
                                           ", &" (.c-struct tail-expr) "};" line-sep])
                               _ (sm/assoc-in-val [.constants .encoded l] (c-static-val var [] {} struct))]
                           (comp tail-expr
                                 head-expr
                                 (c-static-val var [] {} struct)))))
                  (wrap sm/zero-sm
                        (c-static-val "empty_list" [] {} "empty_list_struct")))))

  (wrap-tail [asts args]
    (let [asts (reverse asts)]
      (Left (either (empty? asts)
                    (let [[tail & init] asts]
                      (-> (tail-call tail args)
                          (cons init)
                          reverse)))))))

(defn encodeVectorInfo [v]
  (inline C Vector "
  Vector *v = (Vector *)v_0;

  Vector *array = empty_vect;
  for (int i = 0; i < v->count; i++) {
    Value *val = v->tail[i];
    incRef(val, 1);
    array = mutateVectConj(array, val);
  }

  Vector *result = empty_vect;
  result = mutateVectConj(result, integerValue(v->shift));
  result = mutateVectConj(result, integerValue(v->tailOffset));
  if (v->root != (VectorNode *)0) {
    fprintf(stderr, \"Encode Vector root\\n\");
    abort();
  } else {
    result = mutateVectConj(result, nothing);
  }
  result = mutateVectConj(result, (Value *)array);

  dec_and_free(v_0, 1);
  return((Value *)result);
  "))

(def vector-array-len (inline C Integer "(Value *)&(Integer){IntegerType,-2,VECTOR_ARRAY_LEN}"))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str))

  Emitter
  (reify-c [v param-exprs file-name line-number]
    (sm/state-maybe (either (some v (partial = c/bottom-type))
                            v)))

  (old-reify-c [v param-exprs file-name line-number]
    (map (sm/traverse v (fn [x]
                          (old-reify-c x param-exprs file-name line-number)))
         (fn [new-v]
           (either (some new-v (partial = c/bottom-type))
                   new-v))))

  (encode-static [v]
    (comp (sm/get-in-val [.constants .encoded v])
          (let [[shift offset root array] (encodeVectorInfo v)]
            (for [items (sm/traverse array encode-static)
                  root (either (map root encode-static)
                               (wrap sm/zero-sm (c-static-val "NULL" [] {} "NULL")))
                  struct (global-var "vect_")
                  var (global-var "vect_")
                  _ (declare ["Vector " struct " = {VectorType, -2, 0, "
                              (str (count array))
                              ", " (str shift) ", " (str offset) ", "
                              (.c-struct root)
                              (map items
                                   (fn [expr]
                                     (str ", (Value *)&" (.c-struct expr))))
                              (map (range (- vector-array-len (count array))) (fn [_] ", 0"))
                              "};" line-sep
                              "Value *" var " = (Value *)&" struct ";" line-sep])
                  expr (collapse-expressions (comp items [(c-static-val var [] {} struct)]))
                  _ (sm/assoc-in-val [.constants .encoded v] expr)]
              expr))))

  (wrap-tail [asts params]
    (Left (either (flat-map (last asts)
                            (fn [tail]
                              (store asts (dec (count asts))
                                     (tail-call tail params))))
                  asts))))

(defn set-result-constraint [result-var file-name line-number]
  ;; TODO: shouldn't be returning the result-constraint
  (for [result-c (get-constraint "#result")
        var-c (get-constraint result-var)
        :let [final (c/intersect result-c var-c)
              ;; TODO: this gets printed twice for constructor invokes. Why?
              ;; _ (print-err 'final file-name line-number result-var final)
              _ (and (= c/bottom-type final)
                     (do
                       (print-err "Invalid return value for function at" file-name line-number)
                       (c/conflicting-assertions final file-name line-number)
                       (abort)))]
        _ (set-constraint result-var (c/clear-vars final))
        ;; TOOD: this doesn't work if final has a SumConstraint in it.
        ;; extract-items-constraints will clear vars in that case
        _ (sm/traverse (c/extract-items-constraints final)
                       (fn [c]
                         (constrain-var file-name line-number (c/extract-var c) c)))]
    final))

(defn extract-closures []
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [closures (-> s .fn-context .closed-over .closures)]
                 (and (first closures)
                      (maybe [closures s]))))))

(defn free-closure-parent []
  (comp (map (extract-closures) (fn [_]
                                  ["if (arity->parent) "
                                   "dec_and_free(arity->parent, 1);" line-sep]))
        (sm/state-maybe "")))

(deftype TailExpr [ast]
  Stringable
  (string-list [_]
    (list (str ast)))

  Container
  (map [x f]
    (TailExpr (f ast)))

  (map [x f embed]
    (map (f x) TailExpr))

  Emitter
  (emit [_]
    (for [expr (emit ast)
          _ (set-result-constraint (.c-var expr) "" 0)]
      expr)))

(deftype TailHashMap [m]
  Stringable
  (string-list [_]
    (list (str m)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Emitter
  (emit [_]
    ;; TODO: need to test freeing the parent fn in closures
    (for [init-fn-context (sm/get-val .rt-init)
          fn-context (reset-fn-context (.subs init-fn-context {}))
          value (encode m)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .rt-init init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)
          _ (set-result-constraint (.c-var value) "" 0)
          free-parent (free-closure-parent)]
      (c-code (.c-var value) [free-parent line-sep "return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint))))

(defn collisionArray [m]
  (inline C Vector "
  HashCollisionNode *node = (HashCollisionNode *)m_0;
  int cnt = node->count;
  Vector *v = empty_vect;
  for (int i = 0; i < cnt; i++) {
    Value *val = node->array[i];
    incRef(val, 1);
    v = mutateVectConj(v, val);
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiArray [m]
  (inline C Vector "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  int cnt = __builtin_popcount(node->bitmap);
  Vector *v = empty_vect;
  for (int i = 0; i < cnt * 2; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((FnArity *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiBitmap [m]
  (inline C Integer "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  Value *result = integerValue(node->bitmap);
  dec_and_free(m_0, 1);
  return((Value *)result);
  "))

(defn arrayNodeArray [m]
  (inline C Vector "
  ArrayNode *node = (ArrayNode *)m_0;
  Vector *v = empty_vect;
  for (int i = 0; i < ARRAY_NODE_LEN; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((FnArity *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(extend-type ast/Annotated
  Emitter
  (emit [a]
    (emit (.ast a)))

  (emit-defined-value [a x]
    (emit-defined-value (.ast a) x))

  (emit-definition [a]
    (emit-definition (.ast a))))

(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (wrap sm/zero-sm (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            {} c/top-type)))

  (emit-defined-value [_ x] (wrap sm/zero-sm []))
  (emit-definition [_] (wrap sm/zero-sm [])))


(extend-type HashSet
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Emitter
  (encode-static [hs]
    (comp (sm/get-in-val [.constants .encoded hs])
          (for [m (encode-static (.set-map hs))
                struct (global-var "set_")
                var (global-var "set_")
                _ (constrain-var "" 0 var (c/TypeConstraint {(get-type hs) #{}}
                                                            empty-list 'HashSet nothing ""))
                _ (declare ["ReifiedVal " struct " = {" (str (get-type hs))
                            ", -2, 0, 1, (Value *)&" (.c-struct m) "};\n"
                            "Value *" var " = (Value *)&" struct ";" line-sep])
                :let [expr (c-static-val var [] {} struct)]
                _ (sm/assoc-in-val [.constants .encoded hs] expr)]
            expr)))

  (emit [hs]
    (for [expr (encode (.set-map hs))
          var (genlocal "set_")]
      (-> expr
          (.c-var var)
          (.init (comp (.init expr) ["Value *" var " = newHashSet((FnArity *)0, " (.c-var expr) ");" line-sep]))))))

(deftype TailCall [ast params]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) (list ">")))

  Container
  (map [x f]
    (TailCall (f ast) (map params f)))

  (map [x f embed]
    (for [new-ast (f ast)
          new-params (map params f embed)]
      (TailCall new-ast new-params)))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))

  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (emit-recursive-call ast params)
            (for [expr (emit ast)
                  curr-const (get-constraint (.c-var expr))
                  result-const (get-constraint "#result")
                  checked-var (genlocal 'checked)
                  free-parent (free-closure-parent)
                  :let [expr (cond (instance? Tagged ast)
                                   (.refs-map expr {})
                                   expr)
                        check-result (cond (instance? c-param expr)
                                           ""
                                           (let [rt-check (runtime-check (c/update-var result-const (.c-var expr))
                                                                         curr-const file-name line-number
                                                                         checked-var)]
                                             (either (empty? rt-check)
                                                     ["if(1){int " checked-var " = 1;" line-sep
                                                      rt-check
                                                      "if(!" checked-var "){abort();}}" line-sep])))]
                  _ (constrain-var file-name line-number (.c-var expr) result-const)
                  final-expr (collapse-expressions [(.init expr [(.init expr) check-result])
                                                    (c-code (.c-var expr)
                                                            [free-parent
                                                             "return(" (.c-var expr) ");" line-sep]
                                                            {(.c-var expr) 1}
                                                            c/top-type)])
                  ;; TODO: periodically enable this to check on things
                  ;; (print-err 'check (some return-assertions assert-return-type) return-type
                  ;;            (ast/file-name ast) (ast/line-number ast))

                  _ (set-result-constraint (.c-var final-expr) file-name line-number)]
              final-expr)))))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (for [expr (comp (sm/get-in-val [.constants .strings str-val])
                     (for [expr (sm/when (-> constants
                                             extract
                                             (get-in [.strings str-val])))
                           _ (sm/assoc-in-val [.constants .strings str-val]
                                              (.init expr []))
                           _ (debug 'from-constants
                                    (to-str (.init expr))
                                    (str "'" str-val "'"))]
                       expr)
                     (for [str-idx (sm/new-sm (fn [s]
                                                (assert (instance? GlobalContext s))
                                                (-> s
                                                    .constants
                                                    .strings
                                                    count
                                                    (vector s)
                                                    maybe)))
                           curr-mod (sm/get-in-val [.module .index])
                           :let [str-sym (str "m" curr-mod "_str" str-idx)
                                 str-ptr (str "m" curr-mod "_strPtr" str-idx)
                                 constraint (c/TypeConstraint {c/StringBufferType #{}}
                                                              empty-list 'String nothing str-ptr)]
                           _ (sm/assoc-in-val [.constants .strings str-val]
                                              (c-static-str str-ptr [] {} constraint str-sym))
                           _ (declare ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        Integer *hash;
        int64_t len;
        char buffer["
                                       (inc str-len)
                                       "];\n} " str-sym " = {StringBufferType, -1, 0, "
                                       str-len ", \"" (escape-chars str-val) "\"};\n"
                                       "Value *" str-ptr " = (Value *)&" str-sym ";\n"])]
                       (c-static-str str-ptr [] {} constraint str-sym)))
          _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
      expr)))

(extend-type String
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Emitter
  (cache-static-constant [s expr]
    (send constants (fn [constants]
                      (assoc-in constants [.strings s]
                                (.init expr ["Value *" (.c-var expr) ";" line-sep])))))

  (emit [str-val]
    (make-static-string str-val)))

(defn make-static-num [num]
  (for [expr (comp (sm/get-in-val [.constants .numbers num])
                   (for [expr (sm/when (-> constants
                                           extract
                                           (get-in [.numbers num])))
                         _ (sm/assoc-in-val [.constants .numbers num]
                                            (.init expr []))
                         _ (debug 'from-constants (to-str (.init expr)) num)]
                     expr)
                   (for [num-idx (sm/new-sm (fn [s]
                                              (assert (instance? GlobalContext s))
                                              (-> s
                                                  .constants
                                                  .numbers
                                                  count
                                                  (vector s)
                                                  maybe)))
                         curr-mod (sm/get-in-val [.module .index])
                         :let [num-sym (str "m" curr-mod "_num" num-idx)
                               num-ptr (str "m" curr-mod "_numPtr" num-idx)
                               constraint (c/StaticIntConstraint num empty-list nothing num-ptr)
                               var (c-static-int num-ptr [] {} constraint num-sym)]
                         _ (sm/assoc-in-val [.constants .numbers num] var)
                         _ (declare ["Integer " num-sym " = {IntegerType, -2, " num "};\n"
                                     "Value *" num-ptr " = (Value *)&" num-sym ";\n"])]
                     var))
        _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
    expr))

(extend-type Integer
  Container
  ;; TODO: remove these
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Emitter
  (cache-static-constant [n expr]
    (send constants (fn [constants]
                      (assoc-in constants [.numbers n]
                                (.init expr ["Value *" (.c-var expr) ";" line-sep])))))

  (emit [num]
    (make-static-num num)))

(extend-type BitmapIndexedNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; _ (debug 'encoding-bmi m
                items (sm/traverse (bmiArray m) (fn [v]
                                                  (either (map v (fn [v]
                                                                   (map (encode-static v) maybe)))
                                                          (sm/state-maybe nothing))))
                struct (global-var "bmi_")
                var (global-var "bmi_")
                :let [new-items (cond (empty? items)
                                      "0"
                                      (interpose (map items
                                                      (fn [v]
                                                        (either (map v (fn [expr]
                                                                         (and (= "" (.c-struct expr))
                                                                              (do
                                                                                ;; TODO: remove sometime
                                                                                (print-err 'wtf-boom expr)
                                                                                (abort)))
                                                                         (str "(Value *)&"
                                                                              (.c-struct expr))))
                                                                "NULL")))
                                                 ", "))]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/BitmapIndexedType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["BitmapIndexedNode " struct " = {BitmapIndexedType, -2, 0, "
                            (str (bmiBitmap m)) ", " new-items "};\n"
                            "Value *" var " = (Value *)&" struct ";\n"])
                expr (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                                 [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type HashCollisionNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; TODO: see just what is being encoded
                ;; _ (debug 'encoding-hash-collistion m)
                items (sm/traverse (collisionArray m) encode-static)
                struct (global-var "collision_")
                var (global-var "collision_")
                :let [new-items (interpose (map items
                                                (fn [expr]
                                                  (str "(Value *)&" (.c-struct expr))))
                                           ", ")]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/HashCollisionNodeType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["HashCollisionNode " struct " = {HashCollisionNodeType, -2, 0, "
                            (str (count items)) ", " new-items "};\n"
                            "Value *" var " = (Value *)&" struct ";\n"])
                expr (collapse-expressions (comp items [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type ArrayNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; _ (debug 'encoding-array-node m
                items (sm/traverse (arrayNodeArray m) (fn [v]
                                                        (either (map v (fn [v]
                                                                         (map (encode-static v) maybe)))
                                                                (sm/state-maybe nothing))))
                struct (global-var "arrayNode_")
                var (global-var "arrayNode_")
                :let [new-items (cond (empty? items)
                                      "0"
                                      (interpose (map items
                                                      (fn [v]
                                                        (either (map v (fn [expr]
                                                                         (str "(Value *)&"
                                                                              (.c-struct expr))))
                                                                "NULL")))
                                                 ", "))]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/ArrayNodeType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["ArrayNode " struct " = {ArrayNodeType, -2, 0, " new-items "};"
                            line-sep "Value *" var " = (Value *)&" struct ";" line-sep])
                expr (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                                 [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type HashMap
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  ast/IsCode
  (ast/generates-code? [expr]
    (maybe expr))

  Emitter
  (emit [m]
    (for [init-fn-context (sm/get-val .rt-init)
          fn-context (reset-fn-context (.subs init-fn-context {}))
          value (comp (encode-static m)
                      (encode m))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/get-val .rt-init init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)]
      ;; TODO: wtf? There shouldn't be a 'return' here
      (c-code (.c-var value) ["return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint)))

  (wrap-tail [m params]
    (Left (TailHashMap m)))

  (encode [m] (encode m "var_"))

  (encode [m var-prefix]
    (comp (encode-static m)
          (for [map-var (global-var var-prefix)
                _ (declare ["Value *" map-var " = (Value *)&emptyBMI;\n"])
                assocs (sm/traverse (vec m)
                                    (fn [[sym var]]
                                      (for [sym-var (cond (instance? Tagged sym)
                                                          (emit (ast/quoted-ast sym))
                                                          (emit sym))
                                            expr (comp (encode-static var)
                                                       (encode var))]
                                        [(.init sym-var) (.init expr)
                                         map-var " = hashMapAssoc((Value *)" map-var
                                         ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"])))
                _ (constrain-var "" 0 map-var hashmap-constraint)]
            (c-code map-var (comp* [] assocs) {} hashmap-constraint)))))

(extend-type ast/quoted-ast
  Emitter
  (update-syms [x _]
    (sm/state-maybe (Left x)))

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (for [expr (sm/get-in-val [.constants .symbols sym])
                  _ (constrain-var (ast/file-name ast) (ast/line-number ast)
                                   (.c-var expr) (.constraints expr))]
              expr)
            ;; (for [expr (sm/when (-> constants
            ;;                         extract
            ;;                         (get-in [.symbols sym])))
            ;;       _ (sm/assoc-in-val [.constants .symbols sym]
            ;;                          (.init expr []))
            ;;       _ (constrain-var (ast/file-name ast) (ast/line-number ast)
            ;;                        (.c-var expr) (.constraints expr))
            ;;       _ (debug 'from-constants (to-str (.init expr)) sym)]
            ;;   expr)
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  curr-mod (sm/get-in-val [.module .index])
                  :let [sym-var (str "m" curr-mod "_sym" sym-idx)
                        sym-ptr (str "m" curr-mod "_symPtr" sym-idx)
                        constraint (c/update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-static-sym sym-ptr [] {} constraint sym-var))
                  _ (constrain-var (ast/file-name ast) (ast/line-number ast)
                                   sym-ptr constraint)
                  _ (declare ["SubString " sym-var " = {SymbolType, -1, 0, " (count (str sym))
                              ", 0, \"" sym "\"};\n"
                              "Value *" sym-ptr " = (Value *)&" sym-var ";\n"])]
              (c-static-sym sym-ptr [] {} constraint sym-var))))))


(def LiteralValues (any-of ast/quoted-ast
                           ast/string-ast
                           ast/integer-ast
                           Integer
                           String))

(extend-type LiteralValues
  Emitter
  (encode-static [n]
    (emit n))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (wrap-tail [x params]
    (Left (TailCall x params))))

(extend-type ast/string-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-string (.string ast))
          _ (sm/update-in-val [.fn-context .subs (.c-var expr)]
                              (fn [c]
                                (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(extend-type ast/integer-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-num (.int ast))
          _ (sm/update-in-val [.fn-context .subs (.c-var expr)]
                              (fn [c]
                                (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(defn constrain-contents [var constraint content-vars file-name line-number]
  (for [contents (sm/traverse content-vars get-constraint)
        :let [constraint (-> constraint
                             (c/intersect (c/StaticLengthConstraint (count content-vars) empty-list
                                                                    nothing var))
                             (c/intersect (c/ItemsConstraint contents c/coll-of-any empty-list
                                                             nothing var))
                             (c/update-var var))]
        _ (append-constraint var constraint file-name line-number)]
    '_))

(defn call-vector [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [vect-sym (genlocal "newVect")
          result-sym (genlocal "vect")
          line (line-macro target "// call-vector")
          _ (constrain-contents result-sym vect-constraint (map args .c-var)
                                file-name line-number)]
      (c-init result-sym
              [line
               "Vector *" vect-sym " = empty_vect;" line-sep
               (map args
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [vect-sym " = mutateVectConj(" vect-sym ", "
                         arg-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
              {} file-name line-number))))

(defn call-list [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "list")
          _ (constrain-contents result-sym list-constraint (map args .c-var)
                                file-name line-number)]
      (c-init result-sym
              [line "List *" list-sym " = empty_list;" line-sep
               (map (reverse args)
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [list-sym " = listCons(" "(Value *)" arg-sym
                         ", " list-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
              {} file-name line-number))))

(defn call-maybe [ast arg]
  (let [target (.call-target ast)
        file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-maybe")
          result-sym (genlocal "maybe")
          _ (propogate-constraint (.c-var arg) result-sym
                                  (fn [inner]
                                    (either (= inner c/top-type)
                                            (c/intersect maybe-constraint
                                                         (c/InferredInner inner empty-list
                                                                          nothing result-sym))))
                                  file-name line-number)]
      (c-init result-sym
              [line "Value *" result-sym " = (Value *)maybe((FnArity *)0, (Value *)0, " (.c-var arg) ");" line-sep]
              {} file-name line-number))))

(def conj-like #{'conj 'mutate-vect-conj})

(defn constrain-collection [coll-var v-var result-var file-name line-number]
  (for [coll-const (get-constraint coll-var)
        :let [coll-type (c/extract-collection-of coll-const)
              contents-type (c/extract-contents-constraint coll-type)]
        _ (append-constraint v-var contents-type file-name line-number)
        v-c (get-constraint v-var)]
    '_))

(defn add-hash-map-constraints [ast result-var args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (either (or (for [_ (= (.call-target ast) 'assoc)
                      coll-var (map (nth args 0) .c-var)
                      k-var (map (nth args 1) .c-var)
                      v-var (map (nth args 2) .c-var)]
                  (for [coll-const (get-constraint coll-var)
                        :let [[key-c val-c] (-> coll-const
                                                c/extract-collection-of
                                                c/extract-contents-constraint
                                                (c/extract-items-constraints 2))]
                        _ (append-constraint v-var val-c file-name line-number)
                        _ (append-constraint k-var key-c file-name line-number)]
                    '_))
                (and (= (.call-target ast) 'hash-map)
                     (maybe (for [arg-cs (sm/traverse args (comp get-constraint .c-var))
                                  :let [pair-cs (-> arg-cs
                                                    (partition 2)
                                                    (map (fn [kv-c]
                                                           (-> c/empty-items-constraint
                                                               (.items-constraints (vec kv-c)))))
                                                    vec)]
                                  _ (append-constraint result-var (-> (c/CollectionOf c/top-type empty-list
                                                                                      nothing "")
                                                                      ;; TODO: this looks dumb. Why intersect a
                                                                      ;; known constraint
                                                                      (c/intersect (-> c/empty-items-constraint
                                                                                       (.items-constraints pair-cs)))
                                                                      (c/update-path file-name line-number))
                                                       file-name line-number)]
                              '_))))
            sm-nop)))

(defn add-contents-constraint [ast result args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target (.call-target ast)]
    (either (or (for [_ (= target 'cons)
                      v (first args)
                      coll (second args)]
                  (let [v-var (.c-var v)
                        coll-var (.c-var coll)]
                    (for [coll-const (get-constraint coll-var)
                          v-const (get-constraint v-var)
                          _ (append-constraint result
                                               (c/ItemsConstraint [v-const] coll-const
                                                                  empty-list nothing result)
                                               file-name line-number)]
                      '_)))
                (for [_ (= target 'store)
                      coll (first args)
                      v (second args)]
                  (for [coll-const (get-constraint (.c-var coll))
                        v-const (get-constraint (.c-var v))
                        :let [coll-type (c/extract-collection-of coll-const)
                              contents-type (c/extract-contents-constraint coll-type)]
                        _ (append-constraint (.c-var v) contents-type file-name line-number)
                        _ (append-constraint result
                                             (c/intersect (c/CollectionOf coll-type empty-list nothing "")
                                                          maybe-constraint)
                                             file-name line-number)]
                    '_))
                (for [_ (conj-like target)
                      coll (first args)
                      v (second args)]
                  (constrain-collection (.c-var coll) (.c-var v) result file-name line-number)))
            sm-nop)))

(defn inner-constraint-for-reduce [result-var ast args]
  (and (= (.call-target ast) 'reduce)
       (= 3 (count args))
       (let [[v initial-val f] (take args 3)
             file-name (ast/file-name ast)
             line-number (ast/line-number ast)]
         (for [arity-info (or (get-in f [.arities 2])
                              (get-in f [.arities 'variadic]))]
           (let [[init-const inner-const] (-> arity-info
                                              .param-constraints
                                              (c/extract-items-constraints 2))
                 inner-const (either (= c/top-type inner-const)
                                     (c/InferredInner inner-const (list [file-name line-number])
                                                      nothing (.c-var v)))
                 result-c (.result-constraint arity-info)]
             (for [_ (constrain-var file-name line-number (.c-var v) inner-const)
                   _ (constrain-var file-name line-number (.c-var initial-val) init-const)
                   _ (constrain-var file-name line-number result-var result-c)]
               '_))))))

(def ignore-result-type #{'split-with 'filter 'drop-while 'take-while})
(def map-fns #{'map 'map-vals 'list-map 'maybe-map 'add-promise-action 'add-future-action})

;; TODO: with DynamicConstraints, the need for this function is questionable
(defn add-inner-constraint [result-var ast args]
  (or (inner-constraint-for-reduce result-var ast args)
      (let [file-name (ast/file-name ast)
            line-number (ast/line-number ast)]
        (and (or (map-fns (.call-target ast))
                 (= (.call-target ast) 'flat-map)
                 (ignore-result-type (.call-target ast)))
             (< 1 (count args))
             (let [[v f] (take args 2)]
               (for [arity-info (or (get-in f [.arities 1])
                                    (get-in f [.arities 'variadic]))]
                 (let [[inner-const] (-> arity-info
                                         .param-constraints
                                         (c/extract-items-constraints 1))
                       inner-const (either (= c/top-type inner-const)
                                           (c/InferredInner inner-const (list [file-name line-number])
                                                            nothing (.c-var v)))
                       result-c (.result-constraint arity-info)
                       result-c (cond
                                 (map-fns (.call-target ast))
                                 (-> (c/InferredInner result-c
                                                      empty-list nothing "")
                                     (c/update-path file-name line-number))

                                 (= (.call-target ast) 'flat-map)
                                 (c/update-path result-c
                                                file-name line-number)

                                 c/top-type)]
                   (for [v-c (get-constraint (.c-var v))
                         _ (constrain-var file-name line-number (.c-var v) inner-const)
                         _ (constrain-var file-name line-number result-var result-c)]
                     '_))))))))

(defn constrain-args [arg-vars param-constraints file-name line-number]
  (assert (instance? (vector-of c/ValueConstraint) param-constraints))
  (for [checked-var (genlocal 'checked)
        checks (sm/traverse (zip-lists arg-vars param-constraints)
                            (fn [[expr constraint]]
                              (let [var (.c-var expr)]
                                (for [curr-const (get-constraint var)
                                      _ (constrain-var file-name line-number var constraint)]
                                  (either (and (instance? c-param expr)
                                               (maybe ""))
                                          (-> constraint
                                              (c/update-var var)
                                              (runtime-check curr-const file-name line-number checked-var)))))))]
    (either (and (every checks empty?)
                 (maybe []))
            ["if(1){int " checked-var " = 1;" line-sep
             checks line-sep
             "if(!" checked-var "){abort();}}" line-sep])))

(defn call-proto-impl [target arg-vars ast]
  (assert (instance? c-protocol-fn target))

  (let [target-ast (.call-target ast)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (either (map (first arg-vars)
                 (fn [expr]
                   (for [disp-type (var-type-num (.c-var expr))
                         ;; _ (cond (= file-name "runtime-tests/apply-constructor.toc")
                         ;;         (debug 'cpi file-name (ast/line-number (.call-target ast))
                         ;;                (.call-target ast) (first arg-vars)
                         ;;                (.c-var expr) disp-type)
                         ;;         sm-nop)
                         :when-not (= disp-type c/UnknownType)
                         result-sym (genlocal "rslt")
                         impl-info (get-proto-impl (.proto-sym target) target-ast num-args disp-type)
                         ;; _ (cond (= file-name "runtime-tests/apply-constructor.toc")
                         ;;         (for [arg-cs (sm/traverse arg-vars (fn [var]
                         ;;                                              (get-constraint (.c-var var))))
                         ;;               _ (debug 'cpi file-name (ast/line-number (.call-target ast))
                         ;;                        (.call-target ast) disp-type "\n\n" 'target target "\n\n"
                         ;;                        'param-cs (.param-constraints impl-info) "\n\n"
                         ;;                        'impl-result (.result-constraint impl-info) "\n\n"
                         ;;                        'arg-vars arg-vars "\n\n"
                         ;;                        'arg-cs "\n" (interpose arg-cs "\n"))
                         ;;               reified-c (reify-constraint (.result-constraint impl-info) arg-vars
                         ;;                                           file-name line-number)
                         ;;               _ (debug'reified result-sym reified-c)
                         ;;               ]
                         ;;           '_)
                         ;;         sm-nop)
                         _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                                 (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
                         check-args (constrain-args arg-vars (-> impl-info
                                                                 .param-constraints
                                                                 (c/extract-items-constraints num-args))
                                                    file-name line-number)

                         ;; TODO: do I really need this? Can propogate-inner-constraint handle it?
                         _ (cond (or (= (.call-target ast) 'seq)
                                     (= (.call-target ast) 'vec))
                                 (let [[arg-var] arg-vars
                                       coll-c (cond (= (.call-target ast) 'seq)
                                                    list-constraint

                                                    vect-constraint)]
                                   (for [arg-c (get-constraint (.c-var arg-var))
                                         :let [result-c (c/set-type arg-c coll-c)
                                               result-c (cond (= result-c c/top-type)
                                                              (.result-constraint impl-info)

                                                              result-c)]
                                         _ (constrain-var file-name line-number result-sym result-c)]
                                     '_))

                                 (= (.call-target ast) 'instance?)
                                 (for [reified (reify-constraint (.result-constraint impl-info)
                                                                 arg-vars file-name line-number)
                                       ;; TODO: when reified is bottom-type, you could optimize the
                                       ;; generated code to eliminate this call to instance?.
                                       _ (cond (= reified c/bottom-type)
                                               (constrain-var file-name line-number result-sym
                                                              (c/update-path maybe-constraint file-name line-number))
                                               (constrain-var file-name line-number result-sym reified))]
                                   '_)

                                 (flat-map (reify-constraint (.result-constraint impl-info) arg-vars
                                                             file-name line-number)
                                           (partial constrain-var file-name line-number result-sym)))
                         _ (sm/traverse (zip-lists (map arg-vars .c-var)
                                                   (c/extract-items-constraints (.param-constraints impl-info)))
                                        (fn [[var constraint]]
                                          (constrain-var file-name line-number var constraint)))
                         line (line-macro target-ast (str "// call proto fn " target-ast))
                         _ (either (add-inner-constraint result-sym ast arg-vars)
                                   sm-nop)
                         _ (add-contents-constraint ast result-sym  arg-vars)
                         _ (add-hash-map-constraints ast result-sym  arg-vars)]
                     (c-init result-sym
                             [line
                              check-args "\n// call proto function " target-ast "\n"
                              "Value *" result-sym " = " (.c-fn impl-info) "("
                              (interpose (list* "(FnArity *)0" (map arg-vars .c-var)) ", ")
                              ");" line-sep]
                             {} file-name line-number))))
            sm/zero-sm)))

(defn inline-get-field [name args]
  (for [reified-val (nth args 0)
        field-index (nth args 1)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit reified-val)
          disp-c (get-constraint (.c-var dispatch-val))
          rslt (genlocal "rslt")]
      ;; TODO: there could be multiple dyn fields because of a SumConstraint
      (either (flat-map (get (c/extract-dynamic-fields disp-c) field-index)
                        (fn [field-var]
                          (or (and (instance? c-static-fn field-var)
                                   ;; TODO: for some reason, static fn's don't work
                                   ;; (maybe (-> field-var
                                   ;;            clear-init
                                   ;;            (.init ["\n// look here static " (str reified-val " " field-index "\n")
                                   ;;                    "Value *" rslt " = ((ReifiedVal *)" (.c-var dispatch-val)
                                   ;;                    ")->impls[" (str field-index) "];\n"
                                   ;;                    "incRef((Value *)" rslt ", 1);"
                                   ;;                    "dec_and_free((Value *)" (.c-var dispatch-val) ", 1);"
                                   ;;                    line-sep])
                                   ;;            (.c-var rslt)
                                   ;;            (.refs-map {(.c-var dispatch-val) 1})))
                                   nothing
                                   )
                              (and (instance? c-closure-fn field-var)
                                   (maybe (-> field-var
                                              clear-init
                                              (.init ["\n// look here closure " (str reified-val " " field-index "\n")
                                                      "Value *" rslt " = ((ReifiedVal *)" (.c-var dispatch-val)
                                                      ")->impls[" (str field-index) "];\n"
                                                      "incRef((Value *)" rslt ", 1);"
                                                      "dec_and_free((Value *)" (.c-var dispatch-val) ", 1);"
                                                      line-sep])
                                              (.c-var rslt)
                                              (.refs-map {(.c-var dispatch-val) 1})))))))
              (c-field rslt ["Value *" rslt " = ((ReifiedVal *)" (.c-var dispatch-val)
                             ")->impls[" (str field-index) "];\n"]
                       {} c/top-type (.c-var dispatch-val))))))

(defn inline-wrap-and-apply [name args]
  (for [dispatch-ast (first args)
        wrapped (second args)]
    (for [dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= c/UnknownType dispatch-type)
          ;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          impl-ast (map (get-proto-impl (ast/tag 'Container) name (count args) dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
          new-ast (-> impl-ast
                      replace-bound-vars
                      (inline-expr (list dispatch-val wrapped)))]
      new-ast)))

(defn inline-flat-map [name args]
  (for [dispatch-ast (first args)
        f-ast (second args)]
    (for [
          ;; _ (cond (= (ast/file-name name) "test.toc")
          ;;         (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          ;;         sm-nop)
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          ;; TODO: if this test fails, we have to emit the dispatch-ast twice
          :when-not (= c/UnknownType dispatch-type)
          impl-ast (map (get-proto-impl (ast/tag 'Container) name 2 dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))]
      (let [impl-ast (replace-bound-vars impl-ast)
            [dispatch-sym f-sym] (.fixed (.params impl-ast))
            result-constraint (-> (.body impl-ast)
                                  (filter (partial instance? c/ResultConstraint))
                                  (map .assertion)
                                  (reduce c/top-type c/intersect))
            inlined-expr (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                                      (-> (.body impl-ast)
                                          (remove (partial instance? c/ResultConstraint))
                                          (replace-syms {f-sym f-ast})))]
        (cond (= c/top-type result-constraint)
              inlined-expr

              (ConstrainedAST inlined-expr result-constraint))))))

(defn inline-zero [name args]
  (for [dispatch-ast (first args)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= c/UnknownType dispatch-type)
          result-var (genlocal "zeroVal")]
      (c-code result-var ["Value *" result-var " = zero((FnArity *)0, &(Value){" (str dispatch-type)
                          ", refsStatic, (Value *)0});" line-sep] {} c/top-type))))

(defn inline-first [name [arg]]
  (for [_ (instance? ast/call-ast arg)
        :let [target (.call-target arg)]
        :when (or (= target 'list)
                  (= target 'vector))
        head (first (.args arg))]
    (let [head-sym (ast/tag "#head" (ast/file-name arg) (ast/line-number arg))]
      (sm/state-maybe (ast/let-ast [(ast/binding head-sym head)]
                                   (conj (rest (.args arg))
                                         (ast/call-ast (ast/tag 'maybe) [head-sym])))))))

(defn inline-rest [name [arg]]
  (for [_ (instance? ast/call-ast arg)
        :let [target (.call-target arg)]
        :when (or (= target 'list)
                  (= target 'vector))
        head (first (.args arg))]
    ;TODO: what about any ItemsConstraints or MinCount (when it arrives)
    (map (emit head)
         (fn [head]
           (cond (empty? (.init head))
                 (.args arg (rest (.args arg)))
                 (ast/let-ast [] [head (.args arg (rest (.args arg)))]))))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(defn inline-partial [name [call-target & args]]
  ;; TODO: some test exprs for this
  ;; (partial subs 8)
  ;; (partial subs "bogus" 'sym 8)
  ;; (partial subs "bogus" 8 9 10)

  (let [file (ast/file-name call-target)
        line (ast/line-number call-target)
        more-args (ast/tag "#more-args" file line)
        fn-sym (ast/tag (str "partial_" (either (instance? Tagged call-target)
                                                'anon)))]
    (-> (ast/fn-ast nothing
                    [(ast/fn-arity fn-sym (ast/params [] (maybe more-args)) ""
                                   [(ast/call-ast (ast/tag 'apply file line)
                                                  [call-target (ast/call-ast (ast/tag 'list* file line)
                                                                             (comp (vec args) [more-args]))])])])
        sm/state-maybe
        maybe)))

(defn inline-comp* [name [arg args]]
  (let [file (ast/file-name args)
        line (ast/line-number args)]
    (maybe (for [expr (emit arg)
                 dispatch-type (var-type-num (.c-var expr))
                 :when-not (= c/UnknownType dispatch-type)
                 impl-ast (map (get-proto-impl (ast/tag 'Composition) 'comp* 2 dispatch-type) .ast)
                 :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
                 args (either (flat-map (instance? ast/call-ast args)
                                        (fn [ast]
                                          (let [target (.call-target ast)]
                                            (and (= target 'rest)
                                                 (maybe (inline-expr target (.args ast)))))))
                              (sm/state-maybe args))
                 :when (and (instance? ast/call-ast args)
                            (let [target (.call-target args)]
                              (or (= target 'list)
                                  (= target 'vector))))
                 arg-exprs (sm/traverse (.args args) emit)
                 :let [impl-ast (replace-bound-vars impl-ast)
                       disp-binding (ast/binding-ast (ast/tag "dispArg" file line) expr)
                       args-bindings (-> (range (count arg-exprs))
                                         (map (fn [n]
                                                (ast/tag (str "arg" n) file line)))
                                         (make-bindings arg-exprs))
                       args-ast (.args args (map args-bindings .binding))
                       [dispatch-sym args-sym] (.fixed (.params impl-ast))]]
             (let [result-constraint (-> (.body impl-ast)
                                         (filter (partial instance? c/ResultConstraint))
                                         (map .assertion)
                                         (reduce c/top-type c/intersect))
                   inlined-expr (ast/let-ast (comp [disp-binding]
                                                   args-bindings)
                                             (-> (.body impl-ast)
                                                 (remove (partial instance? c/ResultConstraint))
                                                 (replace-syms {dispatch-sym (.binding disp-binding)
                                                                args-sym args-ast})))]
               (cond (= c/top-type result-constraint)
                     inlined-expr

                     (ConstrainedAST inlined-expr result-constraint)))))))

(defn inline-comp [name args]
  (let [file (ast/file-name args)
        line (ast/line-number args)]
    (maybe (for [exprs (sm/traverse args emit)]
             (let [[binding & bindings] (make-bindings (map (range (count args))
                                                            (fn [n]
                                                              (ast/tag (str "arg" n) file line)))
                                                       exprs)]
               (ast/let-ast
                (comp [binding] bindings)
                [(ast/call-ast (ast/tag 'comp* file line)
                               [(.binding binding)
                                (ast/call-ast (ast/tag 'list file line)
                                              (vec (map bindings .binding)))])]))))))

(def get-field-sym (ast/tag 'get-field 'core 0))

(def inlined-fns
  {'wrap {2 inline-wrap-and-apply}
   'apply {2 inline-wrap-and-apply}
   'flat-map {2 inline-flat-map}
   'zero {1 inline-zero}
   'map {2 inline-flat-map}
   '= {2 (fn [name args]
           (-> '=*
               (ast/tag (ast/file-name args) (ast/line-number args))
               (ast/call-ast args)
               sm/state-maybe
               maybe))}
   get-field-sym (maybe inline-get-field)
   'partial (maybe inline-partial)
   'first {1 inline-first}
   'rest {1 inline-rest}
   'comp* {2 inline-comp*}
   'comp (maybe inline-comp)})

(extend-type Tagged
  Emitter
  (get-param-cs [sym]
    (for [expr (lookup-sym (ast/tag sym))
          c (get-constraint (.c-var expr))]
      (let [c (cond (instance? c/DynamicConstraint c)
                    c/top-type

                    c)]
        (-> c
            (c/update-var (.c-var expr))
            (c/update-sym (ast/untag sym))))))

  (pre-bind [x]
    (sm/state-maybe x))

  (bind-param-expr [binding]
    (for [r (bind binding)
          :let [bound-var (.bound r)
                param-info (c-param bound-var [] {bound-var 1} c/top-type
                                    (ast/file-name binding) (ast/line-number binding))]
          _ (sm/assoc-in-val [.fn-context .fn-spec .param-vars bound-var]
                             param-info)
          _ (set-sym binding param-info)]
      r))

  (bind-expr [binding]
    (let [file-name (ast/file-name binding)
          line-number (ast/line-number binding)]
      (for [arg-var (genlocal binding "arg")
            :let [evalled (c-code arg-var [] {arg-var 1} c/top-type)]
            _ (comp (redef-proto-fn-error binding)
                    (set-sym binding evalled))]
        (ParamBinding arg-var [] "" [evalled]))))

  (bind-expr [binding evalled]
    (let [file-name (ast/file-name binding)
          line-number (ast/line-number binding)]
      (for [_ (comp (redef-proto-fn-error binding)
                    (for [_ (sm/when (instance? c-field evalled))
                          expr (sm/get-in-val [.fn-context .syms (ast/tag binding)])
                          :when (instance? c-param expr)
                          _ (compilation-error "The parameter" (str "'" binding "'")
                                               "shadows a field of the same name at"
                                               (.file-name expr)
                                               (.line-number expr))]
                      '_)
                    (set-sym binding (clear-init evalled)))]
        (either (and (empty? (.init evalled))
                     (maybe (ParamBinding (.c-var evalled) [] "" [evalled])))
                (ParamBinding (.c-var evalled)
                              [] ""
                              [(either (instance? c-field evalled)
                                       (c-init (.c-var evalled) (.init evalled)
                                               (.refs-map evalled) file-name line-number))])))))

  (emit [sym]
    (let [sym (ast/tag sym)]
      (for [expr (lookup-sym sym)
            c (get-constraint (.c-var expr))
            _ (set-constraint (.c-var expr)
                              (c/update-path c (ast/file-name sym) (ast/line-number sym)))]
        expr)))

  (emit-defined-value [sym defined-sym]
    (for [value (emit (ast/tag sym))
          _ (new-module-def defined-sym value)]
      [value]))

  (wrap-tail [ast params]
    (Left (TailCall ast params)))

  (inline-expr [name arg-asts]
    ;; TODO: inline 'get-in', 'update-in', getters/setters
    (let [args (remove arg-asts (partial instance? ast/NoCode))
          num-args (count args)]
      (either (flat-map (get-in inlined-fns [name num-args])
                        (fn [f]
                          (f name args)))
              sm/zero-sm))))

(extend-type Symbol
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Emitter
  (cache-static-constant [s expr]
    (send constants (fn [constants]
                      (assoc-in constants [.symbols s]
                                (.init expr ["Value *" (.c-var expr) ";" line-sep])))))

  (dissoc-sym [x]
    (for [_ (sm/update-state (fn [[subs & subs-list]]
                               (cons (dissoc subs (ast/tag x))
                                     subs-list)))]
      (Left x)))

  (new-bound-var [x]
    (let [new-var (ast/tag (gensym (str x)))]
      (for [_ (sm/update-state (fn [[subs & subs-list]]
                                 (cons (assoc subs x new-var)
                                       subs-list)))]
        (Left new-var))))

  (update-syms [x _]
    (map (comp (sm/get-in-val [0 (ast/tag x)])
               (sm/state-maybe (ast/tag x)))
         Left))

  (encode-static [sym]
    (emit (ast/quoted-ast sym))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (sm/traverse (.value-exprs ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  _ (sm/assoc-in-val [.module .declarations sym]
                                     (maybe (c-code c-var [] {} c/top-type)))

                  _ (declare ["Value *" c-var ";\n"])]
              [empty-c-code])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (wrap sm/zero-sm (c-code "(FnArity *)0" [] {} c/top-type)))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str "at " file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(FnArity *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

(defprotocol ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(deftype StaticArity [arity-fn-var c-fn params param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))

  Stringable
  (string-list [_]
    (list "(StaticArity " (str arity-fn-var) " " (str param-count) " "
          (str var-info) " " (str param-constraints)
          " " (str result-constraint) ")"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (sm/update-in-val [.reify-fn-index] inc)
          _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraint c-fn)]
      var-info)))

;; TODO: arity-fn-var appears to not be used
(deftype ClosureArity [arity-fn-var params param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))

  Stringable
  (string-list [_]
    (comp (list "(ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info) ")"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (sm/traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (partial str "Value *"))
                                                     (str "FnArity *arity"))
                                               ", "))
                  args (to-str (interpose (comp [dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym) fn-arity-sym) arity-ast
                              param-constraints result-constraint
                              (StaticFnPtr (str impl-fn-sym)))
            _ (sm/update-in-val [.reify-fn-index] inc)
            _ (declare ["// implementation of " fn-name "\n"
                        "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                        "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                        ")->impls[" reify-fn-index "];" line-sep
                        "incRef(" dispArg ", 1);" line-sep
                        "if (arityPtr->count != " param-count ") {\n"
                        "fprintf(stderr, \"Compiler error: arity count != parameter count\\n\");\nabort();\n}\n"
                        "Value *rval = ((FnType" param-count
                        " *)arityPtr->fn)(arityPtr," args ");" line-sep
                        "dec_and_free(" dispArg ", 1);" line-sep
                        ;; TODO: verify that we don't need to free the parent fn here
                        "return(rval);" line-sep
                        "};\n\n"
                        "FnArity " fn-arity-sym " = {FnArityType, -2, " param-count
                        ", (Vector *)0, (Value *)0, 0, " impl-fn-sym ", (Value *)0, (Value *)0};" line-sep])]
        var-info))))

;; TODO: needs new name, get-arity-fn-ptr?
(defn get-proto-dispatch-sym [fn-sym num-args]
  (flat-map (lookup-sym fn-sym)
            (fn [expr]
              (sm/when (get-in expr [.arities num-args .c-fn])))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arity-info arg-vars ast]
  (assert (instance? StaticArity arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        [param-cs result-c] (either (for [_ (= (.call-target ast) 'fn-apply)
                                          applied-fn (first arg-vars)
                                          arities (get applied-fn .arities)]
                                      ;; TODO: catch problems at compile time
                                      (let [param-constraints (-> arities
                                                                  vec
                                                                  (map (fn [[_ v]]
                                                                         (-> v
                                                                             .param-constraints
                                                                             c/extract-items-constraints)))
                                                                  ((partial apply zip-lists))
                                                                  vec
                                                                  (map (fn [cs]
                                                                         (c/sum-type (vec cs)))))
                                            result-constraint (-> arities
                                                                  vec
                                                                  (map (fn [[_ v]]
                                                                         (.result-constraint v)))
                                                                  c/sum-type)]
                                        [(-> (c/ItemsConstraint [fn-constraint
                                                                 (c/ItemsConstraint param-constraints
                                                                                    c/coll-of-any
                                                                                    empty-list
                                                                                    nothing "")]
                                                                c/coll-of-any
                                                                empty-list
                                                                nothing "")
                                             (c/update-path file-name line-number))
                                         (c/update-path result-constraint file-name line-number)]))
                                    [(.param-constraints arity-info)
                                     (.result-constraint arity-info)])]
    (for [result-sym (genlocal "rslt")
          arg-cs (sm/traverse (map arg-vars .c-var) get-constraint)
          :let [r-c result-c]
          ;; TODO: need to get access to the args of (second arg-vars)
          ;; result-c (either (for [_ (= (.call-target ast) 'fn-apply)
          ;;                        coll-c (second arg-cs)]
          ;;                    (reify-constraint result-c
          ;;                                      (c/extract-items-constraints coll-c 10)
          ;;                                      file-name line-number))

          ;;                  (reify-constraint result-c arg-vars file-name line-number))
          result-c (reify-constraint result-c arg-vars file-name line-number)
          ;; _ (comp (for [_ (sm/when (= file-name "runtime-tests/nested-destruct-1.toc"))
          ;;               _ (debug 'csf file-name line-number (.call-target ast) (.c-var target) "\n\n"
          ;;                        'param-cs param-cs "\n\n" 'result result-sym r-c)
          ;;               _ (debug 'arg-cs arg-cs)
          ;;               _ (debug 'reified result-c)
          ;;               _ (sm/traverse (zip-lists arg-vars arg-cs)
          ;;                              (fn [[v c]]
          ;;                                (debug 'v (.c-var v) 'c c)))]
          ;;           '_)
          ;;         sm-nop)
          check-args (constrain-args arg-vars (c/extract-items-constraints param-cs (count arg-vars))
                                     file-name line-number)
          _ (constrain-var file-name line-number result-sym result-c)

          _ (update-call-site-count (.c-fn arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-fn arity-info) file-name line-number)]
      (c-init result-sym
              [check-args
               line "Value *" result-sym " = " (.c-fn arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var)))
                          ", ")
               ");" line-sep]
              {} file-name line-number))))

(defn call-static-variadic [target arity-info arg-vars ast]
  (assert (instance? StaticArity arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [_ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (ast/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg []))))
          result-sym (genlocal "rslt")
          ;; _ (cond (= (str file-name) "assertion-tests/bad-add.toc")
          ;;         (debug 'csv file-name line-number (.call-target ast) (.c-var target) "\n"
          ;;                (.param-constraints arity-info) "\n"
          ;;                result-sym (.result-constraint arity-info))
          ;;         sm-nop)
          check-args (constrain-args arg-vars (-> arity-info
                                                  .param-constraints
                                                  (c/extract-items-constraints (count arg-vars)))
                                     file-name line-number)
          _ (constrain-var file-name line-number (.c-var args-list) (.param-constraints arity-info))

          arg-cs (sm/traverse arg-vars (fn [var]
                                         (get-constraint (.c-var var))))
          _ (flat-map (reify-constraint (.result-constraint arity-info) arg-vars file-name line-number)
                      (partial constrain-var file-name line-number result-sym))
          _ (cond (= (.call-target ast) 'list*)
                  (for [arg-cs (map (get-constraint (.c-var args-list))
                                    c/extract-items-constraints)
                        tail-c (sm/when (last arg-cs))
                        _ (constrain-var file-name line-number result-sym
                                         (-> (c/ItemsConstraint (butlast arg-cs)
                                                                (c/intersect tail-c list-constraint)
                                                                empty-list nothing "")
                                            (c/intersect list-constraint)
                                            (c/update-var result-sym)
                                            (c/update-path file-name line-number)))]
                    '_)

                  sm-nop)

          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               check-args
               line
               "Value *" result-sym " = " (.c-fn arity-info) "((FnArity *)0, (Value *)"
               (.c-var args-list) ");" line-sep]
              {} (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          type-num (var-type-num (.c-var target))
          :when (= c/FunctionType type-num)
          result-sym (genlocal "rslt")
          dyn-result-c (get-constraint (.c-var target))
          _ (set-constraint result-sym (-> (c/DynamicResultConstraint dyn-result-c (count args)
                                                                      empty-list nothing result-sym)
                                           (c/update-path file-name line-number)))
          ;; _ (cond (= file-name "test.toc")
          ;;         (for [result-c (get-constraint result-sym)
          ;;               _ (debug 'cdf file-name line-number (.call-target ast) (.c-var target) "\n\n"
          ;;                        'target target "\n\n" 'result-c result-c)]
          ;;           '_)
          ;;         sm-nop)
          _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
          variadic-sym (genlocal "dynArgs")
          fn-var (genlocal "fn")
          line (line-macro ast "// dynamic fn type")]
      (let [args (map args .c-var)
            arg-syms (comp [(str arity-sym)] args)
            num-args (count args)]
        (c-init result-sym
                ["Value *" result-sym ";" line-sep
                 "FnArity *" arity-sym " = findFnArity(" (.c-var target)
                 ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
                 "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
                 arity-sym "->fn;" line-sep
                 "\n" line
                 result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
                 "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 line result-sym " = " fn-var "(" (str arity-sym) ", (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
                 "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
                 "\", " (ast/line-number ast) ");\n  abort();\n}\n"
                 "dec_and_free("(.c-var target) ", 1);" line-sep]
                {} (ast/file-name ast) (ast/line-number ast))))))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")

          dyn-result-c (get-constraint (.c-var target))
          ;; _ (cond (= file-name "test.toc")
          ;;         (debug 'cdu file-name line-number (.call-target ast) (.c-var target) "\n\n"
          ;;                'target target "\n\n" 'dyn-result-c dyn-result-c)
          ;;         sm-nop)
          ;; _ (set-constraint result-sym (-> (c/DynamicResultConstraint dyn-result-c (count args)
          ;;                                                             empty-list nothing result-sym)
          ;;                                  (c/update-path file-name line-number)))

          invoke-arity-sym (get-proto-dispatch-sym invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")
          sym-location (emit (either (= "\"\"" file-name)
                                     (str "\"at " file-name ": " line-number "\"")))]
      (let [args (map args .c-var)
            arg-syms (comp [(str arity-sym)] args)]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 result-sym " = " invoke-arity-sym "("
                 (interpose (list* (str "(FnArity *)" (.c-var sym-location))
                                   (.c-var target) args) ", ") ");"
                 line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) ", (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                {} file-name line-number)))))

(defn call-invoke [target arg-vars ast]
  (let [arg-vars (comp [target] arg-vars)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [target-type (var-type-num (.c-var target))
          :when-not (= c/UnknownType target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          invoke-info (get-core-proto-impl Function-sym invoke-sym num-args target-type)
          result-sym (genlocal "rslt")
          ;; _ (cond (= file-name "test.toc")
          ;;         (for [_ (debug 'ci file-name line-number (.call-target ast) num-args
          ;;                        'target-type target-type "\n\n"
          ;;                        ;; (.param-constraints invoke-info) "\n\n"
          ;;                        'result result-sym (.result-constraint invoke-info)
          ;;                        )
          ;;               _ (apply debug (list* 'arg-vars "\n" (interpose arg-vars "\n")))
          ;;               ;; _ (debug 'target-c target-c)
          ;;               ;; _ (debug 'fn-c fn-c)
          ;;               ;; _ (debug 'fn-var fn-var)
          ;;               ;; _ (debug 'fn-result-c fn-result-c)
          ;;               ;; _ (debug 'arg-vars arg-vars)
          ;;               ;; _ (debug 'param-consts (.param-constraints invoke-info))
          ;;               ]
          ;;           '_)
          ;;         sm-nop)

          target-c (get-constraint (.c-var target))
          result-c (reify-constraint (.result-constraint invoke-info)
                                     arg-vars file-name line-number)
          check-args (constrain-args arg-vars (-> invoke-info
                                                  .param-constraints
                                                  (c/extract-items-constraints num-args))
                                     file-name line-number)
          ;; _ (cond (= file-name "test.toc")
          ;;         (debug 'reified result-sym result-c)
          ;;         sm-nop)
          _ (constrain-var file-name line-number result-sym result-c)
          ;; _ (cond (= file-name "test.toc")
          ;;         (flat-map (get-constraint result-sym)
          ;;                   (partial debug 'set-c))
          ;;         sm-nop)

          _ (sm/traverse (zip-lists (map arg-vars .c-var)
                                    (c/extract-items-constraints (.param-constraints invoke-info)))
                         (fn [[var constraint]]
                           (constrain-var file-name line-number var constraint)))

          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line check-args "\n// call invoke function\n"
               "Value *" result-sym " = " (.c-fn invoke-info) "("
               (interpose (list* "(FnArity *)0" (map arg-vars .c-var)) ", ")
               ");" line-sep]
              {} file-name line-number))))

(defprotocol CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (call-dyn-fn-value target args ast)
          (call-dyn-unknown-type target args ast))))

(extend-type c-static-reified
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(extend-type c-constructor
  Emitter
  (clear-init [cc]
    (.init cc []))

  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(defn static-call-site [target args ast]
  (comp (for [expr (either (or (map (get-in target [.arities (count args)])
                                    (fn [arity-info]
                                      (call-static-fixed target arity-info args ast)))
                               (map (get-in target [.arities 'variadic])
                                    (fn [arity-info]
                                      (call-static-variadic target arity-info args ast))))
                           sm/zero-sm)
              _ (either (add-inner-constraint (.c-var expr) ast args)
                        sm-nop)
              _ (add-hash-map-constraints ast (.c-var expr) args)
              _ (add-contents-constraint ast (.c-var expr) args)]
          expr)
        (compilation-error "No arity with" (count args) "arguments found"
                           (either (map (instance? Tagged (.call-target ast))
                                        (fn [sym]
                                          (str "for '" sym "'")))
                                   "")
                           "at:" (ast/file-name ast) (ast/line-number ast))))

(extend-type c-maybe-fn
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  CallSite
  (emit-call-site [target args ast]
    (either (map (and (= 1 (count args))
                      (first args))
                 (partial call-maybe ast))
            (compilation-error "Call to 'maybe' in" (ast/file-name ast) "at line" (ast/line-number ast)
                               "has the wrong number of arguments. Only a single argument is valid."))))

(extend-type c-list-fn
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  CallSite
  (emit-call-site [target args ast]
    (call-list (.call-target ast) args)))

(extend-type c-vector-fn
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  CallSite
  (emit-call-site [target args ast]
    (call-vector (.call-target ast) args)))

;; TODO: test add-inner-constraint on state-maybe values
;; TODO: add inner constraint to Strings
;; TODO: insert InferredInner into anon fn passed to higher order fn

(def returns-inner #{'seq 'vec 'rest 'butlast 'reverse 'vals 'last 'nth 'get 'first})

(defn propogate-inner-constraint [result-var ast args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    ;; TODO: do hash-seq, list-concat, comp-vect as well
    (or (for [_ (or (returns-inner (.call-target ast))
                    (= (.call-target ast) 'extract))
              arg (first args)]
          (propogate-constraint (.c-var arg) result-var
                                (fn [constraint]
                                  (let [inner-c (c/extract-coll-constraint constraint)]
                                    (either (and (= (.call-target ast) 'extract)
                                                 (maybe (c/extract-contents-constraint inner-c)))
                                            inner-c)))
                                file-name line-number))

        (for [_ (= (.call-target ast) 'comp-vect)
              arg (first args)
              rest-args (second args)]
          (for [rest-cs (get-constraint (.c-var rest-args))
                r (propogate-constraint (.c-var arg) result-var
                                        (fn [constraint]
                                          (-> rest-cs
                                              c/extract-items-constraints
                                              (conj constraint)
                                              (remove (fn [c]
                                                        (-> c
                                                            c/extract-items-constraints
                                                            count
                                                            (= 0))))
                                              (map c/extract-contents-constraint)
                                              c/sum-type
                                              (c/InferredInner empty-list nothing result-var)
                                              (c/intersect vect-constraint)))
                                        file-name line-number)]
            r))
        )))

(extend-type c-static-fn
  CallSite
  (emit-call-site [target args ast]
    (for [expr (static-call-site target args ast)
          _ (either (propogate-inner-constraint (.c-var expr) ast args)
                    sm-nop)]
      expr)))

(extend-type c-protocol-fn
  Emitter
  (get-result-constraint [expr num-args]
    (sm/when (get-in expr [.arities num-args .result-constraint])))

  (clear-init [expr]
    (-> expr
        (.init [])
        (.refs-map {(.c-var expr) 1})))

  CallSite
  (emit-call-site [target args ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [expr (comp (call-proto-impl target args ast)
                       (static-call-site target args ast))
            _ (either (propogate-inner-constraint (.c-var expr) ast args)
                      sm-nop)]
        expr))))

(extend-type c/SumConstraint
  Emitter
  (reify-c [ast param-exprs file-name line-number]
    (sm/state-maybe (either (some (.alts ast) (partial = c/bottom-type))
                            (let [new-alts (reduce (.alts ast) []
                                                   (fn [new-alts new-c]
                                                     (cond
                                                      (some new-alts (partial = new-c)) new-alts
                                                      (conj new-alts new-c))))]
                              (either (and (= 1 (count new-alts))
                                           (first new-alts))
                                      (.alts ast new-alts))))))

  (old-reify-c [ast param-exprs file-name line-number]
    (for [new-alts (sm/traverse (.alts ast)
                                (fn [alt-c]
                                  (old-reify-c alt-c param-exprs file-name line-number)))]
      (either (some new-alts (partial = c/bottom-type))
              (let [new-alts (reduce new-alts []
                                     (fn [new-alts new-c]
                                       (cond
                                        (some new-alts (partial = new-c)) new-alts
                                        (conj new-alts new-c))))]
                (either (and (= 1 (count new-alts))
                             (first new-alts))
                        (.alts ast new-alts))))))

  (runtime-check [constraint value-info sym-location checked-var]
    (let [alts (.alts constraint)
          var (c/extract-var constraint)]

      (either (and (c/satisfied-by constraint value-info)
                   (maybe []))
              ["if (" checked-var "){"
               "int checkPassed = 0;"
               (reduce alts []
                       (fn [ss alt]
                         (comp ss
                               ["if(!checkPassed){" line-sep
                                checked-var " = 1;" line-sep
                                ;; TODO: what if runtime-check is empty?
                                (runtime-check (c/update-var alt var)
                                               value-info checked-var)
                                "if(" checked-var "){checkPassed = 1;}"])))
               (repeat (count alts) "}")
               "if (!checkPassed){"
               ;; "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Invalid type of value for '"
               (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
               ;; TODO: this error message needs to be more clearer
               "fprintf(stderr, \"Got %s\\n\", extractStr(type_name((FnArity *)0, " var ")));"
               "fprintf(stderr, \"Needed a value specified in\\n"
               (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
               "\\n\");"
               ;; "\n#endif\n"
               "abort();}}" line-sep])))

  (runtime-check [constraint value-info checked-var]
    (let [alts (.alts constraint)
          var (c/extract-var constraint)]
      (either (and (c/satisfied-by constraint value-info)
                   (maybe []))
              ["if (" checked-var "){"
               checked-var " = 0;" line-sep
               (reduce alts []
                       (fn [ss alt]
                         (comp ss
                               ["if(!" checked-var "){" line-sep
                                checked-var " = 1;" line-sep
                                ;; TODO: what if runtime-check is empty?
                                (runtime-check (c/update-var alt var)
                                               value-info checked-var)])))
               (repeat (count alts) "}") "}" line-sep])))

  (emit [ast]
    (emit-sym-constraint ast)))

(extend-type c/ValueConstraint
  Emitter
  (emit-defined-value [constraint defined-sym]
    (let [file-name (ast/file-name constraint)
          line-number (ast/line-number constraint)
          x* (ast/tag "#x")
          y* (ast/tag "#y")]
      (for [constraint (lookup-constraint constraint)
            :let [constraint (c/update-type-name constraint defined-sym)
                  types-info (either (c/extract-type-map constraint)
                                     {})]
            _ (sm/assoc-in-val [.module .types (ast/untag defined-sym)] constraint)
            exprs (emit-defined-value
                   (ast/reified
                    ;; TODO: total hack, should be
                    ;; nothing
                    (= 0 1)
                    {(ast/tag Eq-sym file-name line-number)
                     {=*-sym
                      [(ast/fn-arity
                        (ast/tag (str defined-sym "_EQ_QMARK_") file-name line-number)
                        (ast/params [x* y*]) ""
                        [(ast/and-ast
                           [(ast/call-ast =*-sym
                                          [(ast/call-ast get-type-sym [x*])
                                           (ast/call-ast get-type-sym [y*])])
                            (ast/call-ast maybe-sym [x*])])])]}

                     (ast/tag Type-sym file-name line-number)
                     {instance?-sym
                      [(ast/fn-arity
                        (ast/tag (str defined-sym "_instance_QMARK_") file-name line-number)
                        (ast/params [x* y*]) ""
                        [(-> maybe-constraint
                             (c/intersect (c/InferredInner constraint empty-list nothing ""))
                             c/ResultConstraint)
                         (ast/and-ast
                          ;; TODO: this needs to be replace with runtime-check
                          [(ast/call-ast some-sym
                                         [(ast/call-ast list-sym (vec (keys types-info)))
                                          (ast/call-ast partial-sym
                                                        [=*-sym
                                                         (ast/call-ast get-type-sym [y*])])])
                           (ast/call-ast maybe-sym [y*])])])]

                      type-mapping-sym
                      [(ast/fn-arity
                        (ast/tag (str defined-sym "_type_mapping") file-name line-number)
                        (ast/params [x*]) ""
                        [(map-vals types-info (fn [field-set]
                                                (map field-set ast/quoted-ast)))])]}

                     (ast/tag Stringable-sym file-name line-number)
                     {string-list-sym
                      [(ast/fn-arity string-list-sym (ast/params [x*]) ""
                                     [(ast/call-ast list-sym ["<SumType " (str defined-sym) ">"])])]}})
                   defined-sym)]
        exprs))))

(defn define-enum-element [file-name line-number sym]
  (cond (instance? ast/tagged-symbol sym)
        (comp (flat-map (get-sym sym)
                        (fn [expr]
                          (compilation-error "Invalid enum value " (str "'" sym "'")
                                             " at:" file-name line-number)))
              (let [x* (ast/tag 'x file-name line-number)
                    y* (ast/tag 'y file-name line-number)
                    reified-type-num (extract type-counter)]
                (for [_ (emit-defined-value
                         (ast/reified (maybe reified-type-num)
                                      {(ast/tag Type-sym file-name line-number)
                                       {type-name-sym
                                        [(ast/fn-arity
                                          (ast/tag (str sym "_const_type_name") file-name line-number)
                                          (ast/params [(ast/tag '_)]) ""
                                          [(str "'" sym "' enum value at " file-name ": " line-number)])]}

                                       (ast/tag Stringable-sym file-name line-number)
                                       {string-list-sym
                                        [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                                       [(ast/call-ast list-sym [(str sym)])])]}})
                         sym)]
                  {reified-type-num #{}}))
              (flat-map (debug 'here-maybe)
                        (fn [_]
                          (compilation-error "wtf" file-name line-number))))
        (compilation-error "Invalid enum expression at:"
                           file-name line-number)))

(defn define-enum-type [fn-val defined-sym]
  (let [file-name (ast/file-name defined-sym)
        line-number (ast/line-number defined-sym)]
    (cond (= (.call-target fn-val) 'enum)
          (for [type-maps (sm/traverse (.args fn-val) (partial define-enum-element file-name line-number))
                _ (debug 'type-maps type-maps)
                :let [type-map (comp* {} type-maps)
                      x* (ast/tag "#x")
                      y* (ast/tag "#y")
                      reified-type-num (extract type-counter)
                      constraint (-> (c/TypeConstraint type-map empty-list defined-sym nothing "")
                                     (c/update-path file-name line-number))]
                _ (sm/assoc-in-val [.module .types (ast/untag defined-sym)]
                                   constraint)
                exprs (emit-defined-value
                       (ast/reified
                        (maybe reified-type-num)
                        {Type-sym
                         {instance?-sym
                          [(ast/fn-arity
                            (ast/tag (str defined-sym "_instance_QMARK_") file-name line-number)
                            (ast/params [x* y*]) ""
                            [(-> maybe-constraint
                                 (c/intersect (c/InferredInner constraint empty-list nothing ""))
                                 c/ResultConstraint)
                             (ast/and-ast
                              [(ast/call-ast some-sym
                                             [(ast/call-ast list-sym (vec (keys type-map)))
                                              (ast/call-ast partial-sym
                                                            [=*-sym (ast/call-ast get-type-sym [y*])])])
                               (ast/call-ast maybe-sym [y*])])])]

                          type-mapping-sym
                          [(ast/fn-arity
                            (ast/tag (str defined-sym "_type_mapping") file-name line-number)
                            (ast/params [x*]) ""
                            [(map-vals type-map (fn [field-set]
                                                  (map field-set ast/quoted-ast)))])]}

                         Stringable-sym
                         {string-list-sym
                          [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                         [(ast/call-ast list-sym
                                                        ["<SumType " (str defined-sym) ">"])])]}})
                       defined-sym)]
            exprs)
          sm/zero-sm)))

(defn init-at-runtime [ast defined-sym]
  (for [map-var (lookup-sym (ast/tag symbols-sym (ast/file-name defined-sym) (ast/line-number defined-sym)))
        init-fn-context (sm/get-val .rt-init)
        fn-context (reset-fn-context (.subs init-fn-context {}))

        sym-var (emit (ast/quoted-ast defined-sym))
        value (emit ast)
        global-var (comp (map (lookup-declaration defined-sym) .c-var)
                         (for [var (global-var defined-sym "var")
                               _ (sm/assoc-in-val [.module .declarations defined-sym]
                                                  (maybe (c-code var [] {} c/top-type)))
                               _ (declare ["Value *" var ";\n"])]
                           var))

        constraint (get-constraint (.c-var value))
        init-fn-context (reset-fn-context fn-context)
        _ (sm/set-val .rt-init init-fn-context)
        _ (constrain-var (ast/file-name ast) (ast/line-number ast) global-var constraint)
        _ (cond (empty? (.init value))
                sm-nop
                (sm/update-in-val [.setup .cleanup]
                                  (fn [cleanup]
                                    (conj cleanup ["freeGlobal(" global-var ");" line-sep]))))]
    (let [init (either (and (empty? (.init value))
                            (maybe [global-var " = " (.c-var value) ";" line-sep]))
                       (comp (.init value)
                             [global-var " = " (.c-var value) ";" line-sep
                              "if (" global-var "->refs > 0) "
                              global-var "->refs = -1;"]))]
      (-> value
          (.c-var global-var)
          (.init [init line-sep
                  (.c-var map-var) " = hashMapAssoc((Value *)" (.c-var map-var) ", " line-sep
                  (.c-var sym-var) ", " global-var ");" line-sep])))))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (cond (= (.lang ast) 'C)
            (for [line-info (line-macro ast "// inline")
                  :let [init [line-info (.txt ast) "\n#\n"]]

                  expr (comp (for [constraint (lookup-constraint (.result-type ast))
                                   c-var (genlocal "rslt")
                                   _ (constrain-var file-name line-number c-var constraint)]
                               (c-code c-var init {} constraint))
                             (wrap sm/zero-sm (c-code "" init {} c/top-type)))
                  _ (set-result-constraint (.c-var expr) file-name line-number)]
              expr)

            sm/zero-sm)))

  (emit-defined-value [ast defined-sym]
    (cond (= (.lang ast) 'C)
          (for [constraint (lookup-constraint (.result-type ast))
                c-var (comp (map (lookup-declaration defined-sym) .c-var)
                            (global-var defined-sym "var"))
                _ (new-module-def defined-sym (c-code (str c-var) [] {} constraint))
                line-info (line-macro ast "// inline")
                _ (declare [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"])
                sym-var (emit (ast/quoted-ast defined-sym))
                _ (constrain-var (ast/file-name defined-sym) (ast/line-number defined-sym) c-var constraint)]
            [(c-code c-var [] {} constraint)])

          sm/zero-sm))

  (emit-definition [ast]
    ;; TODO: what about the result-type
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          _ (declare [(.txt ast)])]
      [empty-c-code]))

  (wrap-tail [ast params]
    (Left (TailExpr ast))))

(extend-type ast/call-ast
  Emitter
  (emit-recursive-call [ast params]
    ;; TODO: check for closures and insert dec_and_free(arity->parent, 1);
    (for [_ (sm/when (instance? Tagged (.call-target ast)))
          target (emit (.call-target ast))
          _ (sm/get-in-val [.fn-context .fn-spec .arity-info (.c-var target) (count (.args ast))])
          args (sm/traverse (.args ast) emit)
          line (line-macro ast "// recursive-fixed")]
      (do
        ;; TODO: collapse-expressions doesn't seem to work
        ;; (collapse-expressions (comp args
        ;;                             [(c-code ""
        ;;                                      [line
        ;;                                       (map (zip-lists params (map args .c-var))
        ;;                                            (fn [[param arg]]
        ;;                                              [param " = " arg ";" line-sep]))]
        ;;                                      {} c/top-type)]))
        (comp* empty-c-code (comp args
                                  [(c-code ""
                                           [line
                                            (map (zip-lists params (map args .c-var))
                                                 (fn [[param arg]]
                                                   [param " = " arg ";" line-sep]))]
                                           {} c/top-type)])))))

  (emit-defined-value [fn-val defined-sym]
    (comp (define-enum-type fn-val defined-sym)
          (for [value (init-at-runtime fn-val defined-sym)
                constraint (get-constraint (.c-var value))
                _ (new-module-def defined-sym (c-code (.c-var value) [] {} constraint))]
            [(c-init (.c-var value) [(.init value) (.c-var value) " = " (.c-var value) ";" "\n#\n"]
                     (.refs-map value) (ast/file-name fn-val) (ast/line-number fn-val))])))

  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (.call-target ast (either (instance? Symbol (.call-target ast))
                                        (.call-target ast)))]
      (comp (flat-map (inline-expr (.call-target ast) (.args ast))
                      (fn [x]
                        ;; (cond (= file-name "test.toc")
                        ;;       (for [_ (debug 'old file-name line-number "\n" ast)
                        ;;             _ (debug 'new "\n" x)
                        ;;             r (emit x)]
                        ;;         r))

                        (emit x)))
            ;; TODO: this is a refactoring of the below expression, but not sure it's better
            ;; (for [target (emit (.call-target ast))
            ;;       expr (comp (for [args (sm/traverse (.args ast) emit)
            ;;                        call-site (comp (emit-call-site target args ast)
            ;;                                        (compilation-error "Could not compile call site at:"
            ;;                                                           file-name line-number))]
            ;;                    (do
            ;;                      ;; TODO: why does 'collapse-expressions' not work here?
            ;;                      ;; (collapse-expressions (comp [target] args [call-site]))
            ;;                      (comp* target (comp args [call-site])))))]
            ;;   expr)
            (flat-map (sm/traverse (.args ast) emit)
                      (fn [args]
                        (comp (for [target (emit (.call-target ast))
                                    call-site (emit-call-site target args ast)]
                                (do
                                  ;; TODO: why does 'collapse-expressions' not work here?
                                  ;; (collapse-expressions (comp [target] args [call-site]))
                                  (comp* target (comp args [call-site]))))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (wrap-tail [ast params]
    (Left (TailCall ast params)))

  (inline-expr [ast arg-asts]
    (let [target (.call-target ast)
          file-name (ast/file-name target)
          line-number (ast/line-number target)]
      (comp (for [_ (sm/when (instance? ast/tagged-symbol target))
                  ;; TODO; this is not general enough. Needs to handle more than one field
                  ;; and multiple fields being fn's
                  constructor (lookup-sym target)
                  :when (instance? c-constructor constructor)
                  invoke-info (get-core-proto-impl Function-sym invoke-sym
                                                   (-> ast .args count inc)
                                                   (.type-num constructor))
                  new-params (sm/when (map (get-in invoke-info [.ast .params])
                                           (fn [params]
                                             (ast/params-ast (rest (.fixed params))
                                                             nothing))))
                  new-body (sm/when (for [ast-body (get-in invoke-info [.ast .body])
                                          let-ast (some ast-body (partial instance? ast/let-ast))]
                                      (.body let-ast)))
                  fn-ast (sm/when (flat-map (first (.args ast))
                                            (partial instance? ast/fn-ast)))
                  fn-field (sm/when (first (.fields constructor)))
                  new-ast (-> (ast/fn-arity new-params
                                            (ast/block-comment file-name line-number [])
                                            new-body)
                              replace-bound-vars
                              (replace-syms {fn-field fn-ast})
                              (inline-expr arg-asts))]
              new-ast)
            (for [new-call-target (inline-expr target (.args ast))
                  new-ast (inline-expr new-call-target arg-asts)]
              new-ast)))))

;; TODO: when a proto impl is wrong (ie; wrong number of args)
;; the error message is trash
(extend-type C-expr
  ast/IsCode
  (ast/generates-code? [expr]
    (maybe expr))

  Emitter
  (wrap-tail [expr _]
    (Left (TailExpr expr)))

  (emit [x]
    (sm/state-maybe x)))

(extend-type c-code
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-field
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-param
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-constructor
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-reified
  Emitter
  (get-result-constraint [expr num-args]
    (map (get-core-proto-impl Function-sym invoke-sym (inc num-args) (.type-num expr))
         .result-constraint))

  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-protocol-fn
  C-Code
  (expr-constraints [expr]
    fn-constraint))

(extend-type c-static-int
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-str
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-sym
  Emitter
  (clear-init [expr]
    (c-code (.c-var expr) [] {(.c-var expr) 1} c/top-type))

  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-closure-fn
  CallSite
  (emit-call-site [target args ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (for [arity-info (sm/when (or (get-in target [.arities (count args)])
                                          (map (get-in target [.arities 'variadic])
                                               (fn [arity-info]
                                                 (either (c/compose-constraints
                                                          file-name line-number
                                                          (c/StaticLengthConstraint (count args)
                                                                                    empty-list nothing "")
                                                          (.param-constraints arity-info))
                                                         (abort))
                                                 arity-info))))
                  ;; _ (debug 'call-closure file-name line-number (.call-target ast) (.c-var target) "\n"
                  ;;          (.param-constraints arity-info) "\n"
                  ;;          'result-c (.result-constraint arity-info))
                  _ (constrain-args args (-> arity-info
                                             .param-constraints
                                             (c/extract-items-constraints (count args)))
                                    file-name line-number)
                  expr (call-dyn-fn-value target args ast)
                  _ (flat-map (reify-constraint (.result-constraint arity-info) args file-name line-number)
                              (partial constrain-var file-name line-number (.c-var expr)))
                  ;; TODO: restore
                  ;; _ (either (add-inner-constraint (.c-var expr) ast args)
                  ;;           (wrap sm/zero-sm '_))
                  ;; _ (add-hash-map-constraints ast (.c-var expr) args)
                  ;; _ (add-contents-constraint ast (.c-var expr) args)
                  ]
              expr)
            (compilation-error "No arity with" (count args) "arguments found"
                               (either (map (instance? Tagged (.call-target ast))
                                            (fn [sym]
                                              (str "for '" sym "'")))
                                       "")
                               "at:" (ast/file-name ast) (ast/line-number ast)))))

  Emitter
  (get-result-constraint [expr num-args]
    ;; TODO: add variadic
    (sm/when (get-in expr [.arities num-args .result-constraint])))

  (clear-init [expr]
    (-> expr
        (.init [])
        (.refs-map {(.c-var expr) 1})))

  C-Code
  (expr-constraints [expr]
    fn-constraint))

(extend-type c-static-fn
  Emitter
  (get-result-constraint [expr num-args]
    ;; TODO: add variadic
    (sm/when (get-in expr [.arities num-args .result-constraint])))

  (clear-init [expr]
    (-> expr
        (.init [])
        (.refs-map {(.c-var expr) 1})))

  C-Code
  (expr-constraints [expr]
    fn-constraint))

(extend-type ast/tagged-symbol
  Emitter
  (dissoc-sym [x]
    (for [_ (sm/update-state (fn [[subs & subs-list]]
                               (cons (dissoc subs (ast/tag x))
                                     subs-list)))]
      (Left x)))

  (new-bound-var [x]
    (let [new-var (ast/tag (gensym (str x))
                           (ast/file-name x)
                           (ast/line-number x))]
      (for [_ (sm/update-state (fn [[subs & subs-list]]
                                 (cons (assoc subs x new-var)
                                       subs-list)))]
        (Left new-var))))

  (update-syms [x _]
    (map (comp (sm/get-in-val [0 x])
               (sm/state-maybe x))
         Left))

  (encode-static [x]
    (emit (ast/quoted-ast (.sym x))))

  (all-symbols [ast]
    [ast]))

(defn bind-list [param-var fixed-bindings tail-binding file-name line-number]
  (let [tail-var (.bound tail-binding)
        content-vars (map fixed-bindings .bound)
        fixed-count (count fixed-bindings)]
    (for [_ (set-sym param-var (c-code param-var [] {} c/top-type))
          dest-args (genlocal "destArgs")
          _ (cond (= 0 fixed-count)
                  sm-nop
                  (constrain-var file-name line-number
                                 param-var
                                 (rdr/assert-min-count file-name line-number fixed-count)))
          items-constraints (map (get-constraint param-var)
                                 c/extract-items-constraints)
          _ (sm/traverse (zip-lists content-vars items-constraints)
                         (fn [[var const]]
                           (append-constraint var const file-name line-number)))
          _ (append-constraint tail-var (-> list-constraint
                                            (c/update-var tail-var))
                               file-name line-number)]
      (ParamBinding param-var
                    fixed-bindings tail-var
                    (comp [(c-code ""
                                   (destruct-seq param-var
                                                 (conj content-vars tail-var)
                                                 (str dest-args) file-name line-number)
                                   {param-var 1} c/top-type)]
                          (map (conj content-vars tail-var)
                               (fn [var]
                                 (c-init var [] {} file-name line-number)))
                          (flat-map (conj fixed-bindings tail-binding) .destruct))))))

(extend-type ast/params-ast
  Emitter
  (wrap-tail [ast params]
    (Left ast))

  (all-symbols [params]
    (comp* (either (.variadic params)
                   [])
           (seq (.fixed params))))

  (get-param-cs [params]
    (sm/state-maybe (-> c/empty-items-constraint
                        (.tail-constraint (either (.variadic params)
                                                  c/top-type))
                        (.items-constraints (.fixed params)))))

  (pre-bind [params]
    (sm/state-maybe (cond (.variadic params)
                          params

                          (.variadic params (maybe (ast/tag "restArgs"))))))

  (bind-param-expr [params]
    (flat-map (genlocal "arg")
              (fn [param-var]
                (bind-list param-var
                           (.fixed params)
                           (either (.variadic params)
                                   (do
                                     (print-err "Compiler error at toccata.toc:" _LINE_)
                                     (abort)))
                           (ast/file-name params)
                           (ast/line-number params)))))



  (bind-expr [params]
    (flat-map (genlocal "arg")
              (fn [param-var]
                (bind-list param-var
                           (.fixed params)
                           (either (.variadic params)
                                   (do
                                     (print-err "Compiler error at toccata.toc:" _LINE_)
                                     (abort)))
                           (ast/file-name params)
                           (ast/line-number params)))))

  (bind-expr [params evalled]
    (let [evalled (.refs-map evalled (dissoc (.refs-map evalled) (.c-var evalled)))]
      (for [tail-binding (bind (either (.variadic params)
                                       (ast/tag "restArgs")))
            fixed-bindings (sm/traverse (.fixed params) bind)
            _ (cond (empty? (.init evalled))
                    (set-sym (.c-var evalled) evalled)
                    sm-nop)
            binding (bind-list (.c-var evalled)
                               fixed-bindings
                               tail-binding
                               (ast/file-name params)
                               (ast/line-number params))]
        (.destruct binding (-> evalled
                               (.refs-map (dissoc (.refs-map evalled) (.c-var evalled)))
                               vector
                               (comp (.destruct binding)))))))

  (new-bound-var [ast]
    (sm/state-maybe (Right ast)))

  (dissoc-sym [ast]
    (sm/state-maybe (Right ast)))

  (update-syms [ast handle-bindings]
    (either (map (.variadic ast) (fn [var]
                                   (for [new-fixed (map (.fixed ast)
                                                        (fn [param]
                                                          (apo handle-bindings param sm/state-maybe))
                                                        sm/state-maybe)
                                         new-var (apo handle-bindings var sm/state-maybe)]
                                     (Left (ast/params-ast new-fixed (maybe new-var))))))

            (map (map (.fixed ast)
                      (fn [param]
                        (apo handle-bindings param sm/state-maybe))
                      sm/state-maybe)
                 (fn [new-fixed]
                   (Left (ast/params-ast new-fixed nothing)))))))


(extend-type ast/binding-ast
  Emitter
  (update-syms [ast handle-bindings]
    (for [new-val (elgot (fn [ast]
                           (update-syms ast handle-bindings))
                         pop-subs (.val ast) sm/state-maybe)
          new-bound (apo handle-bindings (.binding ast) sm/state-maybe)]
      (Left (ast/binding-ast new-bound new-val))))

  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [locals get-syms
            bindings (sm/traverse (.bindings ast) emit)
            body-exprs (sm/traverse (.body ast) emit)
            _ (sm/traverse bindings constrain-params)
            code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))
            result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                               (genlocal "let_rslt"))
            _ (propogate-constraint (.c-var code) result-var identity
                                    file-name line-number)
            _ (set-syms locals)]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.refs-map code) file-name line-number))))

  (emit-defined-value [ast defined-sym]
    (for [value (init-at-runtime ast defined-sym)
          val-constraint (get-constraint (.c-var value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] {} val-constraint))]
      [(c-init (.c-var value) [(.init value) (.c-var value) " = " (.c-var value) ";" "\n#\n"]
               (.refs-map value) (ast/file-name ast) (ast/line-number ast))]))

  (wrap-tail [ast params]
    ;; TODO: move this filtering of the body to the Vector implementation of wrap-tail
    (-> ast
        (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                     (-> ast
                         .body
                         (filter ast/generates-code?)
                         (tail-call params))))
        Left))

  (update-syms [ast _]
    (for [_ (sm/update-state (fn [subs-list]
                               (either (map (first subs-list)
                                            (fn [head]
                                              (cons head subs-list)))
                                       (list {}))))]
      (Right ast)))

  (pop-subs [ast]
    (map (sm/update-state rest)
         (fn [subs]
           (or (= (str (ast/file-name ast)) "core")
               (maybe (print-err 'subs subs)))
           ast)))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_]
                                      (ast/tag (gensym "#arg") (ast/file-name ast) (ast/line-number ast))))
          new-body (either (empty? (.body ast))
                           (let [[tail & init] (-> (.body ast)
                                                   (remove (partial instance? ast/NoCode))
                                                   reverse)]
                             (-> (ast/call-ast tail unique-syms)
                                 (cons init)
                                 reverse
                                 vec)))
          new-body (comp (filter (.body ast) (partial instance? c/Constraints))
                         new-body)]
      (sm/state-maybe (ast/let-ast
                       (comp (make-bindings unique-syms arg-asts)
                             (.bindings ast))
                       new-body)))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [constraint type-num impl-fns]
  (let [inits (map impl-fns .init)
        file-name (ast/file-name constraint)
        line-number (ast/line-number constraint)]
    (for [reified-sym (genlocal "reifiedDyn")
          _ (constrain-var file-name line-number
                           reified-sym constraint)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = " (count impl-fns) ";" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (apply merge-with (list* + (map impl-fns .refs-map))) file-name line-number))))

(defn static-reified-value [constraint type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")
        :let [constraint (c/update-var constraint reified-ptr)]
        _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                         reified-ptr constraint)
        _ (declare ["ReifiedVal " reified-sym " = {"
                    type-num ", -2, 0, "
                    "0, {}};" line-sep
                    "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep])]
    (c-static-reified type-num reified-ptr [] {} constraint reified-sym)))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name params)
        line-number (ast/line-number params)
        constraints-list (c/extract-items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramCheckerFn")
          line (line-macro params "// param checking fn")
          checked-var (genlocal 'checked)]
      (cond
       (.variadic params)
       (c-code checking-fn-var
               ["Value *" checking-fn-var
                "(FnArity *arity, Value *args) {\n"
                line
                "int " checked-var "= 1;"
                (-> constraints
                    (c/update-var "args")
                    ;; TODO: what if runtime-check is empty?
                    (runtime-check c/top-type file-name line-number checked-var))
                "if(!" checked-var "){abort();}" line-sep
                "return(" arity-fn-var
                "(arity, args));\n};\n"]
               {} c/top-type)
       (every constraints-list (partial = c/top-type))
       (c-code arity-fn-var [] {} c/top-type)

       (c-code checking-fn-var
               ["Value *" checking-fn-var "("
                (-> param-vars
                    (map (fn [param] (str "Value *" param)))
                    (seq)
                    (conj "FnArity *arity")
                    (interpose ", "))
                ") {\n"
                line
                "int " checked-var "= 1;"
                (for [[constraint var] (zip-lists constraints-list
                                                  param-vars)]
                  ;; TODO: what if runtime-check is empty?
                  (-> constraint
                      (c/update-var var)
                      (runtime-check c/top-type file-name line-number checked-var)))
                "if(!" checked-var "){abort();}" line-sep
                "return(" arity-fn-var "("
                (-> param-vars
                    (seq)
                    (conj "arity")
                    (interpose ", "))
                "));\n};\n"]
               {} c/top-type)))))

(def vect-array-len (inline C Integer "(Value *)&(Integer){IntegerType, -2, VECTOR_ARRAY_LEN};"))

(defn destruct-closures [closure-info]
  (let [closure-count (count closure-info)]
    (cond (<= closure-count vect-array-len)
          (sm/state-maybe (conj (map (vec (zip-lists (range closure-count) closure-info))
                                     ;; TODO: the runtime error message for this version is awful
                                     ;; (fn [[idx [arg _ constraint]]]
                                     (fn [[idx [arg _]]]
                                       (c-init arg ["Value *" arg " = arity->closures->tail[" idx "];"
                                                    " incRef(" arg ",1);" line-sep]
                                               {} "" 0)))
                                (c-code "" ["if (arity->parent) incRef(arity->parent, 1);" line-sep]
                                        {} c/top-type)))

          (for [destArgs (genlocal "destArgs")]
            (let [closures (-> closure-info
                               (map (fn [[arg]] arg))
                               vec
                               (conj "closuresTail"))
                  closure-count (count closures)]
              (comp [(c-code ""
                             [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                              "incRef((Value *)arity->closures, 1);" line-sep
                              "Value **" destArgs "[" closure-count "] = {"
                              (interpose (map closures (partial vector "&")) ", ")
                              "};" line-sep
                              "destructValue(\"\", \"\", (Value *)arity->closures"
                              ", " closure-count ", " destArgs ");" line-sep
                              "if (arity->parent) incRef(arity->parent, 1);" line-sep]
                             {} c/top-type)]
                    (map (vec closure-info)
                         (fn [[arg _]]
                           (c-init arg [] {} "" 0)))))))))

(defn emit-closure-arity [fn-sym fn-var fn-context c-fn params param-vars body-exprs]
  (assert (instance? String fn-var))
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [closures (extract-closures)
          closure-subs (get-subs)
          closures-destruct (destruct-closures closures)
          body (collapse-expressions (comp closures-destruct
                                           (either (= "" fn-var)
                                                   [(c-init fn-var ["Value *" fn-var " = arity->parent;"
                                                                    " incRef(" fn-var ",1);" line-sep]
                                                            {} "" 0)])
                                           body-exprs))

          result-constraint (get-constraint (.c-var body))
          param-constraints (flat-map (get-param-constraints params)
                                      (fn [param-constraints]
                                        (reify-constraint param-constraints [] "" 0)))
          _ (reset-fn-context fn-context)
          closed-over (sm/traverse closures (fn [[closed-over sym]]
                                              (map (lookup-sym sym)
                                                   (fn [expr]
                                                     [closed-over (.c-var expr)]))))
          _ (sm/traverse (for [[closure outer] closed-over
                               :let [closure-c (get closure-subs closure)]
                               :when closure-c]
                           [outer (extract closure-c)])
                         (fn [[outer-var constraint]]
                           (append-constraint outer-var constraint file-name line-number)))
          arity-var (genlocal fn-sym "dynArity")
          closure-vars (sm/traverse closures (fn [[closed-over sym]]
                                               (for [closure (lookup-sym sym)]
                                                 (c-code ""
                                                         [arity-var "->closures = mutateVectConj("
                                                          "(Vector *)" arity-var "->closures"
                                                          ", (Value *)" (.c-var closure) ");" line-sep]
                                                         {(.c-var closure) 1}
                                                         (c/update-var list-constraint (str (.c-var closure)))))))

          line (line-macro fn-sym "// paramChecker")
          checked-var (genlocal 'checked)
          :let [check-params (either (for [_ (.variadic params)
                                           var-args (first param-vars)]
                                       (-> param-constraints
                                           (c/update-var var-args)
                                           (runtime-check c/top-type file-name line-number checked-var)))
                                     (for [[constraint var] (zip-lists
                                                             (c/extract-items-constraints param-constraints
                                                                                          (count param-vars))
                                                             param-vars)]
                                       ;; TODO: what if runtime-check is empty?
                                       (-> constraint
                                           (c/update-var var)
                                           (runtime-check c/top-type file-name line-number checked-var))))]
          _ (declare ["Value *" c-fn "("
                      (-> param-vars
                          (map (partial str "Value *"))
                          (seq)
                          (conj "FnArity *arity")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      line
                      "if(1){int " checked-var " = 1;" line-sep
                      check-params
                      "if(!" checked-var "){abort();}}" line-sep
                      (.init body)
                      line-sep "};};\n"])
          :let [arity-init ["FnArity *" arity-var
                            " = malloc_fnArity();" line-sep
                            arity-var "->count = " (count param-vars)
                            ";" line-sep
                            arity-var "->variadic = "
                            (cond (.variadic params)
                                  "1"
                                  "0")
                            ";" line-sep
                            arity-var "->fn = " c-fn ";" line-sep
                            arity-var "->closures = empty_vect;" line-sep]]
          expr (collapse-expressions (comp [(c-code arity-var arity-init {} c/top-type)]
                                           closure-vars
                                           [(c-init arity-var [] {} file-name line-number)]))]
      (ClosureArity c-fn params (cond (.variadic params)
                                      'variadic
                                      (count params))
                    expr
                    param-constraints (c/clear-vars result-constraint)))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars body-exprs]
  (assert (instance? ast/params-ast params))
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [body (collapse-expressions body-exprs)
          arity-var (global-var fn-sym "staticArity")
          result-constraint (get-constraint (.c-var body))
          param-constraints (flat-map (get-param-constraints params)
                                      (fn [param-constraints]
                                        (reify-constraint param-constraints [] "" 0)))
          runtime-check-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)
          ;; TODO: put back in when rstoring the interpreter
          ;; param-struct (encode-static param-constraints)
          ;; rslt-struct (encode-static result-constraint)
          ]
      (let [expr (c-static-arity (ArityValPtr (str "&" arity-var) arity-var) [] {} arity-var)]
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= c/UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn params (cond (.variadic params)
                                              'variadic
                                              (count params))
                     (.init expr ["Value *" c-fn "("
                                  (-> param-vars
                                      (map (partial str "Value *"))
                                      (seq)
                                      (conj "FnArity *arity")
                                      (interpose ", "))
                                  ") {\nwhile (1) {\n"
                                  (.init body)
                                  line-sep "};};\n"
                                  (.init runtime-check-fn)
                                  "FnArity " arity-var " = {FnArityType, -2, "
                                  (count param-vars)
                                  ", (Vector *)0, (Value *)0, " (cond (.variadic params)
                                                                      "1"
                                                                      "0")
                                  ", " (.c-var runtime-check-fn)
                                  ;; TODO: put back in when rstoring the interpreter
                                  ;; ", (Value *)&" (.c-struct param-struct)
                                  ;; ", (Value *)&" (.c-struct rslt-struct)
                                  ", (Value *)0, (Value *)0"
                                  "};" line-sep])
                     param-constraints (c/clear-vars result-constraint))))))

(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? CFnPtr c-fn))

   ;; TODO: there are two ResultConstraint's in 'body'
   (either (and (empty? (remove body (partial instance? ast/NoCode)))
                (maybe sm/zero-sm))
           ;; TODO: I'm tired of file-name not being accurate for compiler-generated fns
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 constraints (filter body (partial instance? c/Constraints))
                 body (remove body (partial instance? ast/NoCode))
                 fn-constraint (-> fn-constraint
                                   (c/update-var (str fn-var))
                                   (c/update-sym (ast/untag fn-sym)))
                 fn-sym (either (instance? ast/tagged-symbol fn-sym)
                                (ast/tag fn-sym file-name line-number))]
             (for [fn-context (reset-fn-context)
                   ;; _ (debug "------------\n" (ast/file-name fn-sym) (ast/line-number fn-sym) 'fn-arity fn-sym)
                   p-bindings (bind-param params)
                   _ (cond (.variadic params)
                           sm-nop
                           (sm/assoc-in-val [.fn-context .fn-spec .arity-info
                                             fn-var (count params)] '_))
                   :let [param-vars (map p-bindings .bound)
                         param-destruct (cond
                                         (some body (partial instance? ast/inline-ast))
                                         []

                                         (.variadic params)
                                         (flat-map p-bindings .destruct)

                                         (comp (map param-vars
                                                    (fn [var]
                                                      (c-init var [] {}
                                                              (ast/file-name params)
                                                              (ast/line-number params))))
                                               (flat-map p-bindings .destruct)))]
                   _ (sm/traverse param-vars
                                  (fn [var]
                                    (set-constraint var c/top-type)))
                   _ (sm/traverse (zip-lists (.fixed params) (range (count (.fixed params))))
                                  (fn [[sym index]]
                                    (cond (instance? ast/params-ast sym)
                                          sm-nop

                                          (flat-map (map (lookup-sym sym) .c-var)
                                                    (fn [var]
                                                      (set-constraint var (c/DynamicParamConstraint
                                                                           index empty-list (maybe sym) var
                                                                           c/top-type)))))))
                   _ (set-constraint "#result" c/top-type)

                   syms get-syms
                   _ (either (map (get syms fn-sym) sm/state-maybe)
                             (set-sym fn-sym (c-code fn-var [] {fn-var 1} fn-constraint)))
                   body-exprs (-> (comp param-destruct constraints body)
                                  (tail-call param-vars)
                                  ;; ((fn [b]
                                  ;;    (and (= fn-sym 'bogus)
                                  ;;         (do
                                  ;;           (print-err 'params param-destruct)
                                  ;;           (print-err 'body "\n" (interpose b "\n"))
                                  ;;           nothing))
                                  ;;    b))
                                  (sm/traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-var fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars body-exprs))
                   ;; _ (debug "============")
                   ]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-sym arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-sym "staticImpl")
          arity-impl-var (global-var (str type-str fn-sym) "arityImpl")
          c-fn (global-var (str type-str fn-sym) "arityFn")
          :let [arity-impl-var (ArityValPtr arity-impl-var "")
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (lookup-sym fn-sym)
          dispatcher-info (sm/when (get-in dispatcher-info [.arities num-args]))

          ;; [arity-fn-var c-fn param-count var-info param-constraints result-constraint]

          :let [sym-map (reduce (zip-lists (-> dispatcher-info .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (cond (= old-sym new-sym)
                                           m
                                           (assoc m old-sym new-sym))))]
          :let [param-assertions (-> dispatcher-info
                                     .param-constraints
                                     (replace-syms sym-map)
                                     c/extract-items-constraints
                                     (map (fn [c]
                                            (c/update-var c ""))))
                arity-ast (.body arity-ast (comp [(c/ResultConstraint (.result-constraint dispatcher-info))]
                                                 param-assertions (.body arity-ast)))]
          _ (new-proto-impl proto-sym fn-sym num-args type-num arity-impl-var arity-ast
                            (-> c/empty-items-constraint
                                (.items-constraints param-assertions))
                            c/top-type c-fn)
          _ (declare ["Value *" c-fn "("
                      (-> arity-ast
                          .params
                          .fixed
                          (map (fn [_] "Value *"))
                          (seq)
                          (conj "FnArity *arity")
                          (interpose ", "))
                      ");\n"
                      "FnArity *" arity-impl-var ";\n"])]
      (ProtoImplDeclaration proto-sym fn-sym
                            arity-ast
                            arity-impl-var c-fn))))

(deftype ConstrainVar [constraint]
  (assert (instance? c/ValueConstraint constraint))

  Stringable
  (string-list [_]
    (list "(ConstrainVar " (str constraint) ")"))

  Container
  (map [x f]
    (ConstrainVar (f constraint)))

  (map [x f embed]
    (map (f constraint) ConstrainVar))

  ast/IsCode
  (ast/generates-code? [x]
    (maybe x))

  Emitter
  (emit [_]
    (either (map (c/extract-sym constraint)
                 (fn [sym]
                   (for [sym-info (-> sym
                                      (ast/tag (ast/file-name constraint) (ast/line-number constraint))
                                      lookup-sym)
                         _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                          (.c-var sym-info) constraint)]
                     empty-c-code)))
            (wrap sm/zero-sm empty-c-code))))

(defn emit-impl [type-str disp-constraint type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)
        disp-constraint (either (for [type-map (c/extract-type-map disp-constraint)
                                      fields (get type-map type-num)]
                                  (c/TypeConstraint {type-num fields} empty-list
                                                    (symbol type-str)
                                                    (maybe (ast/untag disp-param)) ""))
                                disp-constraint)]
    (for [;; _ (debug 'impl file-name line-number type-str fn-sym num-args "\n" disp-constraint)
          default-impl (get-proto-impl proto-sym fn-sym num-args 0)
          ext-fn (comp (emit-fn-arity (symbol (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [(-> disp-constraint
                                                 (c/update-path file-name line-number))
                                             (-> (.result-constraint default-impl)
                                                 (c/update-path file-name line-number)
                                                 c/ResultConstraint)]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          ext-fn (cond (instance? StaticArity ext-fn)
                       (-> ext-fn
                           .var-info
                           .init
                           declare
                           (map (fn [_]
                                  (.var-info ext-fn (.init (.var-info ext-fn) [])))))

                       (sm/state-maybe ext-fn))
          :let [ext-fn (cond (= fn-sym 'instance?)
                             (either (update-in ext-fn [.param-constraints .items-constraints]
                                                (fn [cs]
                                                  (either (store cs 1 c/top-type)
                                                          cs)))
                                     ext-fn)

                             ext-fn)]
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.init reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast constraint type-num]
  (assert (instance? Integer type-num))

  (let [impl-arities (for [[proto-sym impl-fns] (vec (.impls ast))
                           [fn-name arities] (vec impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
    (cond (empty? impl-arities)
          (sm/state-maybe [])
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num]) str)
                               (wrap sm/zero-sm (str "_" type-num "_")))
                _ (sm/traverse (keys (.impls ast))
                               (fn [proto-sym]
                                 (comp (lookup-protocol proto-sym)
                                       (compilation-error "Invalid protocol:" proto-sym "in"
                                                          (str (ast/file-name proto-sym) ",")
                                                          (ast/line-number proto-sym)))))
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (sm/traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (sm/traverse impl-arities (partial emit-impl type-str constraint type-num))]
            (cons head-fn fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [file (ast/file-name ast)
          line (ast/line-number ast)
          reified-type-num (either (.type-num ast)
                                   (extract type-counter))
          constraint (c/TypeConstraint {reified-type-num #{}} (list [file line])
                                       (symbol (str "reified at " file ": " line))
                                       nothing "")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast constraint reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (either (map (every impl-fns (partial instance? c-static-arity))
                                        (fn [_]
                                          (static-reified-value constraint reified-type-num impl-fns)))
                                   (closure-reified-value constraint reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (let [x* (ast/tag "#x")
          y* (ast/tag "#y")
          file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (cond (get-in ast [.impls Eq-sym =*-sym])
                    ast
                    (assoc-in ast [.impls Eq-sym =*-sym]
                              [(ast/fn-arity
                                (ast/tag (str defined-sym "_EQ_QMARK_") file-name line-number)
                                (ast/params [x* y*]) ""
                                [(ast/and-ast
                                  [(ast/call-ast =*-sym
                                                 [(ast/call-ast get-type-sym [x*])
                                                  (ast/call-ast get-type-sym [y*])])
                                   (ast/call-ast maybe-sym [y*])])])]))]
      (for [value (init-at-runtime ast defined-sym)
            _ (new-module-def defined-sym (c-static-reified (.type-num value)
                                                            (.c-var value) [] {}
                                                            (.constraints value)
                                                            (.c-struct value)))]
        [value])))

  (wrap-tail [ast params]
    (Left (TailCall ast params))))

(defn filter-vals [m f]
  (reduce (vec m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defn conditional-rt-checks [vars final-subs init-subs file-name line-number]
  (sm/traverse vars
               (fn [var]
                 (let [init-c (either (get init-subs var)
                                      c/top-type)
                       final-c (either (get final-subs var)
                                       c/top-type)]
                   (cond (c/satisfied-by final-c init-c)
                         (sm/state-maybe [])

                         (for [checked-var (genlocal 'checked)
                               _ (append-constraint var final-c file-name line-number)]
                           ["int " checked-var " = 1;" line-sep
                            (runtime-check final-c init-c
                                           file-name line-number checked-var)
                            line-sep "if(!" checked-var "){abort();}"]))))))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          line-number (ast/line-number clause)]
      (for [syms get-syms
            init-subs (get-subs)
            expr (emit clause)
            final-subs (get-subs)
            curr-const (get-constraint (.c-var expr))
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)
            _ (set-syms syms)
            rt-checks (-> expr
                          .refs-map
                          (dissoc (.c-var expr))
                          keys
                          (conditional-rt-checks final-subs init-subs file-name line-number))
            checked-var (genlocal 'checked)]
        (cond (= (.c-var expr) "")
              expr
              (.init expr [rt-checks
                           (.init expr)
                           (cond  (instance? c-param expr)
                                  ""
                                  (let [rt-check (-> maybe-constraint
                                                     (c/update-path file-name line-number)
                                                     (c/update-var (.c-var expr))
                                                     (runtime-check curr-const file-name line-number checked-var))]
                                    (either (empty? rt-check)
                                            ["if(1){int " checked-var " = 1;" line-sep
                                             rt-check
                                             line-sep "if(!" checked-var "){abort();}}" line-sep])))]))))))

(extend-type TailCall
  EmitCond
  (emit-cond-clause [clause]
    (emit clause)))

(extend-type Tagged
  EmitCond
  (emit-cond-clause [sym]
    (let [file-name (ast/file-name sym)
          line-number (ast/line-number sym)]
      (for [expr (emit sym)
            curr-const (get-constraint (.c-var expr))
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)
            checked-var (genlocal 'checked)]
        (.init expr [(.init expr)
                     (cond (instance? c-param expr)
                           ""
                           (let [rt-check (-> maybe-constraint
                                              (c/update-path file-name line-number)
                                              (c/update-var (.c-var expr))
                                              (c/update-sym (ast/untag sym))
                                              (runtime-check curr-const file-name line-number checked-var))]
                             (either (empty? rt-check)
                                     ["if(1){int " checked-var " = 1;" line-sep
                                      rt-check
                                      line-sep "if(!" checked-var "){abort();}}" line-sep])))])))))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (assert (instance? Vector init))
  (assert (instance? C-expr clause))

  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj init
           [(.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            (either (empty? cond-test)
                    [cond-test result-var ",\"\",0)) {" line-sep])
            (map (vec refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))
        last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))
        last-init [(.init last-clause)
                   (either (= "" (.c-var last-clause))
                           [result-var " = " (.c-var last-clause) ";" line-sep])]]
    (conj clause-inits last-init)))

(defn clause-refs [exprs result-var]
  (-> (apply merge-with (list* + (map exprs .refs-map)))
      (dissoc result-var)))

(defn emit-and-expr [result-var clauses tail-return]
  (let [file-name (ast/file-name clauses)
        line-number (ast/line-number clauses)]
    (either (map (first clauses)
                 (fn [clause]
                   (for [expr (emit-cond-clause clause)
                         final-subs (get-subs)
                         expr-cs (sm/traverse (rest clauses)
                                              (fn [clause]
                                                (for [expr (emit-cond-clause clause)
                                                      constraint (get-constraint (.c-var expr))]
                                                  [constraint expr])))
                         _ (sm/assoc-in-val [.fn-context .subs] final-subs)
                         exprs (sm/traverse expr-cs
                                            (fn [[c expr]]
                                              (map (constrain-var file-name line-number (.c-var expr) c)
                                                   (fn [_]
                                                     expr))))
                         :let [exprs (comp [expr] exprs)]

                         last-expr (sm/when (last exprs))
                         _ (propogate-constraint (.c-var last-expr) result-var
                                                 identity file-name line-number)
                         free-parent (cond (= tail-return "")
                                           (sm/state-maybe "")

                                           (free-closure-parent))]
                     (let [tail-return [free-parent line-sep tail-return]
                           refs-map (clause-refs exprs result-var)]
                       (c-init result-var
                               ["Value *" result-var ";" line-sep
                                (-> exprs
                                    (clause-inits "if (isNothing("  refs-map result-var)
                                    (interpose [tail-return "} else {" line-sep
                                                "dec_and_free(" result-var ", 1);" line-sep]))
                                (-> (count exprs)
                                    dec
                                    (repeat (str "}" line-sep)))]
                               refs-map file-name line-number)))))
            (wrap sm/zero-sm empty-c-code))))

(deftype TailAnd [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ")
          (flat-map (vec clauses) string-list)
          (list ">")))

  Container
  (map [x f]
    (TailAnd (map clauses f)))

  (map [x f embed]
    (map (map clauses f embed) TailAnd))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "andRslt")
            _ (constrain-var file-name line-number "#result" maybe-constraint)
            check-fn (global-var 'checker)
            ;; TODO: test a closure with a TailAnd
            expr (emit-and-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode))
                                (str "return(nothing);" line-sep))
            result-const (get-constraint "#result")
            expr-const (get-constraint (.c-var expr))
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr))))

(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (flat-map (genlocal "andRslt")
                (fn [result-var]
                  (emit-and-expr result-var clauses "")))))

  (wrap-tail [ast params]
    (-> (.clauses ast)
        ;; TODO: move this filtering to the Vector wrap-tail
        (filter ast/generates-code?)
        (tail-call params)
        TailAnd
        Left)))

(defn assert-maybe-of [type-expr]
  (assert (instance? c/ValueConstraint type-expr))

  (let [path (list [(ast/file-name type-expr) (ast/line-number type-expr)])]
    (c/MultiConstraint [maybe-constraint (c/CollectionOf type-expr path nothing "")])))

(defn emit-or-expr [result-var clauses tail-return]
  (let [file-name (ast/file-name clauses)
        line-number (ast/line-number clauses)]
    (either (map (first clauses)
                 (fn [clause]
                   (for [expr (emit-cond-clause clause)
                         final-subs (get-subs)

                         expr-cs (sm/traverse (rest clauses)
                                              (fn [clause]
                                                (for [expr (emit-cond-clause clause)
                                                      constraint (get-constraint (.c-var expr))]
                                                  [constraint expr])))
                         _ (sm/assoc-in-val [.fn-context .subs] final-subs)
                         exprs (sm/traverse expr-cs
                                            (fn [[c expr]]
                                              (map (constrain-var file-name line-number (.c-var expr) c)
                                                   (fn [_]
                                                     expr))))
                         :let [result-c (-> expr-cs
                                            (map (fn [[c]]
                                                   (c/extract-contents-constraint c)))
                                            (conj (either (map (get final-subs (.c-var expr))
                                                               c/extract-contents-constraint)
                                                          c/top-type))
                                            c/sum-type
                                            assert-maybe-of
                                            (c/update-path file-name line-number))]
                         _ (constrain-var file-name line-number result-var result-c)
                         free-parent (cond (= tail-return "")
                                           (sm/state-maybe "")

                                           (free-closure-parent))]
                     (let [tail-return [free-parent line-sep tail-return]
                           exprs (comp [expr]
                                       (map expr-cs (fn [[_ expr]] expr)))
                           refs-map (clause-refs exprs result-var)]
                       (c-init result-var
                               ["Value *" result-var ";" line-sep
                                (-> exprs
                                    (clause-inits "if (!isNothing(" refs-map result-var)
                                    (interpose [tail-return "} else {" line-sep
                                                "dec_and_free(" result-var ", 1);" line-sep]))
                                (-> (count exprs)
                                    dec
                                    (repeat (str "}" line-sep)))]
                               refs-map file-name line-number)))))
            (wrap sm/zero-sm empty-c-code))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ")
          (flat-map (vec clauses) string-list)
          (list ">")))

  Container
  (map [x f]
    (TailOr (map clauses f)))

  (map [x f embed]
    (map (map clauses f embed) TailOr))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "orRslt")
            _ (constrain-var file-name line-number "#result" maybe-constraint)
            check-fn (global-var 'checker)
            ;; TODO: test closure with tail or expr
            expr (emit-or-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode))
                               (str "return(" check-fn "(" result-var "));" line-sep))
            result-const (get-constraint "#result")
            expr-const (get-constraint (.c-var expr))
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr))))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-or-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode)) ""))))

  (wrap-tail [ast params]
    (-> (.clauses ast)
        ;; TODO: move this filtering to the Vector wrap-tail
        (filter ast/generates-code?)
        (tail-call params)
        TailOr
        Left)))

(deftype TailEither [clause alt]

  Stringable
  (string-list [expr]
    (list "(TailEither " (str clause) "\n" (str alt) ")"))

  Container
  (map [x f]
    (TailEither (f clause) (f alt)))

  (map [x f embed]
    (for [new-clause (f clause)
          new-alt (f alt)]
      (TailEither new-clause new-alt)))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      ;; TODO: this is so fantastically wrong.
      ;; How does the alt result-var get constrained?
      (for [cond-val (emit-cond-clause clause)
            alt-val (emit alt)
            result-var (genlocal "tailEither_rslt")
            result-const (get-constraint "#result")
            cond-constraint (get-constraint (.c-var cond-val))
            alt-constraint (get-constraint (.c-var alt-val))
            :let [expr-const (-> (c/sum-type [(c/extract-contents-constraint cond-constraint)
                                              alt-constraint])
                                 (c/update-path file-name line-number))]
            _ (constrain-var file-name line-number result-var expr-const)
            _ (set-result-constraint result-var file-name line-number)
            free-parent (free-closure-parent)
            checked-var (genlocal 'checked)]
        (let [cond-rslt (.c-var cond-val)
              refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
          (c-code result-var
                  [(.init cond-val)
                   "Value *" result-var ";" line-sep
                   "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                   result-var " = maybeExtract(" cond-rslt ");" line-sep
                   (map (vec (.refs-map alt-val))
                        (fn [[c-sym remaining]]
                          (either (and (= 0 remaining)
                                       (maybe ""))
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                   (let [rt-check (runtime-check (c/update-var result-const result-var)
                                                 expr-const file-name line-number checked-var)]
                     (either (empty? rt-check)
                             ["int " checked-var " = 1;" line-sep
                              rt-check
                              line-sep "if(!" checked-var "){abort();}" line-sep]))
                   free-parent
                   "return(" result-var ");" line-sep
                   "} else {" line-sep
                   "dec_and_free(" cond-rslt ", 1);" line-sep
                   (.init alt-val)
                   (either (= "" (.c-var alt-val))
                           [result-var " = " (.c-var alt-val) ";" line-sep])
                   "}" line-sep]
                  refs-map
                  c/top-type))))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "eitherRslt")
            cond-val (emit-cond-clause (.clause ast))
            syms get-syms
            alt-val (emit (.alt ast))
            _ (set-syms syms)
            cond-constraint (get-constraint (.c-var cond-val))
            alt-constraint (get-constraint (.c-var alt-val))
            _ (constrain-var file-name line-number result-var
                             (c/sum-type [(c/extract-contents-constraint cond-constraint)
                                          alt-constraint]))]
        (let [cond-rslt (.c-var cond-val)
              refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                           (filter-vals (partial < 0)))]
          (c-init result-var
                  [(.init cond-val)
                   "Value *" result-var ";" line-sep
                   "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                   result-var " = maybeExtract(" cond-rslt ");" line-sep
                   (map (vec (.refs-map alt-val))
                        (fn [[c-sym remaining]]
                          (either (and (= 0 remaining)
                                       (maybe ""))
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                   "} else {" line-sep
                   "dec_and_free(" cond-rslt ", 1);" line-sep
                   (.init alt-val)
                   result-var " = " (.c-var alt-val) ";" line-sep
                   "}" line-sep]
                  refs-map file-name line-number)))))

  ;; TODO:  add back later
  ;; (emit-defined-value [ast defined-sym]
  ;;   (for [value (emit ast)
  ;;         _ (new-module-def defined-sym value)]
  ;;     [value]))

  (wrap-tail [ast params]
    (Left (TailEither (.clause ast)
                      (tail-call (.alt ast) params)))))

(extend-type ast/cond-val-ast
  EmitCond
  (emit-cond-clause [ast]
    (let [file-name (ast/file-name (.value ast))
          line-number (ast/line-number (.value ast))]
      (for [init-subs (get-subs)
            cond-val (emit-cond-clause (.conditional ast))
            syms get-syms
            final-subs (get-subs)
            value (emit (.value ast))
            value-c (get-constraint (.c-var value))
            final-final-subs (get-subs)
            _ (sm/assoc-in-val [.fn-context .subs] final-subs)
            _ (set-syms syms)
            result-var (genlocal "cvRslt")
            _ (constrain-var file-name line-number result-var value-c)
            do-value (genlocal "doValue")
            :let [refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map value))
                               (filter-vals (partial < 0)))]
            rt-checks (-> (.refs-map cond-val)
                          keys
                          (conditional-rt-checks final-subs init-subs
                                                 (ast/file-name (.conditional ast))
                                                 (ast/line-number (.conditional ast))))
            value-rt-checks (-> (.refs-map value)
                                (dissoc (.c-var value))
                                keys
                                (conditional-rt-checks final-final-subs final-subs
                                                       (ast/file-name (.value ast))
                                                       (ast/line-number (.value ast))))]
        (c-init result-var
                [rt-checks
                 (.init cond-val)
                 "Value *" result-var " = " (.c-var cond-val) ";" line-sep
                 "int " do-value " = !isNothing(" result-var ",\"\",0);" line-sep
                 "if (" do-value ") {" line-sep
                 "dec_and_free(" result-var ", 1);" line-sep
                 value-rt-checks
                 (.init value)
                 result-var " = " (.c-var value) ";" line-sep
                 "} else {" line-sep
                 (map (vec (.refs-map value)) (fn [[c-sym remaining]]
                                                (either (and (= 0 remaining)
                                                             (maybe ""))
                                                        ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "}" line-sep "if (" do-value ") {" line-sep]
                refs-map file-name line-number)))))

(defn emit-cond-expr [ast result-var tail-return]
    (let [[clause & clauses] (.conditionals ast)
          file-name (ast/file-name clause)
          line-number (ast/line-number clause)]
      (for [initial-subs (get-subs)
            expr (emit-cond-clause clause)
            first-const (get-constraint (.c-var expr))
            expr-cs (sm/traverse clauses
                                 (fn [clause]
                                   (for [_ (sm/assoc-in-val [.fn-context .subs] initial-subs)
                                         expr (emit-cond-clause clause)
                                         constraint (get-constraint (.c-var expr))]
                                     [constraint expr])))
            clauses-subs (get-subs)
            _ (sm/assoc-in-val [.fn-context .subs] initial-subs)
            default-expr (emit (.default ast))
            default-subs (get-subs)
            def-const (get-constraint (.c-var default-expr))
            default-rt-checks (-> (.refs-map default-expr)
                                  (dissoc (.c-var default-expr))
                                  keys
                                  (conditional-rt-checks default-subs clauses-subs
                                                         (ast/file-name (.default ast))
                                                         (ast/line-number (.default ast))))
            _ (sm/assoc-in-val [.fn-context .subs] initial-subs)
            :let [default-expr (.init default-expr
                                      [default-rt-checks
                                       (.init default-expr)])
                  exprs (comp [expr]
                              (map expr-cs (fn [[_ expr]] expr))
                              [default-expr])
                  result-c (-> expr-cs
                               vec
                               (map (fn [[c]] c))
                               (comp [def-const first-const])
                               c/sum-type
                               (c/update-path file-name line-number))]
            _ (constrain-var file-name line-number result-var result-c)
            free-parent (cond (= "" tail-return)
                              (sm/state-maybe "")

                              (free-closure-parent))]
        (let [refs-map (clause-refs exprs result-var)
              [exprs] (reduce (rest exprs) [[expr ] (.c-var expr)]
                              (fn [[exprs prev-var] expr]
                                [(conj exprs (.init expr ["dec_and_free(" prev-var ", 1);" line-sep
                                                          (.init expr)]))
                                 (.c-var expr)]))]
          (c-init result-var
                  ["Value *" result-var ";" line-sep
                   (-> exprs
                       (clause-inits "" refs-map result-var)
                       (interpose [free-parent line-sep tail-return "} else {" line-sep]))
                   (-> (count exprs)
                       dec
                       (repeat (str "}" line-sep)))]
                  refs-map file-name line-number)))))

(deftype TailCond [conditionals default]
  Stringable
  (string-list [_]
    (list "(TailCond " (str conditionals) " " (str default) ")"))

  Container
  (map [x f]
    (TailCond (map conditionals f) (f default)))

  (map [x f embed]
    (for [new-conds (map conditionals f embed)
          new-default (f default)]
      (TailCond new-conds new-default)))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name conditionals))

  (ast/line-number [_]
    (ast/line-number conditionals))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "condRslt")
            check-fn (global-var 'checker)
            expr (emit-cond-expr ast result-var
                                 (str "return(" check-fn "(" result-var "));" line-sep))
            result-const (get-constraint "#result")
            expr-const (get-constraint (.c-var expr))
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr))))

(extend-type ast/cond-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "condRslt")
              (fn [result-var]
                (emit-cond-expr ast result-var ""))))

  (wrap-tail [ast params]
    (Left (TailCond (.conditionals ast)
                    (tail-call (.default ast) params)))))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [
          ;; _ (debug "=======\n*** " 'main-fn)
          ;; TODO: add param assertions
          fn-arity (emit-fn-arity (ast/tag 'main) "" (.params ast) (.body ast))
          fn-arity (cond (instance? StaticArity fn-arity)
                         (-> fn-arity
                             .var-info
                             .init
                             declare
                             (map (fn [_]
                                    (.var-info fn-arity (.init (.var-info fn-arity) [])))))

                         (sm/state-maybe fn-arity))
          ;; _ (debug "======= done main")
          _ (sm/assoc-in-val [.module .values 'main] fn-arity)]
      [empty-c-code])))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        :let [arity-count (count arities)
              fn-constraint (c/update-path fn-constraint
                                           (ast/file-name fn-sym) (ast/line-number fn-sym))]
        _ (constrain-var (ast/file-name fn-sym) (ast/line-number fn-sym)
                         fn-var fn-constraint)
        _ (declare ["Value *" fn-var ";\n"])
        _ (sm/traverse arities (fn [arity]
                                 (-> arity .var-info .init declare)))
        _ (declare ["Function " struct-var " = {FunctionType, -2, \""
                    fn-sym "\", " arity-count ", "
                    "{"   (-> arities
                              (map (fn [arity]
                                     (-> arity .var-info .c-var)))
                              (interpose ", ")
                              (to-str))
                    "}};\n"
                    "Value *" fn-var " = (Value *)&" struct-var ";\n\n"])]
    (let [arities (map arities (fn [arity]
                                 (.var-info arity (.init (.var-info arity) []))))]
      (cond
       (= fn-sym 'list)
       (c-list-fn fn-var [] {} struct-var)

       (= fn-sym 'maybe)
       (c-maybe-fn fn-var [] {} struct-var)

       (= fn-sym 'vector)
       (c-vector-fn fn-var [] {} struct-var)

       (c-static-fn fn-var [] {} struct-var
                    (reduce arities {}
                            (fn [m arity]
                              (assoc m (.param-count arity) arity))))))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities (partial instance? ClosureArity)))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "// creating " fn-sym))
        _ (declare (-> arities
                       (filter (partial instance? StaticArity))
                       (map (fn [arity]
                              (-> arity
                                  .var-info
                                  .init)))))]
    (let [emitted-arities (map arities (fn [arity]
                                         (either (map (instance? StaticArity arity)
                                                      (fn [arity]
                                                        (-> arity
                                                            .var-info
                                                            (.init []))))
                                                 (.var-info arity))))
          arity-count (count arities)]
      (c-closure-fn (str fn-var)
                    [(map emitted-arities .init)
                     line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
                     "Value *" fn-var " = (Value *)" struct-var ";" line-sep
                     struct-var "->name = \"" fn-sym "\";" line-sep
                     struct-var "->arityCount = " arity-count ";" line-sep
                     (map (zip-lists (map emitted-arities .c-var)
                                     (range arity-count))
                          (fn [[sym index]]
                            [sym "->parent = " fn-var ";" line-sep
                             struct-var "->arities[" index "] = " sym ";" line-sep]))]
                    (apply merge-with (list* + (map emitted-arities .refs-map)))
                    (reduce arities {}
                            (fn [m arity]
                              (assoc m (.param-count arity) arity)))
                    (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn call-universal-proto-fn [fn-sym disp-arg args]
  (let [args (cons disp-arg args)]
    ["Value *protoRslt;\n"
     "if (universalProtoFn != 0){\n"
     "  List *args = empty_list;\n"
     (to-str (flat-map (reverse args)
                       (fn [arg]
                         (list "  args = listCons(" "(Value *)" arg ", args);\n"))))
     "  args = listCons(symbol(stringValue(\"" fn-sym "\")), args);\n"
     "  args = listCons(stringValue(\"" (ast/file-name fn-sym) "\"), args);\n"
     "  protoRslt = fnApply(universalProtoFn, (Value *)args);\n"
     "  if (protoRslt->type == MaybeType && !isNothing(protoRslt,\"\",0)) {\n"
     "    Value *result = ((Maybe *)protoRslt)->value;\n"
     "    incRef(result, 1);\n"
     "    dec_and_free(protoRslt, 1);\n"
     "    dec_and_free(" disp-arg ", 1);\n"
     "    return(result);\n"
     "}\n} else {\n"
     (flat-map args (fn [arg]
                      (list
                       "  dec_and_free(" arg ", 1);\n")))
     "protoRslt = nothing;}\n"]))

(deftype InsertCode [fn-sym prototype]
  Stringable
  (string-list [_]
    (list "<InsertCode>"))

  Container
  (map [x f]
    (InsertCode fn-sym (f prototype)))

  (map [x f]
    (map (f prototype)
         (partial InsertCode fn-sym)))

  Emitter
  (emit [_]
    (let [num-args (-> prototype .params .fixed count)
          [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                            (range num-args))
                                 (fn [[arg idx]]
                                   (check-C-var (str arg "_" idx) (str "arg" idx))))]
      (sm/state-maybe (c-code "protoRslt"
                              [(call-universal-proto-fn fn-sym disp-arg args)]
                              (reduce args {disp-arg 1}
                                      (fn [m arg]
                                        (assoc m arg 1)))
                              c/top-type)))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (let [num-args (-> prototype .params .fixed count)
        [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                          (range num-args))
                               (fn [[arg idx]]
                                 (check-C-var (str arg "_" idx) (str "arg" idx))))]
    (comp (filter (.default-body prototype) (partial instance? c/Constraints))
          [(c-code ""
                   ["incRef(" disp-arg ", 1);"
                    ;; TODO: maybe use 'InsertCode' instead
                    (call-universal-proto-fn fn-sym disp-arg args)
                    (line-marker (ast/file-name fn-sym) (ast/line-number fn-sym) "")
                    "if (arity != (FnArity *)0) {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments %s\\n\", "
                    "((String *)type_name((FnArity *)0, " disp-arg "))->buffer, " num-args
                    ", ((String *)arity)->buffer);abort();"
                    "} else {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments.\\n\", "
                    "((String *)type_name((FnArity *)0, " disp-arg "))->buffer, " num-args ");abort();"
                    "}"]
                   (reduce args {disp-arg 1}
                           (fn [m arg]
                             (assoc m arg 1)))
                   c/top-type)])))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [default-body (missing-impl-body protocol-sym fn-sym prototype)
        default-constraints (filter (.default-body prototype)
                                    (partial instance? c/Constraints))
        body (remove (.default-body prototype) (partial instance? ast/NoCode))
        arity-ast (ast/fn-arity (.params prototype) ""
                                (cond (empty? body)
                                      default-body
                                      body))
        params (.params prototype)
        default-fn-sym (str "Default_" fn-sym)]
    (for [arity-impl-var (map (global-var default-fn-sym "arityImpl")
                              ProtoDispFnPtr)
          fn-context (reset-fn-context)

          ;; create vars for all the parameters
          p-bindings (bind-param params)

          ;; clear any constraints for the parameter vars
          _ (-> p-bindings
                (map .bound)
                (sm/traverse (fn [var]
                               (set-constraint var c/top-type))))

          ;; constrain those vars with the given assertions
          _ (sm/traverse default-constraints emit)

          ;; save the constraints specified for the parameters
          pcs (get-param-constraints params)
          _ (reset-fn-context fn-context)

          ;; compute the given result constraints
          result-constraint (-> (.default-body prototype)
                                (filter (partial instance? c/ResultConstraint))
                                (map .assertion)
                                (sm/traverse lookup-constraint)
                                (map (fn [result-constraints]
                                       (reduce result-constraints c/top-type c/intersect))))

          ;; emit the default proto function
          static-arity (emit-fn-arity (symbol default-fn-sym) disp-fn-var params
                                      (comp default-constraints
                                            (cond (empty? body)
                                                  default-body
                                                  [(ast/either-ast
                                                    (InsertCode fn-sym prototype)
                                                    (ast/let-ast [] body))]))
                                      arity-impl-var)
          static-arity (cond (instance? StaticArity static-arity)
                             (-> static-arity
                                 .var-info
                                 .init
                                 declare
                                 (map (fn [_]
                                        (.var-info static-arity (.init (.var-info static-arity) [])))))

                             (compilation-error "Compiler error! Default proto impl must be a static arity."))

          :let [param-count (.param-count static-arity)
                default-impl (ProtoImpl 0 (.c-var (.var-info static-arity)) arity-ast
                                        pcs result-constraint arity-impl-var)]

          _ (sm/update-in-val [.module .values fn-sym .arities param-count]
                              (fn [static-arity]
                                (assert (instance? StaticArity static-arity))
                                (-> static-arity
                                    (.result-constraint result-constraint)
                                    (.param-constraints pcs))))

          ;; this is the info used to emit the implementations
          _ (comp (sm/update-in-val [.module .protocols
                                     (ast/untag protocol-sym) (ast/untag fn-sym)]
                                    (fn [p-disp]
                                      (assert (instance? ProtoDispatcher p-disp))
                                      (assoc-in p-disp [.p-impls param-count 0]
                                                default-impl)))
                  (sm/assoc-in-val [.module .protocols
                                    (ast/untag protocol-sym) (ast/untag fn-sym)]
                                   (ProtoDispatcher (ast/untag fn-sym)
                                                       (cond (= 'core (ast/file-name protocol-sym))
                                                             ""
                                                             (ast/file-name protocol-sym))
                                                       {param-count {0 default-impl}})))]
      static-arity)))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [_ (emit (ast/quoted-ast proto-sym))
        _ (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        _ (new-module-def fn-sym (c-protocol-fn fn-var [] {} "" proto-sym {}))
        arities-info (sm/traverse arities
                                  (fn [arity]
                                    (let [params (.params arity)
                                          arg-count (count params)
                                          param-cs (-> c/empty-items-constraint
                                                       (.items-constraints (repeat arg-count c/top-type)))]
                                      (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                            _ (sm/assoc-in-val [.module .values
                                                                fn-sym .arities arg-count]
                                                               ;; TODO: removing the ProtoDispFnPtr causes a
                                                               ;; useless error message because of inlining
                                                               (StaticArity fn-var (ProtoDispFnPtr c-fn)
                                                                            params arg-count
                                                                            ;; TODO: what should be here? Is it used?
                                                                            empty-c-code
                                                                            param-cs
                                                                            c/top-type))]
                                        ["Value *" c-fn "("
                                         (-> (map (range arg-count) (partial str "Value *arg"))
                                             (conj "FnArity *arity")
                                             (interpose ", "))
                                         ");\n"]))))
        _ (declare ["\n// proto fn for " proto-sym "/" fn-sym "\n"
                    "\n// --------- " fn-sym " -------------\n"
                    "Value *" fn-var ";\n"
                    arities-info])]
    []))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototypes (-> (.prototypes ast)
                         (reduce {}
                                 (fn [m prototype]
                                   (either (update m (.fn-name prototype)
                                                   (fn [prototypes]
                                                     (conj prototypes prototype)))
                                           (assoc m (.fn-name prototype) [prototype]))))
                         (vec))]
      (for [_ (comp (flat-map (lookup-protocol proto-name)
                              (fn [_]
                                (compilation-error "Duplicate protocol"
                                                   (str "'" proto-name "'") "at"
                                                   (str (ast/file-name proto-name) ":")
                                                   (ast/line-number proto-name))))
                    sm-nop)
            _ (sm/traverse prototypes
                           (partial create-dispatcher proto-name))
            _ (sm/traverse prototypes
                           (fn [[fn-sym arities]]
                             (flat-map (map (lookup-sym fn-sym) .c-var)
                                       (fn [fn-var]
                                         (sm/traverse arities (partial emit-proto-default proto-name
                                                                       fn-sym fn-var))))))]
        [empty-c-code]))))

(extend-type ast/fn-arity-ast
  Emitter
  (update-syms [ast _]
    (for [_ (sm/update-state (fn [subs-list]
                               (either (map (first subs-list)
                                            (fn [head]
                                              (cons head subs-list)))
                                       (list {}))))]
      (Right ast)))

  (pop-subs [ast]
    (map (sm/update-state rest)
         (fn [_]
           ast)))

  (emit [ast]
    ;; TODO: doesn't look like the arity's ast gets saved
    (emit-fn-arity (cond (= "" (.fn-sym ast))
                         'anon
                         (.fn-sym ast))
                   (str (.fn-var ast)) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (let [file-name (ast/file-name arg-asts)
          line-number (ast/line-number arg-asts)
          fixed-args (take arg-asts (count (.fixed (.params ast))))
          new-bindings (make-bindings (.fixed (.params ast)) fixed-args)
          new-bindings (either (map (.variadic (.params ast))
                                    (fn [var-args]
                                      (conj new-bindings
                                            (ast/binding-ast
                                             var-args
                                             (ast/call-ast list-sym
                                                           (-> arg-asts
                                                               (drop (count (.fixed (.params ast))))
                                                               vec))))))
                               new-bindings)
          ;; TODO: put this back in later, we're tryint to tag all the symbols in the arity for
          ;; better error messages
          ;; tagged-bindings (reduce (all-symbols new-bindings) {}
          ;;                         (fn [m sym]
          ;;                           (either (instance? Tagged sym)
          ;;                                   (print-err 'boom new-bindings))

          ;;                           (assoc m
          ;;                             (ast/untag sym) (ast/tag sym file-name line-number))))
          ;; inlined-expr (replace-syms (ast/let-ast new-bindings
          ;;                                         (remove (.body ast) (partial instance? c/ResultConstraint)))
          ;;                            tagged-bindings)
          inlined-expr (ast/let-ast new-bindings
                                    (remove (.body ast) (partial instance? c/ResultConstraint)))
          result-constraint (-> (.body ast)
                                (filter (partial instance? c/ResultConstraint))
                                (map .assertion)
                                (reduce c/top-type c/intersect))]
      (cond (= c/top-type result-constraint)
            (sm/state-maybe inlined-expr)

            (sm/state-maybe (ConstrainedAST inlined-expr result-constraint))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (either (map (.fn-sym ast)
                   (fn [fn-sym]
                     (for [;; _ (debug "=========")
                           ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                           fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                                        (global-var fn-sym "fn"))
                           _ (declare ["\n// --------- " fn-sym " -------------\n"])
                           _ (constrain-var file-name line-number fn-var fn-constraint)
                           arities (sm/traverse (map (.arities ast) (fn [arity]
                                                                      (-> arity
                                                                          (.fn-sym fn-sym)
                                                                          (.fn-var fn-var))))
                                                emit)
                           fn-expr (comp (closure-fn fn-sym fn-var arities)
                                         (static-fn fn-sym fn-var arities))
                           ;; _ (debug "---------")
                           ]
                       fn-expr)))
              (let [fn-sym (symbol (str "anonymous function at " (ast/file-name ast) ": " (ast/line-number ast)))]
                (for [fn-var (global-var "fn")
                      ;; _ (declare ["Value *" fn-var ";\n"])
                      _ (constrain-var file-name line-number fn-var fn-constraint)
                      arities (sm/traverse (.arities ast) emit)
                      fn-expr (comp (closure-fn fn-sym fn-var arities)
                                    (static-fn fn-sym fn-var arities))]
                  fn-expr)))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (wrap-tail [x params]
    (Left (TailCall x params)))

  (inline-expr [ast arg-asts]
    (either (or (map (.fn-sym ast) (fn [_]
                                     sm/zero-sm))
                (map (-> (.arities ast)
                         (filter (fn [arity]
                                   (= (count arg-asts) (count (.params arity)))))
                         first)
                     (fn [arity]
                       (inline-expr arity arg-asts))))
            sm/zero-sm)))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [constraint (lookup-constraint (c/TypeConstraint {} empty-list type-sym nothing ""))
                  fns (flat-map (get-type-sym-info type-sym)
                                (fn [constraint]
                                  (-> (either (c/extract-type-map constraint)
                                              {})
                                      keys
                                      (sm/traverse (partial extend-type* ast constraint))
                                      (map flatten))))]
              fns)
            (compilation-error "Could not extend type: "
                               (str "'" type-sym "'") "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn create-constructor [new-type-name type-num new-type-constraint fields assertions]
  (assert (instance? ast/tagged-symbol new-type-name))
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? (vector-of Symbol) fields))
  (assert (instance? c/ItemsConstraint assertions))

  (let [file-name (ast/file-name new-type-name)
        line-number (ast/line-number new-type-name)
        x* (ast/tag "#x" file-name line-number)
        y* (ast/tag "#y" file-name line-number)
        field-count (count fields)
        args (map (range field-count)
                  (fn [n]
                    (ast/tag (str "arg" n))))
        args-map (reduce (zip-lists fields args) {}
                         (fn [m [k v]]
                           (cond (= k v)
                                 m
                                 (assoc m k v))))
        assertions (replace-syms assertions args-map)
        reified-type-num (extract type-counter)]
    (ast/reified (maybe reified-type-num)
                 {(ast/tag Eq-sym file-name line-number)
                  {(ast/tag =*-sym file-name line-number)
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_EQ_QMARK_") file-name line-number)
                     (ast/params [x* y*]) ""
                     [(ast/and-ast
                       [(ast/call-ast =*-sym
                                      [type-num
                                       (ast/call-ast get-type-sym [y*])])
                        (ast/call-ast maybe-sym [y*])])])]}

                  (ast/tag Type-sym file-name line-number)
                  {type-name-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_const_type_name") file-name line-number)
                     (ast/params [(ast/tag '_)]) ""
                     [(str "* " new-type-name " constructor at " file-name ": " line-number " *")])]

                   type-mapping-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_const_type_map") file-name line-number)
                     (ast/params [(ast/tag '_)]) ""
                     [(map-vals (.type-maps new-type-constraint)
                                (fn [field-set]
                                  (map field-set ast/quoted-ast)))])]

                   instance?-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_instance_QMARK_") file-name line-number)
                     (ast/params [x* y*]) ""
                     [(-> maybe-constraint
                          (c/intersect (c/InferredInner new-type-constraint empty-list nothing ""))
                          c/ResultConstraint)
                      (ast/and-ast
                       [(ast/call-ast =*-sym
                                      [type-num
                                       (ast/call-ast get-type-sym [y*])])
                        (ast/call-ast maybe-sym [y*])])])]}

                  (ast/tag Function-sym file-name line-number)
                  {invoke-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_invoke") file-name line-number)
                     (ast/params (comp [(ast/tag '_)] args)) ""
                     (comp [(c/ResultConstraint (-> (c/DynamicFields empty-list nothing "")
                                                    (c/update-sym (symbol "#result"))))]
                           (-> assertions 
                               (c/extract-items-constraints (count fields))
                               (remove (partial = c/top-type)))
                           [(c/update-var new-type-constraint "#result")
                            (ast/inline-ast (ast/tag 'C)
                                            new-type-constraint
                                            (str "ReifiedVal *rv = malloc_reified("
                                                 field-count ");\n"
                                                 "#ifdef SINGLE_THREADED\n"
                                                 "rv->refs = refsInit;\n#else\n"
                                                 " __atomic_store(&rv->refs,"
                                                 " &refsInit, __ATOMIC_RELAXED);\n"
                                                 "#endif\n"
                                                 "rv->type = " type-num ";\n"
                                                 (to-str (map (range field-count)
                                                              (fn [idx]
                                                                (str "rv->impls[" idx "] = arg" idx
                                                                     "_" (inc idx) ";\n"))))
                                                 "return((Value *)rv);\n")
                                            "" 0)]))]}

                  (ast/tag Container-sym file-name line-number)
                  {apply-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_apply_ST_") file-name line-number)
                     (ast/params [(ast/tag '_) (ast/tag 'fields)]) ""
                     [(-> assertions
                          (c/intersect seq-constraint)
                          (c/update-path file-name line-number)
                          (c/update-var "fields_1"))

                      (ast/inline-ast (ast/tag 'C)
                                      new-type-constraint
                                      (str "return(newTypeValue(" type-num ", (Vector *)fields_1));")
                                      "" 0)])]}

                  (ast/tag Stringable-sym file-name line-number)
                  {string-list-sym
                   [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                  [(ast/call-ast list-sym
                                                 ["<ValueConstructor " (str new-type-name) " ["
                                                  (to-str (interpose fields ", "))
                                                  "]>"])])]}})))

(defn emit-constructor [new-type-name type-num new-type-constraint fields assertions]
  (assert (instance? ast/tagged-symbol new-type-name))
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? (vector-of Symbol) fields))
  (assert (instance? c/ItemsConstraint assertions))

  (for [value (init-at-runtime (create-constructor new-type-name type-num
                                                   new-type-constraint fields assertions)
                               new-type-name)
        _ (new-module-def new-type-name (c-constructor (.c-var value) [] {}
                                                       (.constraints value)
                                                       (.c-struct value)
                                                       type-num fields))]
    [value]))

(defn default-type-impls [type-sym type-num fields]
  (let [x* (ast/tag "#x")
        y* (ast/tag "#y")
        file-name (ast/file-name type-sym)
        line-number (ast/line-number type-sym)
        field* (ast/tag "#field")
        ctxt* (ast/tag "#ctxt")]
    {Type-sym
     {type-name-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_type_name") file-name line-number)
        (ast/params [x*]) ""
        [(ast/string-ast (str type-sym) file-name line-number)])]

      has-field-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_has_field") file-name line-number)
        (ast/params [x* field*]) ""
        [(ast/or-ast
          (conj (map fields
                     (fn [field]
                       (ast/call-ast identical-sym
                                     [(ast/tag (str "." field))
                                      field*])))
                nothing-sym))])]}

     Eq-sym
     {=*-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_EQ_STAR_") file-name line-number)
        (ast/params [x* y*]) ""
        [(ast/and-ast
          [(ast/call-ast
            =*-sym [(ast/call-ast get-type-sym [x*])
                    (ast/call-ast get-type-sym [y*])])
           (ast/call-ast
            =*-sym [(ast/call-ast default-type-args-sym [x*])
                    (ast/call-ast default-type-args-sym [y*])])
           (ast/call-ast maybe-sym [x*])])])]}

     Associative-sym
     {get-symb
      [(ast/fn-arity
        (ast/tag (str type-sym "_get") file-name line-number)
        (ast/params [x* field*]) ""
        [ ;; (c-code "" ["// TODO: this seems to do runtime checks for 'has-field' result\n// and the result returned\n"]
         ;;         {} c/top-type)
         (ast/and-ast
          [(ast/call-ast has-field-sym [x* field*])
           (ast/call-ast maybe-sym
                         [(ast/call-ast field* [x*])])])])]

      assoc-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_assoc_") file-name line-number)
        (ast/params [x* field* (ast/tag 'new-value)]) ""
        [(ast/cond-ast
          [(ast/cond-val-ast (ast/call-ast has-field-sym [x* field*])
                             (ast/call-ast field* [x* 'new-value]))]
          x*)])]}

     Hashable-sym
     {sha1-update-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_sha1_update") file-name line-number)
        (ast/params [x* ctxt*]) ""
        [(ast/call-ast sha1-update-type-sym [x* ctxt*])
         (ast/call-ast
          sha1-update-sym
          [(ast/call-ast default-type-args-sym [x*]) ctxt*])])]

      sha1-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_sha1") file-name line-number)
        (ast/params [x*]) ""
        [(ast/call-ast
          sha1-finalize-sym
          [(ast/call-ast
            sha1-update-sym
            [x* (ast/call-ast sha1-init-sym [])])])])]}}))

(defn declare-getter [getter-sym]
  (let [tagged-getter (ast/tag getter-sym)
        arities [(ast/prototype tagged-getter
                                (ast/params [(ast/tag "#x")])
                                (ast/block-comment "" 0 [])
                                [(c/FieldConstraint getter-sym "" empty-list (maybe (symbol "#x")) "")])
                 (ast/prototype tagged-getter
                                (ast/params [(ast/tag "#x") (ast/tag "#y")])
                                (ast/block-comment "" 0 [])
                                [(c/FieldConstraint getter-sym "" empty-list (maybe (symbol "#x")) "")])]]
    (flat-map (sm/get-in-val [.module .index])
              (fn [curr-mod]
                (comp (sm/get-in-val [.module .protocols 'Type tagged-getter])
                      (for [_ (create-dispatcher Type-sym [tagged-getter arities])
                            fn-var (map (lookup-sym tagged-getter) .c-var)
                            _ (sm/traverse arities (partial emit-proto-default Type-sym
                                                            tagged-getter fn-var))]
                        '_))))))

(defn declare-getters [new-type-name fields]
  (comp (for [curr-mod (sm/get-in-val [.module .index])
              _ (cond (= 0 curr-mod)
                      (sm/traverse fields
                                   (fn [field]
                                     (declare-getter (symbol (str "." field)))))
                      (let [prom (promise)]
                        (map (get (extract modules) 'core)
                             (fn [ast-emitter]
                               (send ast-emitter
                                     (fn [ctxt]
                                       (update-context
                                        ctxt
                                        (map (sm/traverse
                                              fields
                                              (fn [field]
                                                (let [getter-sym (symbol (str "." field))]
                                                  (for [_ (declare-getter getter-sym)
                                                        _ (map (sm/get-in-val [.fn-context .decl]) write-strings)
                                                        _ (sm/assoc-in-val [.fn-context .decl] [])
                                                        proto (sm/get-in-val [.module .protocols 'Type getter-sym])
                                                        disp (lookup-sym (ast/tag getter-sym))]
                                                    (send core-agent
                                                          (fn [mod]
                                                            (either (and (get-in mod [.values (ast/tag getter-sym)])
                                                                         (maybe mod))
                                                                    (-> mod
                                                                        (assoc-in [.values (ast/tag getter-sym)]
                                                                                  disp)
                                                                        (assoc-in [.protocols 'Type getter-sym]
                                                                                  proto)))))))))
                                             (partial deliver prom)))))))
                        (sm/state-maybe (extract prom))))]
          '_)))

(defn create-getters [sym fields field-constraints]
  (let [type-value (ast/tag "#value")
        field-arg (ast/tag "#field")
        file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [field-constraint (c/update-path field-constraint
                                                  (ast/file-name sym) (ast/line-number sym))]
              [(ast/tag (str "." field) file-name line-number)
               [(ast/fn-arity
                 (ast/tag (str sym "_" field) file-name line-number)
                 (ast/params [type-value field-arg]) ""
                 [(c/update-sym field-constraint (ast/untag field-arg))
                  ;; TODO: add replacing of dynamic field constraint
                  (ast/inline-ast (ast/tag 'C)
                                  (c/TypeConstraint {} empty-list sym nothing "")
                                  (str "return(updateField(value_0, field_1, "
                                       field-index "));\n")
                                  "" 0)])

                (let [field-constraint (-> field-constraint
                                           (c/intersect (c/DynamicItemConstraint 0 field-index
                                                                                 empty-list nothing ""))
                                           c/clear-sym)]
                  (ast/fn-arity
                   (ast/tag (str sym "_" field) file-name line-number)
                   (ast/params [type-value]) ""
                   [(ast/inline-ast (ast/tag 'C) field-constraint
                                    (str "
  Value *result = incRef(((ReifiedVal *)value_0)->impls[" field-index "], 1);
  dec_and_free(value_0, 1);
  return(result);
")
                                    "" 0)]))]])))}))

(defn destruct-impl-fields [type-const field-constraints ast arity]
  (assert (instance? ast/type-ast ast))
  (assert (instance? ast/fn-arity-ast arity))

  (let [[type-value-parameter] (.fixed (.params arity))
        fields (.fixed (.fields ast))
        field-count (count fields)
        body-exprs (remove (.body arity) (partial instance? c/Constraints))
        body-exprs (either (flat-map (last body-exprs)
                                     (fn [last-expr]
                                       (store body-exprs (dec (count body-exprs))
                                              (CollectFieldConsts (.fields ast) last-expr))))
                           body-exprs)
        new-body (comp (filter (.body arity) (partial instance? c/Constraints))
                       [(ConstrainVar (c/update-sym type-const (ast/untag type-value-parameter)))
                        (-> (zip-lists fields (range field-count))
                            (map (fn [[field-sym index]]
                                   (assert (instance? Integer index))

                                   (ast/binding field-sym
                                     (ast/call-ast get-field-sym
                                                   [type-value-parameter index]))))
                            vec
                            (ast/let-ast (-> (c/extract-items-constraints field-constraints)
                                             (zip-lists fields (range field-count))
                                             (map (fn [[field-c field-sym field-index]]
                                                    (ConstrainVar
                                                     (c/intersect field-c
                                                                  (c/DynamicItemConstraint
                                                                   0 field-index
                                                                   empty-list
                                                                   (maybe (ast/untag field-sym))
                                                                   (c/extract-var field-c))))))
                                             vec
                                             (comp body-exprs))))])]
    (-> arity
        (.body new-body)
        (.fn-sym (-> ast
                     .sym
                     (str "_" fn-name)
                     (ast/tag (ast/file-name ast) (ast/line-number ast)))))))

(defn destructure-fields [type-const field-constraints ast]
  (let [impls (comp* {} (-> (.impls ast)
                            (filter (partial instance? HashMap))))]
    (map-vals impls
              (fn [impl-arities]
                (map (vec impl-arities)
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields type-const field-constraints ast))]))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'TypeConstraint c/TypeConstraintType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      'MultiConstraint c/MultiConstraintType
                      'ResultConstraint c/ResultConstraintType
                      'ItemsConstraint c/ItemsConstraintType
                      'FieldConstraint c/FieldConstraintType
                      'StaticIntConstraint c/StaticIntConstraintType
                      'MinValue c/MinValueType
                      'MaxValue c/MaxValueType
                      'InferredInner c/InferredInnerType
                      'StaticLengthConstraint c/StaticLengthConstraintType
                      'StaticStrConstraint c/StaticStrConstraintType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract type-counter)))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (ast/untag (.sym ast))
          fields  (-> (.fields ast)
                      .fixed
                      (map ast/untag))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) (partial instance? c/ValueConstraint))]
      (comp (for [_ (comp (sm/get-in-val [.module .types sym])
                          (sm/when (get-in (extract core-agent) [.types sym])))
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (cond (= file-name 'core)
                                                  "$TOCCATA_DIR/core.toc"
                                                  file-name)
                                            ", " line-number))]
              "")

            (let [type-num (new-type-number sym)
                  type-map {type-num (-> fields
                                         (map (fn [name]
                                                (symbol (str "." name))))
                                         set)}
                  new-type-constraint (c/TypeConstraint type-map (list [file-name line-number])
                                                        (.sym ast) nothing "")]
              (for [_ (emit-definition (ast/declaration-ast (.sym ast)))
                    _ (sm/assoc-in-val [.module .types sym] new-type-constraint)
                    _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                    _ (declare-getters sym fields)

                    ;; TODO: this whole section is bogus
                    field-assertions (sm/traverse field-assertions lookup-constraint)
                    :let [field-map (reduce field-assertions
                                            {} (fn [m c]
                                                 (validate-field c m fields file-name line-number)))
                          field-constraints (c/ItemsConstraint
                                             (map fields (fn [field]
                                                           (either (get field-map field)
                                                                   c/top-type)))
                                             c/coll-of-any
                                             empty-list (maybe (symbol (str sym " fields"))) "")
                          impls (merge-with comp
                                            (default-type-impls sym type-num fields)
                                            (destructure-fields new-type-constraint field-constraints ast))
                          impl-arities (for [[proto-sym impl-fns] (vec impls)
                                             [fn-name arities] (vec impl-fns)
                                             impl-arity arities]
                                         [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
                    _ (sm/assoc-in-val [.fn-context .field-constrs] (maybe field-constraints))

                    impl-arities (sm/traverse impl-arities (partial declare-impl (str sym) type-num))
                    _ (sm/traverse impl-arities
                                   (partial emit-impl (str sym) new-type-constraint type-num))
                    new-field-constrs (sm/get-in-val [.fn-context .field-constrs])
                    :let [field-constraints (either (map new-field-constrs
                                                         (fn [fc]
                                                           (-> fc
                                                               (c/update-var "")
                                                               (c/update-sym (symbol (str sym " fields")))
                                                               (.items-constraints (map (.items-constraints fc)
                                                                                        (fn [c]
                                                                                          (c/update-var c "")))))))
                                                    field-constraints)

                          field-constraints (promote-inferred field-constraints)
                          getter-arities (create-getters (.sym ast) fields
                                                         (c/extract-items-constraints field-constraints))
                          getter-arities (for [[proto-sym impl-fns] (vec getter-arities)
                                               [fn-name arities] (vec impl-fns)
                                               impl-arity arities]
                                           [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]

                    getter-arities (sm/traverse getter-arities (partial declare-impl (str sym) type-num))
                    _ (sm/traverse getter-arities (partial emit-impl (str sym) new-type-constraint type-num))
                    _ (sm/assoc-in-val [.fn-context .field-constrs] nothing)

                    type-constructor (emit-constructor (.sym ast) type-num new-type-constraint
                                                       fields field-constraints)]
                type-constructor))))))

;; (defn js-callable-arity [[num-args expr]]
;;   (for [c-fn-name (global-var (str (.sym ast) "_" num-args))
;;         :let [c-fn-name (either (check-C-var c-fn-name)
;;                                 c-fn-name)
;;               js-wrapper (c-code ""
;;                                  ["\nEM_ASM(\n" (str (.sym ast)) " = function("
;;                                   (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
;;                                   "_" c-fn-name "("
;;                                   (interpose (map (range num-args)
;;                                                   (fn [idx]
;;                                                     ["sendValue(arg" idx ")"]))
;;                                              ", ")
;;                                   ");\n return; \n};);\n"]
;;                                  [] {} {})]
;;         _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
;;                                                 (conj exprs js-wrapper)))]
;;     [c-fn-name num-args]
;;     [(c-code "" []
;;              ["EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
;;               (interpose (map (range num-args) (partial str "int64_t arg")) ", ")
;;               ") {\ndec_and_free("
;;               (.c-var expr) "("
;;               (interpose (cons "empty_list"
;;                                (map (range num-args)
;;                                     (fn [idx]
;;                                       ["(Value *)arg" idx])))
;;                          ", ")
;;               "), 1);\n return; \n};\n"]
;;              {} {})]))

(extend-type ast/JS-callable
  Emitter
  (emit-definition [ast]
    (let [num-args (.num-args ast)]
      (comp (for [fn-var (lookup-sym (.sym ast))
                  expr (sm/when (get-in fn-var [.arities num-args]))
                  c-fn-name (global-var (str (.sym ast)))
                  :let [js-wrapper (c-code ""
                                           ["\n#ifdef TOCCATA_WASM\n"
                                            "EM_ASM(\n" (str (.sym ast)) " = function("
                                            (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
                                            "return _" c-fn-name "("
                                            (interpose (map (range num-args)
                                                            (fn [idx]
                                                              ["sendValue(arg" idx ")"]))
                                                       ", ")
                                            ");\n};);\n"
                                            "#endif\n"]
                                           {} c/top-type)
                        _ (send rt-exprs conj js-wrapper)]
                  _ (declare ["\n#ifdef TOCCATA_WASM\n"
                              "EMSCRIPTEN_KEEPALIVE\n Value * " c-fn-name "("
                              (interpose (map (range num-args) (partial str "int arg")) ", ")
                              ") {\nreturn("
                              (.c-fn expr) "("
                              (interpose (cons "(FnArity *)0"
                                               (map (range num-args)
                                                    (partial str "(Value *)arg")))
                                         ", ")
                              "));\n};\n"
                              "#endif\n"])]
              [empty-c-code])
            (compilation-error "Could not find function" (.sym ast) "or an arity with" num-args "arguments.")))))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  Emitter
  (get-result-constraint [expr num-args]
    (for [type-num (var-type-num (.c-var expr))
          :when-not (= c/UnknownType type-num)
          invoke-info (get-core-proto-impl Function-sym invoke-sym (inc num-args) type-num)]
      (.result-constraint invoke-info)))

  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");\n"]))

(defn declare-dispatcher [mod-index [fn-sym arities]]
  (let [arities (.p-impls arities)]
    (for [disp-fn (sm/get-in-val [.module .values (ast/tag fn-sym)])
          :let [fn-var (.c-var disp-fn)]
          c-fns (sm/traverse (vec (.arities disp-fn))
                             (fn [[arg-count static-arity]]
                               (assert (instance? StaticArity static-arity))
                               (for [arity-var (global-var "arity")]
                                 [arg-count arity-var (.c-fn static-arity)])))
          struct-var (global-var "dispFnStruct")

          _ (sm/assoc-in-val [.module .values (ast/tag fn-sym) .c-struct] struct-var)
          checked-var (genlocal 'checked)
          _ (declare [(map c-fns
                           (fn [[arg-count arity-var c-fn]]
                             ;; TODO: this should be done in the traverse above
                             (let [impls (extract (get arities arg-count))]
                               ["Value *" c-fn "(FnArity *"
                                (interpose (cons "closures" (map (range arg-count)
                                                                 (partial str "Value *arg")))
                                           ",")
                                ") {\nFnArity *arity;\n#\n"
                                "FnType" arg-count " *_fn;\n"
                                "int " checked-var "= 1;"
                                "switch (arg0->type) {\n"
                                (-> impls
                                    (dissoc 0)
                                    (vec)
                                    (map (fn [[type-num arity-info]]
                                           (assert (instance? ProtoImpl arity-info))

                                           ["case " (str type-num) ": arity = "
                                            (.c-var arity-info) ";\n_fn = (FnType"
                                            arg-count " *)" (.c-fn arity-info) ";\n"
                                            (for [[constraint var] (-> (.param-constraints arity-info)
                                                                       (c/extract-items-constraints arg-count)
                                                                       (zip-lists (map (range arg-count)
                                                                                       (partial str "arg")))
                                                                       rest)]
                                              (-> constraint
                                                  (c/update-var var)
                                                  (runtime-check c/top-type
                                                                 (str "(closures == (FnArity *)0 ? \"\" : "
                                                                      "((String *)closures)->buffer)")
                                                                 checked-var)))
                                            "\nclosures = arity;\nbreak;\n"])))
                                (let [arity-info (extract (get impls 0))]
                                  ["default:\n"
                                   (for [[constraint var] (-> (.param-constraints arity-info)
                                                              (c/extract-items-constraints arg-count)
                                                              (zip-lists (map (range arg-count)
                                                                              (partial str "arg")))
                                                              rest)]
                                     (-> constraint
                                         (c/update-var var)
                                         (runtime-check c/top-type
                                                        (str "(closures == (FnArity *)0 ? \"\" : "
                                                             "((String *)closures)->buffer)")
                                                        checked-var)))
                                   "_fn = (FnType" arg-count
                                   " *)" (.c-fn arity-info) ";\nbreak;\n"])
                                "}\n"
                                "if(!" checked-var "){abort();}" line-sep
                                ;; "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n"
                                "return(_fn(closures, " (-> (range arg-count)
                                                            (map (partial str "arg"))
                                                            (interpose ", "))
                                "));\n}\n"
                                "FnArity " arity-var " = {FnArityType, -2, "
                                arg-count
                                ", (Vector *)0, (Value *)0, 0, " c-fn ", (Value *)0, (Value *)0};\n"])))
                      "Function " struct-var " = {FunctionType, -2, \""
                      fn-sym "\", " (count c-fns) ", "
                      "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                      "}};\n"
                      "Value *" (.c-var disp-fn) " = (Value *)&" struct-var ";\n\n"])]
      '_)))

(def gather-protocols
  (comp (for [mod-index (sm/get-in-val [.module .index])
              protocols (sm/get-in-val [.module .protocols])
              ;; expr (encode-static protocols)
              x (apply (wrap sm/zero-sm list)
                       (map (for [[_ proto-fns] (vec protocols)
                                  [fn-sym arities] (vec proto-fns)]
                              [fn-sym arities])
                            (partial declare-dispatcher mod-index)))
              ;; protos-var (sm/get-in-val [.module .values protocols-sym])
              ;; r (collapse-expressions [expr
              ;;                          (c-code (.c-var protos-var)
              ;;                                  [(.c-var protos-var) " = " (.c-var expr) ";\n"]
              ;;                                  {} c/top-type)])
              ]
          ;; r
          empty-c-code
          )
        (for [path (sm/get-in-val [.module .path])
              _ (compilation-error "Could not gather the protocols for" (str "'" path "'"))]
          '_)))

(def gather-symbols
  (for [symbols (sm/get-in-val [.module .values])
        file-name (sm/get-in-val [.module .path])
        expr (-> symbols
                 (dissoc symbols-sym 'main protocols-sym)
                 (assoc 'filename (either (instance? String file-name)
                                          ""))
                 seq
                 (reduce {} (fn [m [k v]]
                              (either (and (instance? c-code v)
                                           (maybe m))
                                      (assoc m k v))))
                 (encode "symbols_"))
        sym-var (sm/get-in-val [.module .values symbols-sym])
        r (collapse-expressions [expr
                                 (c-code (.c-var sym-var)
                                         [(.c-var sym-var) " = " (.c-var expr) ";\n"]
                                         {} c/top-type)])]
    r))

(defn map-modules [operation]
  (assert (instance? sm/new-sm operation))

  (let [results-prom (promise)
        _ (send modules
                (fn [mods]
                  (deliver results-prom
                           (map (vec mods)
                                (fn [[_ ast-emitter]]
                                  (let [result-prom (promise)]
                                    (send ast-emitter
                                          (fn [ctxt]
                                            (update-context ctxt
                                                            (map (comp operation
                                                                       (sm/state-maybe ""))
                                                                 (partial deliver result-prom)))))
                                    result-prom))))
                  mods))]
    ;; TODO: this probably doesn't work
    ;; (extract (apply (promise vector)
    ;;                 (extract results-prom)))

    ;; 'results-prom' is a promise where a vector of promises will be delivered
    ;; we have to wait for all those promises to be delivered as well
    (map (extract results-prom) extract)))

(defn emit-main [main-module]
  (let [main-fn (either (get-in main-module [.values 'main])
                        (do
                          (print-err "'main' function is missing")
                          (abort)))
        wait-prom (promise)
        _ (send modules
                (fn [mods]
                  (map (get mods 'core)
                       (fn [ast-emitter]
                         (send ast-emitter
                               (fn [ctxt]
                                 (map ctxt
                                      (fn [ctxt]
                                        (.module ctxt (extract core-agent))))))
                         (send ast-emitter
                               (fn [ctxt]
                                 (map ctxt
                                      (fn [ctxt]
                                        (deliver wait-prom '_)
                                        ctxt))))))
                  mods))
        _ (extract wait-prom)
        inits (map-modules (for [proto-expr gather-protocols
                                 ;; syms-expr gather-symbols
                                 ]
                             (comp (.init proto-expr)
                                   ;; (.init syms-expr)
                                   )))
        decls (map-modules (sm/get-in-val [.fn-context .decl]))
        values-prom (promise)
        _ (send rt-exprs (partial deliver values-prom))
        values (extract values-prom)]
    (write-strings decls)
    (write-strings ["\n#\n"
                    "\nint main (int argc, char **argv) {\n"
                    "prErrSTAR = &defaultPrErrSTAR;\n"
                    "#ifdef SINGLE_THREADED\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
                    "at same time.\");\n "
                    "abort();\n"
                    "#endif\n"
                    "#endif\n"
                    "maybeNothing = maybe((FnArity *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    inits
                    (map values .init)
                    "init_module_0();\n"
                    "init_module_1();\n"
                    "\n#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-fn main-fn)
                    "((FnArity *)0, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "cleaningUp = 1;\n"
                    "mainThreadDone = 1;\n"
                    "waitForWorkers();\n"
                    (map-modules (for [expr (sm/get-in-val [.module .values symbols-sym])]
                                   (free-global (c-init (.c-var expr) [] {} "" 0))))
                    (map-modules (sm/get-in-val [.setup .cleanup]))
                    (map values free-global)
                    "\n#\n"
                    "for(List *l = argList; l != (List *)0; l = l->tail) {\n"
                    "   l->refs = 1;\n"
                    "}\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif"
                    "\n#\n"
                    "  return(0);\n};\n"
                    "\nint typeCount = " (str (extract type-counter)) ";\n"])))

(defn new-module [context module-name module-index]
  (update-context context
                  (for [_ (sm/set-val .module (Module module-name module-index {} {} {} {} {} empty-list))
                        protos-var (global-var "protos_")
                        _ (new-module-def protocols-sym (c-code protos-var [] {} c/top-type))
                        symbols-var (global-var "symbols_")
                        _ (new-module-def symbols-sym (c-code symbols-var [] {} c/top-type))
                        _ (declare ["Value *" protos-var " = (Value *)&emptyBMI;\n"
                                    "Value *" symbols-var " = (Value *)&emptyBMI;\n"])]
                    '_)))

(defprotocol TypeChecker
  (strip-constraints [ast]
    ast)

  (strip-asts [ast]
    ast)

  (check-call-site [ast args]
    (assert-result x (instance? se/new-se x)))

  (recover-type-constraint [x]
    (se/state-error x))

  (param-types [_]
    (assert-result x (instance? se/new-se x)))

  (pre-check [ast]
    (assert-result r (instance? se/new-se r))

    (flat-map (se-debug 'pre (type-name ast) "\n" ast)
              (fn [_]
                (se/state-error ast))))

  (type-check [ast old-ast]
    (assert-result r (instance? se/new-se r))))

(defn sm-translate [se-val]
  (sm/new-sm (fn [s]
               (let [se-result (se-val s)]
                 (cond (= se/Failure se-result)
                       nothing

                       (instance? se/Error se-result)
                       ((compilation-error (.val se-result))
                        (.state se-result))

                       (maybe se-result))))))

(defn se-translate [sm-val]
  (se/new-se (fn [s]
               (either (sm-val s)
                       se/Failure))))

(extend-type ConstrainedAST
  TypeChecker
  (strip-asts [ast]
    (.ast ast))

  (strip-constraints [ast]
    (.constraint ast))

  (check-call-site [ast args]
    ;; TODO: seems a little bogus
    (check-call-site (.ast ast) args)))

(deftype PrototypeImpls [fn-sym impls]
  (assert (instance? (map-of Integer HashMap) impls))

  Stringable
  (string-list [_]
    (list "(PrototypeImpls " (str fn-sym) "\n" (str impls) ")"))

  Container
  (map [x f]
    (PrototypeImpls fn-sym
                    (map-vals impls (fn [impl-fns]
                                      (map-vals impl-fns (fn [arities]
                                                           (map arities f)))))))

  (map [x f embed]
    (map (contextual-map-vals impls (fn [impl-fns]
                                      (contextual-map-vals impl-fns f embed))
                              embed)
         (partial PrototypeImpls fn-sym))))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (cata param-types params se/state-error))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (ana recover-type-constraint params se/state-error))

(defn set-type-constraint [sym constraint]
  (assert (instance? Tagged sym))
  (assert (instance? ConstrainedAST constraint))

  (se/update-in-val [.module .value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (assoc value-types (ast/untag sym) constraint)
                                           (rest types-list))))
                              (list {(ast/untag sym) constraint})))))

(defn get-type-constraint [sym]
  ;; TODO: make this work
  ;; (assert-result r (instance? (all-of se/new-se
  ;;                                     (contains ConstrainedAST))
  ;;                             r))
  (assert (instance? Tagged sym))

  (comp (se/get-in-val [.module .value-types 0 sym])
        (cond (flat-map (first (str sym))
                        (partial = "."))
              ;; TODO: getters need to be dclared in the core module
              ;; so this work needs to be sent over there
              (let [param-cs (-> c/empty-items-constraint
                                 (.items-constraints [(c/FieldConstraint (ast/untag sym) "" empty-list
                                                                         (maybe (symbol "#w")) "")])
                                 (.tail-constraint c/top-type))
                    impls (PrototypeImpls sym
                                          {c/UnknownType
                                           {1 (ast/fn-arity-ast
                                               (ast/tag sym) ""
                                               (ast/params [(ast/tag "#w")] nothing)
                                               "" [] param-cs c/top-type)
                                            2 (ast/fn-arity-ast
                                               (ast/tag sym) ""
                                               (ast/params [(ast/tag "#w") (ast/tag "#i")] nothing)
                                               "" [] param-cs c/top-type)}})
                    protocol (ast/protocol-ast (ast/tag sym)
                                               [(ast/prototype sym (ast/params [(ast/tag "#x")])
                                                               (ast/block-comment "" 0 []) [])
                                                (ast/prototype sym (ast/params [(ast/tag "#x")
                                                                                (ast/tag "#y")])
                                                               (ast/block-comment "" 0 []) [])])]
                (for [_ (set-type-constraint sym (ConstrainedAST impls fn-constraint))
                      ;; TODO: this doesn't work. The Type prtocol needs to be updated for all
                      ;; elements of the value-types list
                      ;; _ (se/assoc-in-val [.module .value-types 0 'Type (ast/untag sym)] protocol)
                      ]
                  (ConstrainedAST impls fn-constraint)))
              (-> ["Could not find type constraint for" (str "'" sym "'")
                   "at" (str (ast/file-name sym) ":") (ast/line-number sym)]
                  (interpose " ")
                  to-str
                  se/throw))))

(defn remove-type-constraint [sym]
  (assert (instance? Tagged sym))
  (se/update-in-val [.module .value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types (ast/untag sym))
                                           (rest types-list))))
                              types-list))))

(defn append-type-constraint [sym constraint]
  (assert (instance? Tagged sym))
  (assert (instance? c/Constraints constraint))

  (cond (= constraint c/top-type)
        se-nop

        (for [curr-const (se/try
                           (get-type-constraint sym)
                           (fn [_]
                             (se/state-error (ConstrainedAST sym c/top-type))))
              :let [new-const (c/trim (c/intersect (.constraint curr-const) constraint))]
              _ (cond (= new-const c/bottom-type)
                      (do
                        (c/conflicting-assertions new-const "type checker testing" _LINE_)
                        (se/throw new-const))
                      (set-type-constraint sym (.constraint curr-const new-const)))]
          new-const)))

(defn update-constraint [constrained constraint]
  (assert (instance? ConstrainedAST constrained))
  (assert (instance? c/Constraints constraint))

  ;; TODO: need to check if 'sym' satisfies 'c'
  ;; and add runtime-check notation if not
  (let [new-c (c/intersect (.constraint constrained) constraint)]
    (cond (= new-c c/bottom-type)
          (do
            (c/conflicting-assertions new-c "type checker testing" _LINE_)
            (se/throw new-c))

          (either (map (instance? Tagged (.ast constrained))
                       (fn [sym]
                         (map (append-type-constraint sym constraint)
                              (fn [_]
                                (.constraint constrained new-c)))))
                  (se/state-error (.constraint constrained new-c))))))

(defn get-types []
  (se/get-in-val [.module .value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.module .value-types])
             (fn [types-list]
               (se/assoc-in-val [.module .value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        types-list)))))
  ([value-types]
   (flat-map (se/get-in-val [.module .value-types])
             (fn [types-list]
               (se/assoc-in-val [.module .value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.module .value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.module .value-types])
            (fn [types-list]
              (se/assoc-in-val [.module .value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (rest types-list))))
                                       types-list)))))

(extend-type c/Constraints
  TypeChecker
  (pre-check [c]
    (se-translate (lookup-constraint c))))

(extend-type c/AllValues
  TypeChecker
  (type-check [c old-c]
    (se/state-error (ConstrainedAST c c))))

(extend-type c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (map (either (map (.sym old-c)
                      (fn [sym]
                        (append-type-constraint sym c)))
                 se-nop)
         (fn [_]
           (ConstrainedAST c c)))))

(extend-type c/MultiConstraint
  TypeChecker
  (type-check [c old-c]
    (-> c
        (.constraints (map (.constraints c) .ast))
        ((fn [c]
           (ConstrainedAST c c)))
        se/state-error)))

(deftype ConstrainedSum [alts path sym var]
  Stringable
  (string-list [_]
    (list "(ConstrainedSum " (str alts) ")"))

  Container
  (map [c f]
    (.alts c (map alts f)))

  (map [c f embed]
    (map (map alts f embed)
         (partial .alts c)))

  TypeChecker
  (type-check [c old-c]
    (let [new-c (-> (.alts c)
                    (map .ast)
                    c/sum-type
                    (.path (.path c))
                    (.sym (.sym c))
                    (.var (.var c)))]
      (map (either (map (.sym old-c)
                        (fn [sym]
                          (append-type-constraint sym new-c)))
                   se-nop)
           (fn [_]
             (ConstrainedAST new-c new-c))))))

(extend-type c/SumConstraint
  TypeChecker
  (pre-check [c]
    (se/state-error (ConstrainedSum (.alts c) (.path c) (.sym c) (.var c)))))

(extend-type c/ResultConstraint
  TypeChecker
  (pre-check [c]
    (se/state-error (c/update-sym c (symbol "#result"))))

  (type-check [c old-c]
    (let [rc (-> c
                 .assertion
                 .constraint)]
      (se/state-error
       (ConstrainedAST (c/ResultConstraint rc) rc)))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.value-exprs (-> (.value-exprs ast)
                          (remove (partial instance? ast/block-comment-ast))
                          (map (fn [inner-ast]
                                 (either (map (instance? ast/fn-ast inner-ast)
                                              (fn [fn-ast]
                                                (.fn-sym fn-ast (maybe (.sym ast)))))
                                         inner-ast)))))
        se/state-error))

  (type-check [ast old-ast]
    (let [constrained (either (last (.value-exprs ast))
                              (ConstrainedAST old-ast c/top-type))]
      (flat-map
       ;; (se-debug 'def (.sym old-ast) constrained)
       se-nop
                (fn [_]
                  (either (map (instance? c/Constraints (.ast constrained))
                               (fn [constraint]
                                 (let [constraint (c/update-type-name constraint (.sym old-ast))]
                                   (-> (either (map (.sym constraint)
                                                    (fn [sym]
                                                      (remove-type-constraint sym)))
                                               se-nop)
                                       (flat-map (fn [_]
                                                   (se/assoc-in-val [.module .types (ast/untag (.sym old-ast))]
                                                                    constraint)))))))
                          (map (set-type-constraint (.sym old-ast) constrained)
                               (fn [_]
                                 constrained))))))))

(extend-type ast/inline-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [c (se-translate (lookup-constraint (.result-type ast)))]
      (ConstrainedAST (.result-type ast c) c))))

(extend-type Tagged
  TypeChecker
  (check-call-site [ast args]
    (map (get-type-constraint ast)
         (fn [c-ast]
           ;; TODO: seems to be called on recursive calls.
           ;; return the #result constraint
           (Right c/top-type))))

  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (recover-type-constraint [sym]
    (flat-map (se/get-in-val [.module .value-types])
              (fn [types-list]
                (assert (instance? List types-list))
                (either (for [value-types (nth types-list 1)
                              prev-constraint (get value-types (ast/untag sym))]
                          (set-type-constraint sym prev-constraint))
                        (remove-type-constraint sym)))))

  (param-types [sym]
    (for [c (get-type-constraint sym)]
      (cond (instance? c/DynamicConstraint (.constraint c))
            (.constraint c c/top-type)

            c)))

  (type-check [s old-s]
    (get-type-constraint s)))

(deftype ParamConstraintPair [v1 v2]
  (assert (instance? (any-of ast/BindingTarget
                             Symbol)
                     v1))
  (assert (instance? c/ValueConstraint v2))

  Stringable
  (string-list [_]
    (list "(ParamConstraintPair " (str v1) " " (str v2) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn constrain-all-syms [tup]
  (assert (instance? ParamConstraintPair tup))

  (let [[param param-c] (type-args tup)]
    (cond (instance? Tagged param)
          (map (set-type-constraint param (ConstrainedAST param param-c))
               (fn [_]
                 tup))
          (let [new-param-cs (c/intersect (ast/new-param-constraints param)
                                          param-c)
                new-param-cs (either (or (= c/bottom-type new-param-cs)
                                         (and (instance? c/TypeConstraint param-c)
                                              (maybe (ast/new-param-constraints param))))
                                     new-param-cs)]
            (cond (= c/bottom-type new-param-cs)
                  (do
                    (c/conflicting-assertions new-param-cs "ka blooie" _LINE_)
                    (se/throw new-param-cs))

                  (let [new-tail (cond (= (.tail-constraint new-param-cs) c/bottom-type)
                                       (c/TypeConstraint {c/ListType #{}} empty-list
                                                         'List nothing "")
                                       (c/intersect (c/TypeConstraint {c/ListType #{}}
                                                                      empty-list 'List nothing "")
                                                    (.tail-constraint new-param-cs)))]
                    (-> (zip-lists (.fixed param) (c/extract-items-constraints new-param-cs))
                        (map (fn [[x y]]
                               (ParamConstraintPair x y)))
                        vec
                        (comp (either (map (.variadic param)
                                           (fn [variadic]
                                             [(ParamConstraintPair variadic new-tail)]))
                                      []))
                        se/state-error)))))))

(extend-type ast/params-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (param-types [params]
    (se/state-error (-> c/empty-items-constraint
                        (.tail-constraint (either (.variadic params)
                                                  c/top-type))
                        (.items-constraints (.fixed params)))))

  (type-check [ast old-ast]
    (either (map (.variadic old-ast)
                 (fn [var-sym]
                   (for [_ (set-type-constraint var-sym (ConstrainedAST var-sym list-constraint))]
                     old-ast)))
            (se/state-error old-ast))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (ana constrain-all-syms (ParamConstraintPair (.params ast)
                                                         (.param-consts ast))
                 se/state-error)]
      (.body ast (remove (.body ast) (partial instance? ast/block-comment-ast)))))

  (type-check [ast old-ast]
    (for [pts (get-param-types (.params old-ast))
          result-c (se/try
                     (get-type-constraint (symbol "#result"))
                     (fn [_]
                       (se/state-error (ConstrainedAST (symbol "#result") c/top-type))))
          _ (remove-type-constraint (symbol "#result"))
          _ (recover-types (.params old-ast))
          _ (nip-types)]
      (let [result-c (c/intersect (cata strip-constraints result-c)
                                  (.result-const ast))
            result-c (c/intersect result-c
                                  (either (map (last (.body ast)) .constraint)
                                          c/top-type))
            pts (c/intersect (cata strip-constraints pts)
                             (.param-consts ast))]
        (either (map (or (= c/bottom-type result-c)
                         (= c/bottom-type pts))
                     (fn [failure-c]
                       (c/conflicting-assertions failure-c "type checker testing" _LINE_)
                       (se/throw failure-c)))
                (-> ast
                    (.result-const result-c)
                    (.param-consts pts)))))))

(extend-type ast/fn-ast
  TypeChecker
  (check-call-site [ast args]
    (let [arg-count (count args)]
      (either (map (or (some (.arities ast) (fn [arity]
                                              (and (-> arity
                                                       .params
                                                       .fixed
                                                       count
                                                       (= arg-count))
                                                   (maybe arity))))
                       (some (.arities ast) (fn [arity]
                                              (and (-> arity
                                                       .params
                                                       .variadic)
                                                   (-> arity
                                                       .params
                                                       .fixed
                                                       count
                                                       (<= arg-count))
                                                   (maybe arity)))))
                   (fn [arity]
                     (-> arity
                         .param-consts
                         (c/extract-items-constraints arg-count)
                         (zip-lists args)
                         (se/traverse (fn [[c arg]]
                                        (update-constraint arg c)))
                         (map (fn [_]
                                (Left (.result-const arity)))))))
              (se/throw (str "Could not find implementation of " (str "'" (.fn-sym ast) "'")
                             ;; TOOD: add location
                             "with " arg-count "arguments.")))))

  (pre-check [ast]
    (either (map (.fn-sym ast)
                 (fn [sym]
                   (map (set-type-constraint sym (ConstrainedAST sym fn-constraint))
                        (fn [_]
                          (.arities ast (map (.arities ast)
                                             (fn [arity]
                                               (.fn-sym arity sym))))))))
            (se/state-error ast)))

  (type-check [ast old-ast]
    (either (map (.fn-sym ast)
                 (fn [_]
                   (se/state-error (ConstrainedAST ast fn-constraint))))
            (se/state-error (ConstrainedAST ast fn-constraint)))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (se/traverse (all-syms (.params ast))
                         (fn [sym]
                           (set-type-constraint sym (ConstrainedAST sym c/top-type))))]
      ast))

  (type-check [ast old-ast]
    (for [pts (get-param-types (.params old-ast))
          result-c (se/try
                     (get-type-constraint (symbol "#result"))
                     (fn [_]
                       (se/state-error (ConstrainedAST (symbol "#result") c/top-type))))
          _ (remove-type-constraint (symbol "#result"))
          _ (recover-types (.params old-ast))
          _ (nip-types)]
      (-> ast
          (.result-const (cata strip-constraints result-c))
          (.param-consts (cata strip-constraints pts))))))

(extend-type PrototypeImpls
  TypeChecker
  (check-call-site [proto-impls args]
    (let [num-args (count args)]
      (either (map (first args)
                   (fn [disp-arg]
                     (let [type-num (constraint-type-num (.constraint disp-arg))
                           param-cs (either (or (get-in proto-impls [.impls type-num num-args .param-consts])
                                                (get-in proto-impls [.impls c/UnknownType num-args .param-consts]))
                                            c/top-type)
                           result-c (either (or (get-in proto-impls [.impls type-num num-args .result-const])
                                                (get-in proto-impls [.impls c/UnknownType num-args .result-const]))
                                            c/top-type)]
                       (map (se/traverse (zip-lists args (c/extract-items-constraints param-cs num-args))
                                         (fn [[arg c]]
                                           (update-constraint arg c)))
                            (fn [_]
                              (Left result-c))))))
              (-> [(str "'" (.fn-sym proto-impls) "'") "requires at least one argument at"
                   ;; TODO: add locatio
                   ]
                  (interpose " ")
                  to-str
                  se/throw))))

  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (set-type-constraint (.fn-sym ast) (ConstrainedAST ast fn-constraint))))

(deftype ProtocolWithImpls [protocol default-impls]
  Stringable
  (string-list [_]
    (list "(ProtocolWithImpls " (str protocol) "\n\n" (str default-impls) ")"))

  Container
  (map [_ f]
    (ProtocolWithImpls (f protocol) (map default-impls f)))

  (map [_ f embed]
    (for [new-impls (-> default-impls
                        vec
                        (map (fn [[k v]]
                               (map (f v) (partial vector k)))
                             embed)
                        (map (fn [kv-pairs]
                               (reduce kv-pairs {}
                                       (fn [m [k v]]
                                         (assoc m k v))))))
          new-proto (f protocol)]
      (ProtocolWithImpls new-proto new-impls)))

  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/protocol-ast
  TypeChecker
  (pre-check [ast]
    (let [prototypes (reduce (.prototypes ast) nothing
                             (fn [protos proto]
                               (or (for [_ (-> (.default-body proto)
                                               (filter ast/generates-code?)
                                               first)
                                         :let [arg-count (count (.fixed (.params proto)))
                                               proto-arity (ast/fn-arity (.fn-name proto)
                                                                         (.params proto)
                                                                         (.doc proto)
                                                                         (.default-body proto))]
                                         protos (or protos
                                                    (maybe {}))
                                         new-protos (or (update-in protos [(.fn-name proto) .impls 0]
                                                                   (fn [arities]
                                                                     (assoc arities arg-count proto-arity)))
                                                        (maybe (assoc-in protos [(.fn-name proto)]
                                                                         (PrototypeImpls
                                                                          (.fn-name proto)
                                                                          {c/UnknownType
                                                                           {arg-count proto-arity}}))))]
                                     new-protos)
                                   protos)))
          new-protocol (.prototypes ast
                                    (map (.prototypes ast)
                                         (fn [proto]
                                           (.default-body proto (filter (.default-body proto)
                                                                        (partial instance? c/Constraints))))))]
      (se/state-error (either (map prototypes
                                   (partial ProtocolWithImpls new-protocol))
                              new-protocol))))

  (type-check [ast old-ast]
    (for [_ (se/traverse (.prototypes ast)
                         (fn [proto]
                           (let [arg-count (count (.fixed (.params proto)))
                                 proto-arity (ast/fn-arity-ast (.fn-name proto)
                                                               ""
                                                               (.params proto)
                                                               (.doc proto)
                                                               []
                                                               (cata strip-constraints (.param-consts proto))
                                                               (cata strip-constraints (.result-const proto)))]
                             (comp (for [final (se/get-in-val [.module .value-types 0 (ast/untag (.fn-name proto))
                                                               .impls c/UnknownType arg-count])]
                                     (do
                                       ;; TODO: this won't ever be called during type checking
                                       (print-err 'final-proto (ast/untag (.fn-name proto)) arg-count "\n"
                                                  (.param-consts final) "\n\n"
                                                  (.result-const final))
                                       (abort)
                                       '_))
                                   (set-type-constraint (.fn-name proto)
                                                        (ConstrainedAST (PrototypeImpls
                                                                         (.fn-name proto)
                                                                         {c/UnknownType
                                                                          {arg-count proto-arity}})
                                                                        fn-constraint))))))
          ;; _ (se-debug 'checked (type-name ast) "\n" ast)
          ;; _ (se-debug 'protos (-> (.prototypes ast)
          ;;                         (map (fn [ast]
          ;;                                (str "(" (str (.fn-name ast)) " " (.params ast) "\n"
          ;;                                     (-> (.param-consts ast)
          ;;                                         c/extract-items-constraints
          ;;                                         (remove (fn [c]
          ;;                                                   (= c/top-type (.constraint c))))
          ;;                                         (interpose "\n")
          ;;                                         to-str)
          ;;                                     "\n\n"
          ;;                                     (.result-const ast) ")")))
          ;;                         (interpose "\n\n")
          ;;                         to-str))
          _ (set-type-constraint (.protocol-sym ast) (ConstrainedAST ast c/top-type))]
      '_)))

(defn impl-arities [impls]
  (for [[proto-sym impls] (vec impls)
        [fn-sym arities] (vec impls)
        arity arities]
    [proto-sym fn-sym (.fn-sym arity fn-sym)]))

(defn find-prototype [proto-sym fn-sym arg-count]
  (assert (instance? ast/tagged-symbol proto-sym))
  (assert (instance? ast/tagged-symbol fn-sym))

  (let [proto-sym (ast/untag proto-sym)
        fn-sym (ast/untag fn-sym)]
    (comp (flat-map (se/get-in-val [.module .value-types 0 proto-sym
                                    .ast .prototypes])
                    (fn [prototypes]
                      (either (some prototypes
                                    (fn [prototype]
                                      (and (= (.fn-name prototype) fn-sym)
                                           (-> prototype
                                               .params
                                               .fixed
                                               count
                                               (= arg-count))
                                           (maybe (se/state-error prototype)))))
                              se/zero-se)))
          (se/throw (str "Could not find prototype " _FILE_ " " _LINE_)))))

(defn extend-prototypes [type-num impls]
  (se/traverse (impl-arities impls)
               (fn [[proto-name fn-sym arity]]
                 (for [prototype (find-prototype proto-name fn-sym (count (.fixed (.params arity))))
                       :let [param-cs (c/intersect (cata strip-constraints (.param-consts prototype))
                                                   (cata strip-constraints (.param-consts arity)))
                             result-c (c/intersect (cata strip-constraints (.result-const prototype))
                                                   (cata strip-constraints (.result-const arity)))
                             _ (either (map (or (= c/bottom-type param-cs)
                                                (= c/bottom-type result-c))
                                            (fn [failure-c]
                                              (c/conflicting-assertions failure-c
                                                                        "type checker testing" _LINE_)
                                              (abort)))
                                       '_)
                             new-arity (-> arity
                                           (.param-consts param-cs)
                                           (.result-const result-c))]
                       _ (se/update-in-val [.module .value-types]
                                           (fn [[value-types & types-list]]
                                             (cons (assoc-in value-types
                                                             [fn-sym .impls type-num
                                                              (count (.fixed (.params new-arity)))]
                                                             new-arity)
                                                   types-list)))]
                   [proto-name fn-sym new-arity]))))

(extend-type ast/reify-ast
  TypeChecker
  (check-call-site [ast args]
    (let [num-args (inc (count args))]
      (either (for [invoke-arities (get-in ast [.impls Function-sym invoke-sym])
                    arity (some invoke-arities (fn [arity]
                                                 (and (-> arity
                                                          .params
                                                          .fixed
                                                          count
                                                          (=* num-args))
                                                      (maybe arity))))]
                (let [param-cs (.param-consts arity)
                      result-c (.result-const arity)]
                  (map (se/traverse (zip-lists args (rest (c/extract-items-constraints param-cs num-args)))
                                    (fn [[arg c]]
                                      (update-constraint arg c)))
                       (fn [_]
                         (Left result-c)))))
              (-> ["No 'invoke' implementation found for value at"
                   ;; TODO: add locatio
                   ]
                  (interpose " ")
                  to-str
                  se/throw))))

  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (let [reified-type-num (either (.type-num ast)
                                   (extract type-counter))]
      (flat-map (extend-prototypes reified-type-num (.impls ast))
                (fn [arities]
                  (let [arities (reduce arities {}
                                        (fn [m [proto-name fn-sym arity]]
                                          (either (and (get-in m [proto-name fn-sym])
                                                       (update-in m [proto-name fn-sym]
                                                                  (fn [arities]
                                                                    (conj arities arity))))
                                                  (assoc-in m [proto-name fn-sym] [arity]))))]
                    (se/state-error (ConstrainedAST (ast/reify-ast (maybe reified-type-num) arities)
                                                    (c/TypeConstraint {reified-type-num #{}}
                                                                      empty-list (symbol "reified value at")
                                                                      ;; TODO: add location
                                                                      nothing "")))))))))

(extend-type ast/call-ast
  TypeChecker
  (check-call-site [ast args]
    ;; TODO: might need to be expanded
    (se/state-error (Left c/top-type)))

  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [result-type (apo (fn [inner-ast]
                             (check-call-site inner-ast (.args ast)))
                           (.call-target ast) se/state-error)]
      (ConstrainedAST old-ast result-type))))

(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (comp (for [constraint (se-translate (get-type-sym-info (.type ast)))
                :let [type-nums (either (map (c/extract-type-map constraint)
                                             keys)
                                        [])]
                _ (se/traverse type-nums
                               (fn [type-num]
                                 (extend-prototypes type-num (.impls ast))))]
            (do
              ;; (print-err 'extended (.type ast))
              ast))
          (-> ["Could not find type" (str "'" (.type ast) "'")
               "at" (str (ast/file-name (.type ast)) ":") (ast/line-number (.type ast))]
              (interpose " ")
              to-str
              se/throw))))

(extend-type ast/let-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.body (remove (.body ast) (partial instance? ast/block-comment-ast)))
        se/state-error))

  (type-check [ast old-ast]
    (map (se/traverse (reverse (.bindings old-ast))
                      (fn [binding-ast]
                        (for [_ (se/traverse (all-syms (.binding binding-ast))
                                             recover-type-constraint)
                              _ (nip-types)]
                          '_)))
         (fn [_]
           (let [result-c (either (map (last (.body ast)) .constraint)
                                  c/top-type)]
             ;; (print-err 'checked ast)
             (ConstrainedAST ast (c/clear-sym result-c)))))))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (let [binding-syms (all-syms (.binding ast))]
      (for [_ (push-types)
            _ (se/traverse binding-syms
                           (fn [sym]
                             (set-type-constraint sym (ConstrainedAST sym c/top-type))))]
        ast)))

  (type-check [ast old-ast]
    (for [_ (ana constrain-all-syms (ParamConstraintPair (either (map (instance? ConstrainedAST (.binding ast))
                                                                      .ast)
                                                                 (.binding ast))
                                                         (.constraint (.val ast)))
                 se/state-error)]
      ast)))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [new-clause (update-constraint (.clause ast) maybe-constraint)]
      (-> ast
          (.clause new-clause)
          (ConstrainedAST (c/sum-type [(c/extract-contents-constraint (.constraint new-clause))
                                       (.constraint (.alt ast))]))))))

(extend-type ast/declaration-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (set-type-constraint (.sym ast) (ConstrainedAST c/top-type c/top-type))))

(deftype CheckedCondVal [ast types]
  Stringable
  (string-list [_]
    (list "(CheckedCondVal " (str ast) "\n<types>)")))

(extend-type ast/cond-val-ast
  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (for [new-conditional (update-constraint (.conditional ast) maybe-constraint)
          types (pop-types)]
      (-> ast
          (.conditional new-conditional)
          (ConstrainedAST (.constraint (.value ast)))
          (CheckedCondVal types)))))

(extend-type ast/cond-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (let [conditionals (either nothing (vec (map (.conditionals ast) .ast)))]
      (either (map (first (.conditionals ast))
                   (fn [first-cond]
                     (for [_ (pop-types)
                           _ (push-types (.types first-cond))]
                       (ConstrainedAST (.conditionals ast conditionals)
                                       (-> conditionals
                                           (map .constraint)
                                           (conj (.constraint (.default ast)))
                                           c/sum-type)))))
              (se/state-error (ConstrainedAST ast (.constraint (.default ast))))))))

(extend-type ast/integer-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (se/state-error (ConstrainedAST ast int-constraint))))

(extend-type ast/string-ast
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (se/state-error (ConstrainedAST ast string-constraint))))

(deftype AndClause [clause]
  Stringable
  (string-list [_]
    (list "(AndClause " (str clause) ")"))

  Container
  (map [_ f]
    (AndClause (f clause)))

  (map [_ f embed]
    (map (f clause) AndClause))

  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [new-clause (update-constraint (.clause ast) maybe-constraint)
          types (get-types)]
      (CheckedCondVal new-clause types))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clauses (map (.clauses ast) AndClause))
        se/state-error))

  (type-check [ast old-ast]
    (either (for [first-clause (first (.clauses ast))
                  last-clause (last (.clauses ast))]
              (for [_ (pop-types)
                    _ (push-types (.types first-clause))
                    ;; TODO: when the ast of the first clause is a call to instance?,
                    ;; recover the type of the symbol in the second arg
                    ]
                (-> ast
                    (.clauses (map (.clauses ast) .ast))
                    (ConstrainedAST (.constraint (.ast last-clause))))))
            (se/state-error (ConstrainedAST ast maybe-constraint)))))

(deftype OrClause [clause]
  Stringable
  (string-list [_]
    (list "(OrClause " (str clause) ")"))

  Container
  (map [_ f]
    (OrClause (f clause)))

  (map [_ f embed]
    (map (f clause) OrClause))

  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (for [new-clause (update-constraint (.clause ast) maybe-constraint)
          types (pop-types)]
      (CheckedCondVal new-clause types))))

(extend-type ast/or-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clauses (map (.clauses ast) OrClause))
        se/state-error))

  (type-check [ast old-ast]
    (either (for [first-clause (first (.clauses ast))]
              (for [_ (pop-types)
                    _ (push-types (.types first-clause))
                    ;; TODO: when the ast of the first clause is a call to instance?,
                    ;; recover the type of the symbol in the second arg
                    ]
                (-> ast
                    (.clauses (map (.clauses ast) .ast))
                    (ConstrainedAST (-> (.clauses ast)
                                        (map (comp .constraint .ast))
                                        c/sum-type)))))
            (se/state-error (ConstrainedAST ast maybe-constraint)))))

(extend-type String
  TypeChecker
  (pre-check [ast]
    (se/state-error (ast/string-ast ast "" 0))))

(extend-type Integer
  TypeChecker
  (pre-check [ast]
    (se/state-error (ast/integer-ast ast "" 0))))

(extend-type HashMap
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (se/state-error (ConstrainedAST ast hashmap-constraint))))

(extend-type Vector
  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (se/state-error ast)))

(deftype CheckedTypeAST [sym fields]
  Stringable
  (string-list [_]
    (list "(CheckedTypeAST " (str sym) " " (str fields) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [new-type (get-type-constraint (.sym ast))
          ;; _ (se/traverse fields (fn [field]
          ;;                         (for [field-c (get-type-constraint field)]
          ;;                           (print-err 'field (.sym ast) field field-c))))
          _ (pop-types)
          _ (set-type-constraint (.sym ast) new-type)]
      (do
        ;; (print-err 'defined-type (.sym ast))
        new-type))))

(defn add-prototype-assertions [[proto-sym fn-sym arity]]
  (for [prototype (find-prototype proto-sym fn-sym (count (.fixed (.params arity))))
        :let [param-cs (c/intersect (.param-consts prototype)
                                    (.param-consts arity))
              result-c (c/intersect (.result-const prototype)
                                    (.result-const arity))
              _ (either (map (or (= c/bottom-type param-cs)
                                 (= c/bottom-type result-c))
                             (fn [failure-c]
                               (c/conflicting-assertions failure-c
                                                         "type checker testing" _LINE_)
                               (se/throw "no additional info")))
                        '_)
              new-arity (-> arity
                            (.param-consts (c/clear-sym param-cs))
                            (.result-const (c/clear-sym result-c)))]]
    [proto-sym fn-sym new-arity]))

(deftype TypeCheckOnly [x]
  Stringable
  (string-list [_]
    (list "(TypeCheckOnly " (str x) ")"))

  Container
  (map [ast f]
    (TypeCheckOnly (f x)))

  (map [ast f embed]
    (map (f x) TypeCheckOnly))

  TypeChecker
  (pre-check [ast]
    ;; TODO: remove eventually
    ;; disables printing of pre-check message
    (se/state-error ast))

  (type-check [ast old-ast]
    (se/state-error (ConstrainedAST (ast/block-comment "" 0 [])
                                    c/top-type))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (let [sym (.sym ast)
          fields (-> (.fields ast)
                     .fixed
                     (map ast/untag))
          field-assertions (-> c/empty-items-constraint
                               (.items-constraints (filter (.impls ast) (partial instance? c/ValueConstraint)))
                               (.tail-constraint (c/CollectionOf c/top-type empty-list nothing "")))
          type-num (new-type-number sym)
          type-map {type-num (-> fields
                                 (map (fn [name]
                                        (symbol (str "." name))))
                                 set)}
          new-type-constraint (c/TypeConstraint type-map empty-list sym nothing "")
          default-impls (default-type-impls sym type-num fields)]
      (for [_ (se/assoc-in-val [.module .types (ast/untag sym)]
                               new-type-constraint)
            _ (se/assoc-in-val [.constants .type-names type-num] (str sym))
            _ (set-type-constraint sym (ConstrainedAST sym fn-constraint))
            _ (se/traverse fields (fn [sym]
                                    (set-type-constraint sym (ConstrainedAST sym c/top-type))))
            _ (push-types)
            field-assertions (se-translate (lookup-constraint field-assertions))
            impls  (-> (.impls ast)
                       (remove (partial instance? c/Constraints))
                       (flat-map impl-arities)
                       (se/traverse add-prototype-assertions))]
        (let [impls (reduce impls {}
                            (fn [impls [proto-sym fn-sym arity]]
                              (either (update-in impls [proto-sym fn-sym]
                                                 (fn [arities]
                                                   (conj arities arity)))
                                      (assoc-in impls [proto-sym fn-sym] [arity]))))
              ;; TODO: eliminate the named symbols
              impls-get (get-in impls [Associative-sym get-symb])
              default-get (get-in default-impls [Associative-sym get-symb])
              impls-assoc (get-in impls [Associative-sym assoc-sym])
              default-assoc (get-in default-impls [Associative-sym assoc-sym])

              hash-map-impls (either (map (or impls-get
                                              default-get)
                                          (partial assoc-in {} [Associative-sym get-symb]))
                                     {})
              hash-map-impls (either (map (or impls-assoc
                                              default-assoc)
                                          (partial assoc-in hash-map-impls [Associative-sym assoc-sym]))
                                     hash-map-impls)]
          [(map (.items-constraints field-assertions) TypeCheckOnly)
           (TypeCheckOnly (ast/extend-ast sym (dissoc default-impls Associative-sym)))
           (TypeCheckOnly (ast/extend-ast sym (either (update impls Associative-sym
                                                              (fn [fns]
                                                                (dissoc fns assoc-sym get-symb)))
                                                      impls)))
           ;; promote all inferred field constraints
           (cond (empty? hash-map-impls)
                 (ast/block-comment "" 0 [])
                 (ast/extend-ast sym hash-map-impls))
           ;; TODO
           ;; getters
           (ast/definition-ast sym [(create-constructor sym type-num new-type-constraint fields
                                                        field-assertions)])
           (CheckedTypeAST sym fields)])))))

(extend-type ast/block-comment-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error (ConstrainedAST ast c/top-type))))

(defn type-check-ast [ast]
  (flat-map (pre-check ast)
            (fn [new-ast]
              (flat-map (map new-ast type-check-ast se/state-error)
                        (fn [newer-ast]
                          (type-check newer-ast new-ast))))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (sm-translate (type-check-ast ast))
                        ;; (for [emitted (emit-definition ast)
                        ;;       static-strs (sm/get-in-val [.constants .strings])
                        ;;       static-nums (sm/get-in-val [.constants .numbers])
                        ;;       static-syms (sm/get-in-val [.constants .symbols])
                        ;;       :let [constants (extract constants)
                        ;;             ;; TODO: 'vec' here segfaults
                        ;;             ;; _ (map (seq static-strs)
                        ;;             ;;        (fn [[k v]]
                        ;;             ;;          (either (get-in constants [.strings k])
                        ;;             ;;                  (cache-static-constant k v))))
                        ;;             ;; _ (map (seq static-nums)
                        ;;             ;;        (fn [[k v]]
                        ;;             ;;          (either (get-in constants [.numbers k])
                        ;;             ;;                  (cache-static-constant k v))))
                        ;;             ;; _ (map (seq static-syms)
                        ;;             ;;        (fn [[k v]]
                        ;;             ;;          (either (get-in constants [.symbols k])
                        ;;             ;;                  (cache-static-constant k v))))
                        ;;             ]
                        ;;       _ (map (sm/get-in-val [.fn-context .decl]) write-strings)
                        ;;       _ (sm/assoc-in-val [.fn-context .decl] [])
                        ;;       _ (sm/update-in-val [.setup .init] (fn [x]
                        ;;                                            (comp x emitted)))]
                        ;;   "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))


(def fixup-native-symbols*
  (apply (wrap sm/zero-sm (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (ast/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(FnArity *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'zero) 1)
                     (fn [arity-sym]
                       ["Value *(*zero)(FnArity *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(FnArity *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(FnArity *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(FnArity *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(FnArity *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(FnArity *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(FnArity *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'vals) 1)
                     (fn [arity-sym]
                       ["Value *(*vals)(FnArity *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'first) 1)
                     (fn [arity-sym]
                       ["Value *(*first)(FnArity *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'rest) 1)
                     (fn [arity-sym]
                       ["Value *(*rest)(FnArity *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(FnArity *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(FnArity *, Value*) = " arity-sym ";\n"]))

                ;; TODO: no longer needed
                (map (get-proto-dispatch-sym (ast/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(FnArity *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(FnArity *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(FnArity *, Value *) = " arity-ptr ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'new-hash-set) 1)
                     (fn [arity-ptr]
                       ["Value *(*newHashSet)(FnArity *, Value *) = " arity-ptr ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(FnArity *, Value*, Value*) = " arity-ptr ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'pr-value) 1)
                     (fn [arity-ptr]
                       ["Value *(*prValue)(FnArity *, Value*) = " arity-ptr ";\n"]))
                )))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp (for [r fixup-native-symbols*
                              _ (map (sm/get-val .module)
                                     (fn [core-mod]
                                       (send core-agent (fn [_] core-mod))))]
                          r)
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defprotocol ASTEmitter
  (load-module [ast root-dir proj-dir]
    (assert-result r (instance? Promise r))))

(defn add-module-file [module]
  (for [_ (sm/assoc-in-val [.mod-files (.path module)] module)
        _ (sm/traverse (vals (.namespaces module)) add-module-file)]
    '_))

(defn analyze-forms [ast-emitter]
  (rd/parser
   (grmr/catch-error (fn [error curr-state]
                       (abort))
                     (grmr/none-or-more
                      (grmr/any
                       (grmr/one-or-more
                        (apply-to (fn [ast root-dir proj-dir]
                                    (let [ns-sym (ast/untag (.ns-sym ast))
                                          waiter-prom (load-module (.mod ast) root-dir proj-dir)]
                                      (send ast-emitter
                                            (fn [context]
                                              (update-context
                                               context
                                               (let [module (extract waiter-prom)]
                                                 (for [_ (sm/assoc-in-val [.module .namespaces ns-sym]
                                                                          module)
                                                       _ (sm/update-in-val [.setup .init]
                                                                           (fn [mod-init]
                                                                             (conj mod-init
                                                                                   (c-code ""
                                                                                           ["init_module_"
                                                                                            (str (.index module))
                                                                                            "();\n"]
                                                                                           {} c/top-type))))
                                                       _ (add-module-file module)]
                                                   '_)))))))
                                  rdr/read-add-ns
                                  (grmr/get-value 'root-directory)
                                  (grmr/get-value 'project-directory)))
                       (apply-to (fn [ast]
                                   (send ast-emitter emit-ast ast))
                                 rdr/top-level))))))

(defn fixup-generated-symbols [context file-name protocols-sym symbols-sym]
  ;; TODO: make sure .declarations is empty
  (update-context context
                  (for [protocols-var (sm/get-in-val [.module .values protocols-sym])
                        _ (sm/assoc-in-val [.module .values 'protocols]
                                           protocols-var)
                        symbols-var (sm/get-in-val [.module .values symbols-sym])
                        _ (sm/assoc-in-val [.module .values 'symbols]
                                           symbols-var)
                        mod-init (sm/get-in-val [.setup .init])
                        cleanup (sm/get-in-val [.setup .cleanup])
                        module (sm/get-val .module)
                        :let [mod-index (.index module)
                              inited-var (str "m" mod-index "_inited")
                              _ (write-strings ["int " inited-var " =  0;\n"
                                                "void init_module_" (str mod-index) "() {\n"
                                                "if (!" inited-var ") {\n"
                                                (either (empty? mod-init)
                                                        (.init (apply comp mod-init)))
                                                "if(" (.c-var symbols-var) "->refs > 0)\n"
                                                (.c-var symbols-var) "->refs = -1;\n"
                                                inited-var "= 1;\n}}\n"])

                              _ (write-strings ["void cleanup_module_" (str mod-index) "() {\n"
                                                cleanup
                                                "}\n"])]
                        _ (sm/assoc-in-val [.setup .cleanup] ["cleanup_module_" (str mod-index) "();\n"])
                        _ (sm/update-val .loaded (fn [loaded-prom]
                                                   (deliver loaded-prom module)))]
                    '_)))

(defn init-core-module [context]
  (update-context
   context
   (sm/assoc-in-val [.module .types]
                    {'Integer int-constraint
                     'StringBuffer (c/TypeConstraint {c/StringBufferType #{}}
                                                     empty-list 'String nothing "")
                     'SubString (c/TypeConstraint {c/SubStringType #{}}
                                                  empty-list 'String nothing "")
                     'FnArity (c/TypeConstraint {c/FnArityType #{}}
                                                empty-list 'FnArity nothing "")
                     'BitmapIndexedNode (c/TypeConstraint {c/BitmapIndexedType #{}}
                                                          empty-list 'BitmapIndexedNode
                                                          nothing "")
                     'ArrayNode (c/TypeConstraint {c/ArrayNodeType #{}}
                                                  empty-list 'ArrayNode nothing "")
                     'HashCollisionNode (c/TypeConstraint
                                         {c/HashCollisionNodeType #{}}
                                         empty-list 'HashCollisionNode nothing "")
                     'Fn fn-constraint
                     'List list-constraint
                     'Maybe maybe-constraint
                     'Vector vect-constraint
                     'Symbol sym-constraint
                     'HashMap hashmap-constraint
                     'Promise (c/TypeConstraint {c/PromiseType #{}} empty-list
                                                'Promise nothing "")
                     'Future (c/TypeConstraint {c/FutureType #{}} empty-list
                                               'Future nothing "")
                     'Agent (c/TypeConstraint {c/AgentType #{}} empty-list
                                              'Agent nothing "")
                     'Opaque (c/TypeConstraint {c/OpaqueType #{}} empty-list
                                               'Opaque nothing "")})))

(def global-context (GlobalContext (FunctionArityContext (FnSpec {} {}) 0 {} {} empty-closures [] {} nothing)
                                   (FunctionArityContext (FnSpec {} {}) 0 {} {} empty-closures [] {} nothing)
                                   (Module 'core 0 {} {} {} {} {} empty-list)
                                   (ConstantValues {} {} {} type-names {} {})
                                   0                        ;; reify-fn-index
                                   (promise)                ;; loaded
                                   (ModuleSetup [] [])      ;; setup
                                   {}                       ;; mod-files
                                   ))

(defn wait-for-module [waiter-prom ctxt]
  (assert (instance? (maybe-of GlobalContext) ctxt))

  (update-context ctxt
                  (sm/update-val .loaded
                                 (fn [mod-prom]
                                   (map mod-prom (partial deliver waiter-prom))
                                   mod-prom))))

(defn compile-module [module-agents file-name waiter-prom root-dir proj-dir]
  (assert (instance? (map-of String Agent) module-agents))

  (either (map (get module-agents file-name)
               (fn [ast-emitter]
                 (send ast-emitter
                       (fn [ctxt]
                         (update-context ctxt
                                         (sm/update-val .loaded (fn [mod-prom]
                                                                  (map mod-prom (partial deliver waiter-prom))
                                                                  mod-prom)))))
                 module-agents))
          (let [core-prom (promise)
                module-agents (cond (= file-name 'core)
                                    module-agents
                                    (compile-module module-agents 'core core-prom root-dir proj-dir))
                ast-emitter (-> global-context
                                (.loaded waiter-prom)
                                maybe
                                agent)
                module-index (count module-agents)]
            (send ast-emitter new-module file-name module-index)
            (cond (= file-name 'core)
                  (send ast-emitter init-core-module)
                  (send ast-emitter
                        (fn [context]
                          (extract core-prom)
                          context)))
            (future (fn []
                      (either (map (fio/file-in (cond (= file-name 'core)
                                                      path-to-core
                                                      file-name))
                                   (fn [file-in]
                                     (do
                                       ((analyze-forms ast-emitter)
                                        {'file-name file-name
                                         'root-directory root-dir
                                         'project-directory proj-dir
                                         'line-number 1}
                                        (lazy-list file-in))
                                       (and (= file-name 'core)
                                            (maybe (send ast-emitter fixup-native-symbols)))
                                       (send ast-emitter
                                             fixup-generated-symbols file-name
                                             protocols-sym symbols-sym))))
                              (do
                                (print-err "Could not compile" file-name)
                                (abort)))))
            (assoc module-agents file-name ast-emitter))))


(extend-type ast/module-ast
  ;; ev/Evaluator
  ;; (ev/eval [x]
  ;;   (let [file (.file-path x)]
  ;;     (comp (for [curr-file-name (sm/get-val .file-name)
  ;;                 curr-file-path (sm/when (sys/file-directory curr-file-name))
  ;;                 :let [file (str curr-file-path file)]
  ;;                 mod-syms (comp (sm/get-in-val [.ns file .syms])
  ;;                                (for [asts (sm/when (for [file-in (fio/file-in file)
  ;;                                                          asts (ev/parse {'file-name file
  ;;                                                                          'line-number 1}
  ;;                                                                         (lazy-list file-in))]
  ;;                                                      asts))
  ;;                                      _ (sm/set-val .file-name file)
  ;;                                      base-imports (sm/get-val .base-imports)
  ;;                                      _ (sm/assoc-in-val [.ns file] (ev/EvalNamespace file base-imports {}
  ;;                                                                                      {} [{}]))
  ;;                                      _ (ev/eval asts)
  ;;                                      mod-syms (sm/get-in-val [.ns file .syms])]
  ;;                                  mod-syms))
  ;;                 _ (sm/assoc-in-val [.ns curr-file-name .imports file] mod-syms)]
  ;;             mod-syms)
  ;;           (ev/abort-interp "Could not import module" (str "'" file "'") "at"
  ;;                            (ev/ast-location-str x)))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send modules compile-module file-path waiter root-dir proj-dir)
      waiter)))

(def repo-cloner (agent {}))

(defn clone-repo* [ast proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sh/command "/usr/bin/git" (list "clone" "--branch" branch
                                                  (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sh/command "/usr/bin/git"
                                            (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ;; ev/Evaluator
  ;; (ev/eval [ast]
  ;;   ;; Only called when interpreting a file (I think)
  ;;   (let [file (.file ast)]
  ;;     (either (and (-> file
  ;;                     seq
  ;;                     (some (partial = "/")))
  ;;                  (maybe (ev/abort-interp "For git dependencies,"
  ;;                                          "files may only be imported from root of repository,"
  ;;                                          file "is invalid.")))
  ;;             (comp (for [script-dir (sm/get-val .script-dir)
  ;;                         :let [clone-waiter (promise)
  ;;                               dep-path (do
  ;;                                          (clone-repo {} ast clone-waiter script-dir)
  ;;                                          (extract clone-waiter))
  ;;                               module-path (str dep-path "/" file)
  ;;                               _ (or (sys/access module-path)
  ;;                                     (do
  ;;                                       (print-err "Dependency file" file "missing from cloned repository"
  ;;                                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
  ;;                                       (abort)))]
  ;;                         curr-file-name (sm/get-val .file-name)
  ;;                         _ (sm/set-val .file-name module-path)
  ;;                         r (ev/eval (ast/module-ast file))
  ;;                         _ (sm/set-val .file-name curr-file-name)]
  ;;                     r)
  ;;                   (ev/abort-interp "Could not import module" (str "'" file "'") "from git repo at"
  ;;                                    (ev/ast-location-str ast))))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send modules compile-module module-path waiter (str dep-path "/") proj-dir)
        waiter))))

;; (extend-type ev/Thunk
;;   rd/RecursiveDescent
;;   (rd/recursive-descent [f]
;;     (wrap sm/zero-sm (fn [& rules]
;;                       (apply (wrap sm/zero-sm (fn [& parsed-values]
;;                                                 (apply f (remove parsed-values rd/ignore?))))
;;                               rules)))))

;; (extend-type ev/EvalState
;;   Emitter
;;   (encode-static [x]
;;     (for [args (ev/traverse (type-args x) encode-static)
;;           struct (global-var "cnstr_")
;;           var (global-var "cnstr_")
;;           _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
;;                       (str (count args)) (flat-map args (fn [expr]
;;                                                           [",(Value *)&" (.c-struct expr)]))
;;                       "};" line-sep
;;                       "Value *" var " = (Value *)&" struct ";" line-sep])
;;           expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
;;       expr)))

(extend-type ProtoDispatcher
  Emitter
  (encode-static [x]
    (for [args (sm/traverse (type-args x) encode-static)
          struct (global-var "cnstr_")
          var (global-var "cnstr_")
          _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
                      (str (count args)) (flat-map args (fn [expr]
                                                          [",(Value *)&" (.c-struct expr)]))
                      "};" line-sep
                      "Value *" var " = (Value *)&" struct ";" line-sep])
          expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
      expr))

  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (se/state-error (fn [& rules]
                      (apply (se/state-error (fn [& parsed-values]
                                               (apply f (remove parsed-values rd/ignore?))))
                             rules)))))

;; (extend-type sm/new-sm
;;   ev/Evaluator
;;   (ev/apply-fn [mv [state]]
;;     (wrap sm/zero-sm (mv state))))

;; (defn interpret-file [[_ option file-name & args]]
;;   (or (and (= "--script" option)
;;            (flat-map (or (sys/file-directory file-name)
;;                          (do
;;                            (print-err "Could not open file:" file-name)
;;                            (abort)))
;;                      (fn [script-dir]
;;                        (interp/interp-file
;;                         file-name script-dir
;;                         [(interp/CompiledNs 'file (either (get fio/symbols 'filename)
;;                                                           "")
;;                                             fio/symbols fio/protocols)
;;                          (interp/CompiledNs 'reader (either (get rdr/symbols 'filename)
;;                                                             "")
;;                                             rdr/symbols rdr/protocols)
;;                          (interp/CompiledNs 'grammar  (either (get grmr/symbols 'filename)
;;                                                               "")
;;                                             grmr/symbols grmr/protocols)
;;                          (interp/CompiledNs 'parse  (either (get rd/symbols 'filename)
;;                                                             "")
;;                                             rd/symbols rd/protocols)
;;                          (interp/CompiledNs 'ast  (either (get ast/symbols 'filename)
;;                                                           "")
;;                                             ast/symbols ast/protocols)
;;                          (interp/CompiledNs 'sys  (either (get sys/symbols 'filename)
;;                                                           "")
;;                                             sys/symbols sys/protocols)
;;                          (interp/CompiledNs 'state-maybe  (either (get sm/symbols 'filename)
;;                                                                   "")
;;                                             sm/symbols sm/protocols)
;;                          (interp/CompiledNs 'const  (either (get c/symbols 'filename)
;;                                                             "")
;;                                             c/symbols c/protocols)
;;                          (interp/CompiledNs 'shell  (either (get sh/symbols 'filename)
;;                                                             "")
;;                                             sh/symbols sh/protocols)
;;                          (interp/CompiledNs 'strm  (either (get strm/symbols 'filename)
;;                                                            "")
;;                                             strm/symbols strm/protocols)]
;;                         args))))
;;       (do
;;         (print-err "The only option for the compiler is '--script'")
;;         (maybe -1))))

(main [params]
  (either (and (< (count params) 2)
               (do
                 (print-err "A filename to compile must be provided.")
                 (maybe -1)))
          (let [[_ file-name] params
                waiter (promise)]
            (or (map (sys/file-directory file-name)
                     (fn [root-dir]
                       (write-strings ["\n#define _XOPEN_SOURCE 600"
                                       "\n#include <stdlib.h>"
                                       "\n#include \"core.h\"\n"])
                       (send modules compile-module file-name waiter root-dir root-dir)))
                (do
                  (print-err "Could not find " (str "'" file-name "'"))
                  (abort)))
            (extract waiter)
            (emit-main (extract waiter))
            ;; (send ast-emitter (fn [ctxt]
            ;;                     (map (get-in ctxt ['_ .constants .other])
            ;;                          (fn [counts]
            ;;                            (apply print-err (list* "\n" (interpose (map (seq counts)
            ;;                                                                          (fn [[k v]]
            ;;                                                                            (str k ": " v)))
            ;;                                                                    "\n")))
            ;;                            (print-err "number of types" type-count)))))
            ;; wait for agents to clear their queues
            (map-modules sm-nop)
            (let [waiter (promise)]
              (send string-writer (partial deliver waiter))
              (extract waiter)))))
