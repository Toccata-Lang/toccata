
;; TODO: a benchmark to implement
;; https://github.com/christianscott/levenshtein-distance-benchmarks

;; libs to implement
;; ZIO and associated
;; shpadoinkle https://gitlab.com/fresheyeball/Shpadoinkle/-/tree/master

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "54d3fc9"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "97c5572"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "4b6a964"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "e843c60"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "2978872"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "fa3764b"))
(add-ns typ (git-dependency "https://github.com/Toccata-Lang/eval.git"
                            "type-checker.toc"
                            :sha "e2567ba"))
(add-ns ev (git-dependency "https://github.com/Toccata-Lang/eval.git"
                           "eval.toc"
                           :sha "e2567ba"))
(add-ns interp (git-dependency "https://github.com/Toccata-Lang/eval.git"
                               "interpreter.toc"
                               :sha "e2567ba"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "75d8f9c"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "6378d02"))
(add-ns strm (git-dependency "https://github.com/Toccata-Lang/stream.git"
                             "stream.toc"
                             :sha "c778079"))
(add-ns sh (git-dependency "https://github.com/Toccata-Lang/shell-proc.git"
                           "shell-proc.toc"
                           :sha "5b7fbd4"))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def Tagged (any-of Symbol
                    ast/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-marker [file-name line-number marker]
  (cond (or (= "" file-name)
            (and (= 'core file-name)
                 (= 0 line-number)))
        "\n#\n"
        ["\n" marker "\n#line "
         (str line-number) " " "\""
         (cond (= 'core file-name)
               path-to-core
               file-name)
         "\"\n"]))

(defn line-macro [ast marker]
  (wrap sm/zero-sm (line-marker (ast/file-name ast) (ast/line-number ast) marker)))

(def type-names {c/IntegerType "Integer"
                 c/StringBufferType "String"
                 c/SubStringType "String"
                 c/FnArityType "FnArity"
                 c/FunctionType "Fn"
                 c/ListType "List"
                 c/MaybeType "Maybe"
                 c/VectorType "Vector"
                 c/VectorNodeType "VectorNode"
                 c/SymbolType "Symbol"
                 c/BitmapIndexedType "BitmapIndexNode"
                 c/ArrayNodeType "ArrayNode"
                 c/HashCollisionNodeType "HashCollisionNode"
                 c/HashSetType "Set"
                 c/PromiseType "Promise"
                 c/FutureType "Future"
                 c/AgentType "Agent"
                 c/OpaqueType "Opaque"
                 c/UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer c/IntegerType
                     'StringBuffer c/StringBufferType
                     'SubString c/SubStringType
                     'FnArity c/FnArityType
                     'Function c/FunctionType
                     'Fn c/FunctionType
                     'List c/ListType
                     'Maybe c/MaybeType
                     'Vector c/VectorType
                     'Symbol c/SymbolType
                     'BitmapIndexedNode c/BitmapIndexedType
                     'ArrayNode c/ArrayNodeType
                     'HashCollisionNode c/HashCollisionNodeType
                     'Promise c/PromiseType
                     'Future c/FutureType
                     'Agent c/AgentType
                     'Opaque c/OpaqueType
                     'TypeCount c/TypeCount})

(def fn-constraint (c/TypeConstraint {c/FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (c/TypeConstraint {c/SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (c/TypeConstraint {c/VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (c/TypeConstraint {c/ListType #{}} empty-list 'List nothing ""))
(def string-constraint (c/TypeConstraint {c/StringBufferType #{} c/SubStringType #{}}
                                         empty-list 'String nothing ""))
(def hashmap-constraint (c/TypeConstraint {c/BitmapIndexedType #{}
                                           c/ArrayNodeType #{}
                                           c/HashCollisionNodeType #{}}
                                          empty-list 'HashMap nothing ""))
(def int-constraint (c/TypeConstraint {c/IntegerType #{}} empty-list 'Integer nothing ""))
(def maybe-constraint  (c/TypeConstraint {c/MaybeType #{}} empty-list 'Maybe nothing ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map (wrap sm/zero-sm "") (fn [_]
                           (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l)))

  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  (emit-recursive-call [ast params]
    sm/zero-sm)

  ;; Mark this AST node as the final (or tail) expression in a function body
  ;; TODO: all tail expressions must gather the result constraint, etc
  (tail-call [_ params])

  ;; Unwrap the tail call
  (unwrap-tail [ast]
    ast)

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert (instance? (map-of ast/tagged-symbol ast/tagged-symbol) subs))
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    (assert (instance? (map-of ast/tagged-symbol ast/tagged-symbol) subs))

    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (wrap sm/zero-sm ast))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    sm/zero-sm)

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params bind-fn]
    (assert (instance? ast/params-ast params)))

  ;; bind fn parameters
  (bind-param [binding]
    (assert-result x (instance? sm/new-sm x)))
  (bind-param [binding expr]
    (assert-result x (instance? sm/new-sm x)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ subs]
    (assert (instance? (map-of String c/ValueConstraint) subs))
    (assert-result x (instance? sm/new-sm x)))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))

  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (encode [m var-prefix])

  (validate-field [c m fields file-name line-number]
    (assert (instance? c/ValueConstraint c))
    (assert (instance? (map-of Symbol c/ValueConstraint) m))
    (assert (instance? (vector-of Symbol) fields))
    (assert (instance? ast/SymbolOrString file-name))
    (assert (instance? Integer line-number))

    m)

  ;; encode a statically initialized representation of a core data structure
  ;; TODO: make sure every impl is needed and constrains the var properly
  (encode-static [m]
    (do
      (print-err 'could-not-encode (type-name m) m)
      sm/zero-sm))

  (runtime-check [constraint value-info file-name line-number checked-var]
    (assert (instance? ast/SymbolOrString file-name))
    (assert (instance? Integer line-number))
    (assert-result r (instance? Vector r))

    ;; generated code must preserve ref counts
    (cond (c/satisfied-by constraint value-info)
          []
          (runtime-check constraint value-info
                         (cond (= "" file-name)
                               ["\"\""]
                               ["\"at " file-name ": " line-number "\""])
                         checked-var)))

  (runtime-check [constraint value-info sym-location checked-var]
    (assert (instance? (any-of c/NoValues
                               c/ResultConstraint
                               c/ValueConstraint)
                       constraint))
    (assert (instance? c/ValueConstraint value-info))
    (assert (instance? String checked-var))
    (assert-result r (instance? Vector r)))

  (runtime-check [constraint value-info checked-var]
    (assert (instance? (any-of c/NoValues
                               c/ResultConstraint
                               c/ValueConstraint)
                       constraint))
    (assert (instance? c/ValueConstraint value-info))
    (assert (instance? String checked-var))
    (assert-result r (instance? Vector r))))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? String seq-c-var))
  (assert (instance? String dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype FnValPtr [var]
  ;; pointer to a Fn struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var struct]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(def CFnPtr (any-of StaticFnPtr
                    ProtoDispFnPtr))

(def PointerVar (any-of FnValPtr
                        ArityValPtr
                        CFnPtr))

(extend-type PointerVar
  Emitter
  (encode-static [x]
    (emit (.var x)))

  Stringable
  (string-list [x]
    (list (str (.var x))))

  Eq
  (=* [x y]
    (and (=* y (str (.var x)))
         (maybe x)))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? c/Constraints x)))

  (expr-constraints [expr new-const]
    (assert (instance? c/Constraints new-const))

    expr)

  (collapse-expressions* [x y]
    (assert-result r (instance? sm/new-sm r))))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init refs-map]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

(def empty-c-code (empty-code "" [] {}))

(deftype c-code [c-var init refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-reified [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Reified " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-constructor [c-var init refs-map constraints c-struct type-num fields]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Type-Constructor " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ", " (str type-num) ">")))

(deftype c-static-str [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-String " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-int [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Int " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-sym [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Symbol " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-vector-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Vector-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-maybe-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Maybe-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-list-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-List-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-protocol-fn [c-var init refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Protocol-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-arity [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "(c-static-arity " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ")")))

(deftype c-static-fn [c-var init refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "(c-static-fn " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) " " (str arities) ")")))

(deftype c-static-val [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Static-Value " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(extend-type c-code
  Emitter
  (encode-static [m]
    (do
      (print-err 'could-not-encode m)
      sm/zero-sm)))

(def C-Static-Value (any-of c-static-int
                            c-static-str
                            c-static-sym
                            c-static-reified
                            c-constructor
                            c-list-fn
                            c-maybe-fn
                            c-vector-fn
                            c-static-fn
                            c-static-arity
                            c-protocol-fn
                            c-static-val))

(extend-type C-Static-Value
  Emitter
  (encode-static [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init refs-map constraints file-name line-number]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

(deftype c-field [c-var init refs-map constraints parent]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? HashMap refs-map))
  (assert (instance? c/Constraints constraints))
  (assert (instance? String parent))

  Stringable
  (string-list [_]
    (list "<C-Field " (str c-var) ", "
          (str (count init)) ">"))

  Emitter
  (emit [x]
    (sm/state-maybe x))

  Collection
  (empty? [c] nothing))

(def C-Value (any-of c-code
                     c-param
                     C-Static-Value))

(extend-type C-Value
  Collection
  (empty? [c]
    (empty? (.init c)))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init refs-map file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-init', but specifically for anon closure functions
(deftype c-closure-fn [c-var init refs-map arities file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Closure " (str c-var) ", "
          (str (count init)) ", " (str refs-map) " " (str arities) ">"))

  Collection
  (empty? [c] nothing))


(def C-expr (any-of empty-code
                    C-Value
                    c-param
                    c-closure-fn
                    c-init))

(def BindingValue (any-of C-expr
                          c-field))

(defn collapse-expressions [cs]
  (assert (instance? (sequence-of BindingValue)
                     cs))
  (assert-result r (instance? sm/new-sm r))

  (either (or (and (empty? cs)
                   (maybe (sm/state-maybe empty-c-code)))
              (and (empty? (rest cs))
                   (map (first cs) sm/state-maybe)))
          (let [[c & cs] cs]
            (flat-map (collapse-expressions cs)
                      (fn [expr]
                        (collapse-expressions* c expr))))))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (sm/state-maybe y)))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))
                         c-var (.c-var x)
                         file-name (.file-name x)
                         line-number (.line-number x)
                         init [(.init x)
                               (either (or (for [refs (get-in y [.refs-map c-var])]
                                             [(cond (< refs 2)
                                                    ""
                                                    ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                                           (= "" c-var))
                                       [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                               (.init y)]
                         refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                                          c-var)]
                     (-> y
                         (.init init)
                         (.refs-map refs-map)))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          init [(.init x)
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(cond (< refs 2)
                                     ""
                                     ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]]
      (-> (cond (instance? empty-code y)
                (c-code "" [] {} c/top-type)
                y)
          (.init init)
          (.refs-map refs-map)
          sm/state-maybe))))

(extend-type c-closure-fn
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))
                         c-var (.c-var x)
                         file-name (.file-name x)
                         line-number (.line-number x)
                         init [(.init x)
                               (either (or (for [refs (get-in y [.refs-map c-var])]
                                             [(cond (< refs 2)
                                                    ""
                                                    ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                                           (= "" c-var))
                                       [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                               (.init y)]
                         refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                                          c-var)]
                     (-> y
                         (.init init)
                         (.refs-map refs-map)))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(cond (< refs 2)
                                     ""
                                     ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)]
      (-> (cond (instance? empty-code y)
                (c-code "" [] {} c/top-type)
                y)
          (.init init)
          (.refs-map refs-map)
          sm/state-maybe))))

(extend-type C-Value
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> (cond (instance? empty-code y)
                               x
                               y)
                         (.init [(.init x) (.init y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [x (cond (empty? (.init x))
                  (.refs-map x {})
                  x)]
      (-> (cond (instance? empty-code y)
                (c-code "" [] {} c/top-type)
                y)
          (.init [(.init x) (.init y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          sm/state-maybe))))

(deftype StaticArityInfo [c-var param-constraints result-constraint]
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? CFnPtr c-var))

  Stringable
  (string-list [_]
    (list "(StaticArityInfo " (str c-var) " " (str param-constraints) " "
          (str result-constraint)  ")")))

(deftype Closures [closures refs-map]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map)))

(def empty-closures (Closures [] {}))

(deftype ConstantValues [numbers strings symbols type-names encoded other]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names))
  ;; encoded                cache of values that have been statically encoded
  (assert (instance? HashMap encoded)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over decl subs field-constrs]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; C code to declare stuff needed for fn arity
  (assert (instance? Vector decl))
  ;; Substitutions for checking types
  (assert (instance? (vector-of (map-of String c/ValueConstraint)) subs))
  ;; constraints for fields in type-ast implementations
  (assert (instance? (maybe-of c/ItemsConstraint) field-constrs))


  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols declarations ns-syms types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))
  ;; imported namespaces
  (assert (instance? HashMap ns-syms))
  ;; types            map of symbols (type names) to type constraints
  (assert (instance? (map-of Symbol c/ValueConstraint) types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
;; TODO: might be able to remove the 'fns' field
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-counter]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? (map-of ast/SymbolOrString Module) modules))
  ;; fns                    static functions
  (assert (instance? (map-of String StaticArityInfo) fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))
  ;; number of types defined
  (assert (instance? Integer type-counter))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn var-type-num [var]
  (map (sm/get-in-val [.fn-context .subs])
       (fn [subs]
         (let [type-nums (-> subs
                             (reduce {} (fn [m sub]
                                          (let [c (either (get sub var)
                                                          c/top-type)
                                                tm (either (c/extract-type-map c)
                                                           {})]
                                            (comp m tm))))
                             keys)]
           (either (and (= 1 (count type-nums))
                        (first type-nums))
                   c/UnknownType)))))

(defn declare [new-decl]
  (sm/update-in-val [.fn-context .decl] (fn [decl]
                                          (conj decl new-decl))))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      subs (either (get-in curr-fn-context [.subs 0])
                                   {})
                      new-context (reduce (seq (.syms curr-fn-context))
                                          (.context-syms curr-fn-context)
                                          (fn [syms [sym expr]]
                                            (assoc syms sym
                                                   (expr-constraints expr (either (get subs (.c-var expr))
                                                                                  c/top-type)))))]
                  (maybe [(.decl curr-fn-context [])
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures
                                                               (.decl curr-fn-context) [{}]
                                                               (.field-constrs curr-fn-context)))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.decl (.fn-context s) [])
                        (.fn-context s (-> new-fn-context
                                           (.field-constrs (-> s .fn-context .field-constrs))
                                           (.decl (comp (.decl (.fn-context s))
                                                        (.decl new-fn-context)))))])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (ast/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (ast/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str (list* start (seq remaining))))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(defprotocol ConstrainParams
  (constrain-params [pb]))

(deftype ParamBinding [bound vars tail-var destruct]
  (assert (instance? Vector destruct))

  ConstrainParams
  (constrain-params [pb]
    (cond
     (and (empty? vars)
          (= tail-var ""))
     (typ/get-constraint bound)

     (for [tail-const (typ/get-constraint tail-var)
           items-const (typ/traverse vars constrain-params)
           :let [constraint (c/ItemsConstraint items-const tail-const empty-list nothing tail-var)]
           _ (typ/append-constraint bound constraint "" 0)]
       constraint)))

  Stringable
  (string-list [_]
    (cond
     (and (empty? vars)
          (= tail-var ""))
     (list bound)

     (empty? vars)
     (list "[|" tail-var "]")

     (list (str (comp vars [(str "| " tail-var)]))))))


;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" arg-name)))))
  ([sym arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" (either (check-C-var (str sym "_"))
                                                  arg-name)))))))


(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraint c-fn]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? CFnPtr c-fn))

  ;; TODO: remove these eventually
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) " "
                         (str c-fn) ">"))

  Emitter
  (encode [x]
    (encode-static x))

  (encode-static [_]
    (cond (= "" (.var c-var))
          (do
            (print-err 'could-not-encode 'ProtoImpl)
            (maybe sm/zero-sm))
          (wrap sm/zero-sm (c-static-val (str "(Value *)" c-var) [] {} (.struct c-var))))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in m(odule at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [protos (get-in s [.modules path .protocols])
                     _ (some (vals protos) (fn [proto] (get proto (ast/untag fn-sym))))]
                 [path s]))))

(defn find-protocol-path [fn-sym]
  (comp (for [path (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym path)]
          path)
        (lookup-protocol-path fn-sym 'core)))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype CollectFieldConsts [fields ast]
  (assert (instance? ast/params-ast fields))

  Stringable
  (string-list [_]
    (list "<CollectFieldConsts" (str fields) "\n" (str ast) ">"))

  Emitter
  (emit [_]
    (for [expr (emit ast)
          sub (sm/get-in-val [.fn-context .subs 0] {})
          field-constrs (get-param-constraints fields sub)
          curr-constrs (sm/get-in-val [.fn-context .field-constrs])
          :let [field-constrs (either (map curr-constrs (fn [curr]
                                                          (either (c/compose-constraints
                                                                   (ast/file-name ast)
                                                                   (ast/line-number ast)
                                                                   field-constrs curr)
                                                                  (abort))))
                                      field-constrs)]
          _ (sm/assoc-in-val [.fn-context .field-constrs] (maybe field-constrs))]
      expr))

  (unwrap-tail [_]
    ast)

  (tail-call [x params]
    (CollectFieldConsts fields (tail-call ast params)))

  (replace-syms [_ subs]
    (map (replace-syms ast subs)
         (partial CollectFieldConsts fields)))

  (replace-bound-vars [_ subs]
    (CollectFieldConsts fields (replace-bound-vars ast subs))))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraint c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? ArityValPtr var))
  (assert (instance? CFnPtr c-fn))

  (let [ast (unwrap-tail ast)
        new-impl (ProtoImpl dispatch-type var ast param-constraints result-constraint c-fn)]
    (for [protocol-path (find-protocol-path fn-sym)
          _  (comp (sm/update-in-val [.modules protocol-path .protocols (ast/untag proto-sym) (ast/untag fn-sym)]
                                     (fn [p-disp]
                                       (assert (instance? ev/ProtoDispatcher p-disp))
                                       (assoc-in p-disp [.p-impls arg-count dispatch-type] new-impl)))
                   (compilation-error "Compiler Error: missing proto dispatcher" protocol-path proto-sym fn-sym))]
      "")))

(defn verify-proto-name [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (comp (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (or (let [path (either (extract-sym-path s proto-sym)
                                            (ast/file-name proto-sym))]
                           (for [proto-info (-> (.modules s)
                                                (get path)
                                                (flat-map (fn [module]
                                                            (get (.protocols module) (ast/untag proto-sym)))))]
                             [proto-info s]))
                         (for [proto-info (-> (.modules s)
                                              (get 'core)
                                              (flat-map (fn [module]
                                                          (get (.protocols module) (ast/untag proto-sym)))))]
                           [proto-info s]))))
        (compilation-error "Invalid protocol:" proto-sym "in"
                           (str (ast/file-name proto-sym) ",")
                           (ast/line-number proto-sym))))

;; TODO: it feels like these 2 arities are too different
(defn get-proto-impl
  ([fn-sym arg-count type-num]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (or (let [proto-path (either (extract-sym-path s fn-sym)
                                             (ast/file-name fn-sym))]
                      (for [protocols (get-in s [.modules proto-path .protocols])
                            impl-info (some (vals protocols)
                                            (fn [dispatchers]
                                              (get-in dispatchers [(ast/untag fn-sym) .p-impls
                                                                   arg-count type-num])))]
                        [impl-info s]))
                    (for [protocols (get-in s [.modules 'core .protocols])
                          impl-info (some (seq protocols)
                                          (fn [[proto-name dispatchers]]
                                            (get-in dispatchers [(ast/untag fn-sym) .p-impls
                                                                 arg-count type-num])))]
                      [impl-info s])))))
  ([proto-sym fn-sym arg-count type-num]
   (flat-map (sm/new-sm (fn [s]
                          (maybe [(either (extract-sym-path s proto-sym)
                                          (ast/file-name proto-sym))
                                  s])))
             (fn [proto-path]
               (comp (sm/get-in-val [.modules proto-path .protocols (ast/untag proto-sym) (ast/untag fn-sym)
                                     .p-impls arg-count type-num])
                     (sm/get-in-val [.modules 'core .protocols (ast/untag proto-sym) (ast/untag fn-sym)
                                     .p-impls arg-count type-num])
                     ;; (compilation-error "Invalid protocol fn:"
                     ;;                    (str "'" fn-sym "' in")
                     ;;                    (str (ast/file-name fn-sym) ",")
                     ;;                    (ast/line-number fn-sym))
                     )))))

(def DefExprs (any-of c-code
                      c-static-reified
                      c-constructor
                      c-static-str
                      c-static-int
                      c-static-fn
                      c-static-sym
                      c-maybe-fn
                      c-list-fn
                      c-vector-fn
                      c-protocol-fn))

(defn new-module-def [sym value]
  (assert (instance? ast/tagged-symbol sym))
  (assert (instance? DefExprs value))

  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  ;; (sm/assoc-in-val [.fn-context .syms sym] expr)
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn find-global-sym [sym]
  ;; Attempt to look up the global (ie. not closed over) value given a symbol.
  (for [ns-path (sym-ns-path sym)
        expr (sm/get-in-val [.modules ns-path .values sym])]
    expr))

(defn update-subs [f]
  (assert (instance? typ/new-sv f))

  (for [subs (sm/get-in-val [.fn-context .subs] [])
        :let [_ (and (empty? subs)
                     (maybe (do
                              (print-err "Compiler error, no constraints found")
                              (abort))))
              new-subs (map (flat-map subs f) (fn [[_ s]] s))
              new-subs (cond (empty? new-subs)
                             (do
                               (print-err "Compiler error, no new constraints found")
                               (abort))
                             new-subs)]
        _ (sm/assoc-in-val [.fn-context .subs] new-subs)]
    '_))

(defn constrain-var [file-name line-number var constraint]
  (cond (or (= "" var)
            (instance? c/AllValues constraint))
        (wrap sm/zero-sm '_)

        (update-subs
         (typ/append-constraint var constraint file-name line-number))))

(defn lookup-closure-sym [sym]
  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (for [sym-info (sm/get-in-val [.fn-context .context-syms sym])
          closures (sm/get-in-val [.fn-context .closed-over .closures])
          expr (either (some closures
                             (fn [[closure-var sym-literal constraint]]
                               (for [_ (= sym sym-literal)]
                                 ;; already added to closures
                                 (map (sm/update-in-val [.fn-context .closed-over .refs-map closure-var]
                                                        inc)
                                      (fn [_]
                                        (c-code closure-var [] {closure-var 1} constraint))))))
                       ;; first time sym is closed over
                       (for [sym-count (sm/get-in-val [.fn-context .sym-count])
                             _ (sm/update-in-val [.fn-context .sym-count] inc)
                             :let [constraint (expr-constraints sym-info)
                                   closure-var (str "val" sym-count)]
                             _ (sm/update-in-val [.fn-context .closed-over .closures]
                                                 (fn [closures]
                                                   (conj closures [closure-var sym constraint])))
                             _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var]
                                                1)]
                         (c-code closure-var [] {closure-var 1} constraint)))]
      expr)))

(defn lookup-sym [sym]
  (assert (instance? ast/tagged-symbol sym))

  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (for [expr (comp (for [ns-sym (sm/when (ast/namespace sym))
                           ;; lookup namespace-qual sym
                           expr (comp (sm/get-in-val [.modules file-name .ns-syms
                                                      (ast/tag ns-sym) (ast/tag (.base sym))])
                                      (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                                         (str file-name ":") line-number))]
                       expr)

                     ;; lookup sym in local fn context
                     (sm/get-in-val [.fn-context .syms sym])

                     ;; lookup symbol in enclosing context of fn
                     (lookup-closure-sym sym)

                     ;; lookup in module
                     (sm/get-in-val [.modules file-name .values sym])
                     (sm/get-in-val [.modules file-name .declarations sym '_])

                     ;; lookup in core module
                     (sm/get-in-val [.modules 'core .values sym])
                     (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                                        (str file-name ":") (ast/line-number sym)))
          _ (comp (constrain-var file-name line-number (.c-var expr) (expr-constraints expr))
                  (sm/state-maybe '_))

          constraint (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)]
      (expr-constraints expr constraint))))

(extend-type c-field
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (print-err 'c-field 'comp*)
    (abort)
    empty-c-code)

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (either (for [refs (get-in y [.refs-map (.c-var x)])
                  _ (< 0 refs)]
              (-> y
                  (.init [(.init x)
                          "incRef(" (.c-var x) ", " (str refs) ");\n"
                          ;; TODO: it would be nice to remove the need for this dec_and_free
                          ;; do just one after all needed fields are extracted
                          "dec_and_free(" (.parent x) ", 1);\n"
                          (.init y)])
                  (.refs-map (merge-with + {(.parent x) 1}
                                         (dissoc (.refs-map y) (.c-var x))))
                  sm/state-maybe))
            (sm/state-maybe y))))

(extend-type c/Constraints
  Emitter
  (encode-static [x]
    ;; TODO: for some reason, encoding the sym doesn't alwys work,
    ;; fortunately, it's not needed

    (cond (= c/top-type x)
          (sm/state-maybe (c-static-val "all_values" [] {} "all_values_struct"))
          
          (let [x (either (map (instance? c/SymbolConstraints x)
                               (fn [x]
                                 (-> x
                                     (.var "")
                                     (.sym nothing))))
                          x)]
            (comp (for [args (ev/traverse (type-args x) encode-static)
                        struct (global-var "cnstr_")
                        var (global-var "cnstr_")
                        _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
                                    (str (count args)) (flat-map args (fn [expr]
                                                                        [",(Value *)&" (.c-struct expr)]))
                                    "};" line-sep
                                    "Value *" var " = (Value *)&" struct ";" line-sep])
                        expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
                    expr)
                  ;; TODO remove
                  (for [_ (debug 'missing x)
                        :when nothing]
                    '_))))))

(extend-type c/StaticConstraints
  Emitter
  (runtime-check [constraint value-info checked-var]
    [])

  (runtime-check [constraint value-info sym-location checked-var]
    []))

(extend-type c/NoValues
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["abort();\n#\n"])

  (runtime-check [constraint value-info sym-location checked-var]
    ["abort();\n#\n"]))

(extend-type c/AllValues
  Emitter
  (emit [constraint]
    (wrap sm/zero-sm empty-c-code))

  (replace-syms [constraint _]
     (wrap sm/zero-sm constraint))

  (runtime-check [constraint value-info checked-var]
    [])

  (runtime-check [constraint value-info sym-location checked-var]
    []))

(defn get-type-sym-info [type-symbol]
  (assert (instance? ast/tagged-symbol type-symbol))

  (comp (for [ns-path (sym-ns-path type-symbol)
              constraint (comp (sm/get-in-val [.modules 'core .types (ast/untag type-symbol)])
                               (sm/get-in-val [.modules ns-path .types (ast/untag type-symbol)]))]
          constraint)
        (compilation-error "Invalid type" (str "'" type-symbol "'") "at"
                           (ast/file-name type-symbol) (ast/line-number type-symbol))))

(defn emit-sym-constraint [constraint]
  (let [file-name (ast/file-name constraint)
        line-number (ast/line-number constraint)]
    (either (for [_ (= "" (c/extract-var constraint))
                  sym (c/extract-sym constraint)]
              (for [expr (lookup-sym (ast/tag sym file-name line-number))
                    _ (constrain-var file-name line-number (.c-var expr) constraint)
                    checked-var (genlocal 'checked)]
                (cond (instance? c-param expr)
                      empty-c-code
                      (c-code (.c-var expr)
                              (let [rt-check (runtime-check (c/update-var constraint (.c-var expr))
                                                            c/top-type file-name line-number
                                                            checked-var)]
                                (either (empty? rt-check)
                                        [line-sep "if(1){int " checked-var " = 1;" line-sep
                                         rt-check
                                         line-sep "if(!" checked-var "){abort();}}" line-sep]))
                              {} c/top-type))))
            (map (constrain-var file-name line-number
                                (c/extract-var constraint) constraint)
                 (fn [_]
                   empty-c-code)))))

;; TODO: how many of these impls would work for ValueConstraint
(extend-type c/SymbolConstraints
  Emitter
  (validate-field [c m fields file-name line-number]
    (either (map (.sym c)
                 (fn [c-sym]
                   (either (some fields (partial = c-sym))
                           (do
                             (print-err "Invalid field"
                                        (str "'" c-sym "'")
                                        "at:" (str file-name ":")
                                        line-number)
                             (abort)))
                   (-> m
                       (dissoc c-sym)
                       (assoc c-sym (either (c/compose-constraints file-name line-number
                                                                   c
                                                                   (either (get m c-sym)
                                                                           c/top-type))
                                            (abort))))))
            m))

  (tail-call [constraint _]
    constraint)

  (replace-bound-vars [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs (ast/tag old-sym))]
              (c/update-sym constraint (ast/untag new-sym)))
            constraint))

  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs (ast/tag old-sym))]
              (wrap sm/zero-sm (cond (instance? Tagged new-sym)
                                     (c/update-sym constraint (ast/untag new-sym))
                                     c/top-type)))
            (wrap sm/zero-sm constraint)))

  (emit [constraint]
    (emit-sym-constraint constraint)))

(extend-type c/ItemsConstraint
  Emitter
  (promote-inferred [c]
    (-> c
        (.tail-constraint (promote-inferred (.tail-constraint c)))
        (.items-constraints (map (.items-constraints c) promote-inferred))))

  (replace-syms [ast subs]
    (for [new-items (ev/traverse (.items-constraints ast) (fn [c]
                                                            (replace-syms c subs)))
          new-tail (replace-syms (.tail-constraint ast) subs)
          new-sym (either (map (.sym ast) (fn [sym]
                                            (map (replace-syms sym subs)
                                                 (fn [new-sym]
                                                   (maybe (ast/untag new-sym))))))
                          (sm/state-maybe nothing))]
      (c/ItemsConstraint new-items new-tail (.path ast) new-sym (.var ast))))

  (runtime-check [constraint value-info checked-var]
    (cond (or (c/satisfied-by constraint value-info)
              (empty? (c/extract-items-constraints constraint)))
          []

          [(let [rt-check (-> (c/TypeConstraint {c/ListType #{} c/VectorType #{}} (.path constraint) 'Sequence
                                                (.sym constraint) (.var constraint))
                              (runtime-check value-info checked-var))]
             (either (empty? rt-check)
                     ["if (" checked-var "){" rt-check "}"]))
           (let [min-count (str (count (c/extract-items-constraints constraint)))]
             ["if (" checked-var " && countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
              checked-var "= 0;" line-sep "}"])
           (let [items (map (range (inc (count (c/extract-items-constraints constraint))))
                            (partial str (.var constraint) "_"))
                 rt-checks (for [[constraints item] (zip-lists (c/extract-items-constraints constraint) items)]
                             (let [constraints (either (map (.sym constraint) (fn [sym]
                                                                                (c/update-sym constraints sym)))
                                                       constraints)]
                               (-> constraints
                                   (c/update-var item)
                                   (runtime-check value-info checked-var))))]
             (cond (every rt-checks empty?)
                   []

                   ["if (" checked-var ") {" line-sep
                    "incRef(" (.var constraint) ", 1);" line-sep
                    (destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                    rt-checks
                    "if (" checked-var "){"
                    (map items (fn [item]
                                 (str "dec_and_free(" item ", 1);" line-sep)))
                    "}}"]))
           line-sep]))

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (or (c/satisfied-by constraint value-info)
              (empty? (c/extract-items-constraints constraint)))
          []

          [(let [rt-check (-> (c/TypeConstraint {c/ListType #{} c/VectorType #{}} (.path constraint) 'Sequence
                                                (.sym constraint) (.var constraint))
                              (runtime-check value-info sym-location checked-var))]
             (either (empty? rt-check)
                     ["if (" checked-var "){" rt-check "}"]))
           (let [min-count (str (count (c/extract-items-constraints constraint)))]
             ["if (" checked-var " && countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
              ;; "\n#ifndef EMBEDDED\n"
              "fprintf(stderr, \"Insufficient values for '"
              (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
              "fprintf(stderr, \"Needed " min-count
              ", got %\" PRId64 \"\\n\", ((Integer *)count((List *)0, "
              (.var constraint) "))->numVal);" line-sep
              "fprintf(stderr, \"" (interpose (c/format-path constraint (inc (count (.path constraint))))
                                              "\\n")
              "\\n\");"
              ;; "\n#endif\n"
              checked-var "= 0;" line-sep "}"])
           (let [items (map (range (inc (count (c/extract-items-constraints constraint))))
                            (partial str (.var constraint) "_"))
                 rt-checks (for [[constraints item] (zip-lists (c/extract-items-constraints constraint) items)]
                             (let [constraints (either (map (.sym constraint) (fn [sym]
                                                                                (c/update-sym constraints sym)))
                                                       constraints)]
                               (-> constraints
                                   (c/update-var item)
                                   (runtime-check value-info sym-location checked-var))))]
             (either (map (every rt-checks empty?) (fn [_] []))
                     ["if (" checked-var ") {" line-sep
                      "incRef(" (.var constraint) ", 1);" line-sep
                      (destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                      rt-checks
                      "if (" checked-var "){"
                      (map items (fn [item]
                                   (str "dec_and_free(" item ", 1);" line-sep)))
                      "}}"]))
           line-sep])))

(extend-type c/InferredInner
  Emitter
  (promote-inferred [c]
    (c/extract-coll-constraint c))

  (runtime-check [constraint value-info checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check
                     line-sep "}"]))))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type sym-location checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"])))))

(extend-type c/CollectionOf
  Emitter
  (promote-inferred [c]
    (.contents c (promote-inferred (.contents c))))

  (emit [constraint]
    (flat-map (to-constraint constraint)
              emit-sym-constraint))

  (to-constraint [c]
    (map (to-constraint (.contents c))
         (partial .contents c)))

  (runtime-check [constraint value-info checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"]))))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Only checking the inside of Maybe values
    ;; Not worth the cost to check this at runtime for Lists/Vectors
    ;; Maybe add some kind of feature flag to do this
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check (-> constraint
                                            .contents
                                            (c/update-var "inner_value"))
                                        c/top-type sym-location checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var " && "
                     (.var constraint) "->type == MaybeType && !isNothing(" (.var constraint) ", \"\", 0)) {"
                     "Value *inner_value = " (str "((Maybe *)" (.var constraint) ")->value") ";" line-sep
                     line-sep rt-check line-sep "}"])))))

(extend-type c/TypeConstraint
  Emitter
  (to-constraint [ast]
    (cond (empty? (.type-maps ast))
          (map (get-type-sym-info (ast/tag (.type-sym ast)))
               (fn [constraint]
                 (-> (either (map (.sym ast)
                                  (partial c/update-sym constraint))
                             constraint)
                     (c/update-var (.var ast))
                     (c/replace-path (.path ast)))))

          (wrap sm/zero-sm ast)))

  (emit [ast]
    (let [untagged (ast/untag (.type-sym ast))]
      (comp (for [ns-path (sym-ns-path (.type-sym ast))
                  ;; TODO: perhaps use 'to-constraint' here
                  constraint (cond (empty? (.type-maps ast))
                                   (comp (sm/get-in-val [.modules 'core .types untagged])
                                         (sm/get-in-val [.modules ns-path .types untagged]))
                                   (sm/state-maybe ast))
                  expr (-> (either (map (c/extract-sym ast) (fn [sym]
                                                              (c/update-sym constraint sym)))
                                   (c/clear-sym constraint))
                           (c/update-var (c/extract-var ast))
                           (c/update-path (ast/file-name ast) (ast/line-number ast))
                           (emit-sym-constraint))]
              expr)
            (compilation-error "Unknown type" (str "'" (.type-sym ast) "'") "at"
                               (str (ast/file-name ast) ":") (ast/line-number ast)))))

  (runtime-check [constraint value-info checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          ["if (" checked-var "){"
           "switch (" (.var constraint) "->type) {" 
           (map (keys (.type-maps constraint)) (fn [type-num]
                                                 ["case " type-num ": " ]))
           "break;\ndefault:"
           checked-var " = 0;}}"]))

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var "){"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Invalid type of value for '"
                     (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Needed " (str (.type-sym constraint))
                     ", got %s\\n\", extractStr(type_name((List *)0, " (.var constraint) ")));" 
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MaxValue
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["if (" checked-var " && "
     (str (.max constraint)) " < ((Integer *)" (.var constraint) ")->numVal) {"
     checked-var " = 0;}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var ") {"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
                     "' is too large %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Maximum allowed value is " (str (.max constraint))
                     ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MinValue
  Emitter
  (runtime-check [constraint value-info checked-var]
    ["if (" checked-var " && "
     (str (.min constraint)) " > ((Integer *)" (.var constraint) ")->numVal) {"
     checked-var " = 0;}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if (!" checked-var ") {"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
                     "' is too small %s\\n\", " sym-location ");" line-sep
                     "fprintf(stderr, \"Minimum allowed value is " (str (.min constraint))
                     ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/FieldConstraint
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (let [sym (ast/tag sym)]
                     (for [sym-info (lookup-sym sym)
                           field-var (lookup-sym (ast/tag (.field constraint)))
                           _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                            (.c-var sym-info) (.field-var constraint (.c-var field-var)))]
                       (.refs-map sym-info (dissoc (.refs-map sym-info) (.c-var sym-info)))))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info checked-var]
    ["if(" checked-var ") {\n"
     "Value *dork = hasField((List *)0, incRef(" (.var constraint) ", 1), "
     (.field-var constraint) ");\n" "if (isNothing(dork,\"\",0)) {"
     checked-var " = 0;}" line-sep
     "dec_and_free(dork, 1);}"])

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (c/satisfied-by constraint value-info)
          []

          (let [rt-check (runtime-check constraint value-info checked-var)]
            (either (empty? rt-check)
                    ["if (" checked-var "){"
                     rt-check
                     "if(!" checked-var ") {\n"
                     ;; "\n#ifndef EMBEDDED\n"
                     "fprintf(stderr, \"Value '" (either (.sym constraint) "<unknown>")
                     "' of type '%s' does not have field '"
                     (.field constraint) "' %s\\n\", extractStr(type_name((List *)0, "
                     (.var constraint) ")), " sym-location ");" line-sep 
                     "fprintf(stderr, \""
                     (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
                     "\\n\");"
                     ;; "\n#endif\n"
                     "}}"])))))

(extend-type c/MultiConstraint
  Emitter
  (tail-call [constraint _]
    constraint)

  (promote-inferred [c]
    (.constraints c (map (.constraints c) promote-inferred)))

  (validate-field [c m fields file-name line-number]
    (either (for [first-c (first (.constraints c))
                  c-sym (c/extract-sym first-c)]
              (do
                (either (some fields (partial = c-sym))
                        (do
                          (print-err "Invalid field"
                                     (str "'" c-sym "'")
                                     "at:" (str file-name ":")
                                     line-number)
                          (abort)))
                (-> m
                    (dissoc c-sym)
                    (assoc c-sym (either (c/compose-constraints file-name line-number
                                                                c
                                                                (either (get m c-sym)
                                                                        c/top-type))
                                         (abort))))))
            m))

  (replace-bound-vars [constraint subs]
    (.constraints constraint
                  (map (.constraints constraint) (fn [c]
                                                   (replace-bound-vars c subs)))))

  (replace-syms [ast subs]
    (for [new-cs (ev/traverse (.constraints ast) (fn [c]
                                                   (replace-syms c subs)))]
      (.constraints ast new-cs)))

  (runtime-check [constraint value-info checked-var]
    (cond (or (some (.constraints constraint)
                    (partial instance? c/StaticConstraints))
              (c/satisfied-by constraint value-info))
          []

          (map (.constraints constraint)
               (fn [c]
                 (runtime-check c value-info checked-var)))))

  (runtime-check [constraint value-info sym-location checked-var]
    (cond (or (some (.constraints constraint)
                    (partial instance? c/StaticConstraints))
              (c/satisfied-by constraint value-info))
          []

          (map (.constraints constraint)
               (fn [c]
                 (runtime-check c value-info sym-location checked-var)))))

  (to-constraint [ast]
    (map (ev/traverse (.constraints ast) to-constraint)
         (partial .constraints ast)))

  (emit [constraint]
    (map (ev/traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type c/ResultConstraint
  Emitter
  (replace-bound-vars [constraint subs]
    (replace-bound-vars (.assertion constraint) subs))

  (replace-syms [constraint subs]
    (sm/state-maybe constraint))

  (tail-call [constraint _]
    constraint)

  (emit [ast]
    (-> ast .assertion (c/update-var "#result") emit))

  (runtime-check [constraint value-info sym-location checked-var]
    ;; Handled other places
    [])

  (to-constraint [ast]
    (to-constraint (.assertion ast))))

(extend-type Maybe
  Emitter
  (encode-static [v]
    (comp (sm/get-in-val [.constants .encoded v])
          (either (map v (fn [v]
                           (for [_ (debug 'encoding-maybe v (sha1 v))
                                 expr (encode-static v)
                                 struct (global-var "maybe_")
                                 var (global-var "maybe_")
                                 _ (declare ["Maybe " struct " = (Maybe){MaybeType, -2, 0, (Value *)&"
                                             (.c-struct expr) "};" line-sep
                                             "Maybe *" var " = &" struct ";" line-sep])
                                 _ (sm/assoc-in-val [.constants .encoded v] (c-static-val var [] {} struct))]
                             (do
                               ;; TODO: we need to encode the constraints on 'var' as well
                               (comp expr
                                     (c-static-val var [] {} struct))))))
                  (wrap sm/zero-sm
                        (c-static-val "nothing" [] {} "nothing_struct"))))))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str))

  Emitter
  (encode-static [l]
    (comp (sm/get-in-val [.constants .encoded l])
          (either (map (first l)
                       (fn [head]
                         (for [tail-expr (encode-static (rest l))
                               head-expr (encode-static head)
                               struct (global-var "list_")
                               var (global-var "list_")
                               _ (declare ["List " struct " = {ListType, -2, 0, " (str (count l))
                                           ", (Value *)&" (.c-struct head-expr)
                                           ", &" (.c-struct tail-expr) "};" line-sep])
                               _ (sm/assoc-in-val [.constants .encoded l] (c-static-val var [] {} struct))]
                           (comp tail-expr
                                 head-expr
                                 (c-static-val var [] {} struct)))))
                  (wrap sm/zero-sm
                        (c-static-val "empty_list" [] {} "empty_list_struct")))))

  (unwrap-tail [asts]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (unwrap-tail tail)
                    (cons init)
                    reverse)))))
  
  (tail-call [asts args]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args)
                    (cons init)
                    reverse))))))

(defn encodeVectorInfo [v]
  (inline C Vector "
  Vector *v = (Vector *)v_0;

  Vector *array = empty_vect;
  for (int i = 0; i < v->count; i++) {
    Value *val = v->tail[i];
    incRef(val, 1);
    array = mutateVectConj(array, val);
  }

  Vector *result = empty_vect;
  result = mutateVectConj(result, integerValue(v->shift));
  result = mutateVectConj(result, integerValue(v->tailOffset));
  if (v->root != (VectorNode *)0) {
    fprintf(stderr, \"Encode Vector root\\n\");
    abort();
  } else {
    result = mutateVectConj(result, nothing);
  }
  result = mutateVectConj(result, (Value *)array);

  dec_and_free(v_0, 1);
  return((Value *)result);
  "))

(def vector-array-len (inline C Integer "(Value *)&(Integer){IntegerType,-2,VECTOR_ARRAY_LEN}"))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str))

  Emitter
  (replace-syms [v subs]
    (sm/traverse v (fn [x]
                     (replace-syms x subs))))

  (encode-static [v]
    (comp (sm/get-in-val [.constants .encoded v])
          (let [[shift offset root array] (encodeVectorInfo v)]
            (for [items (ev/traverse array encode-static)
                  root (either (map root encode-static)
                               (wrap sm/zero-sm (c-static-val "NULL" [] {} "NULL")))
                  struct (global-var "vect_")
                  var (global-var "vect_")
                  _ (declare ["Vector " struct " = {VectorType, -2, 0, "
                              (str (count array))
                              ", " (str shift) ", " (str offset) ", "
                              (.c-struct root)
                              (map items
                                   (fn [expr]
                                     (str ", (Value *)&" (.c-struct expr))))
                              (map (range (- vector-array-len (count array))) (fn [_] ", 0"))
                              "};" line-sep
                              "Value *" var " = (Value *)&" struct ";" line-sep])
                  expr (collapse-expressions (comp items [(c-static-val var [] {} struct)]))
                  _ (sm/assoc-in-val [.constants .encoded v] expr)]
              expr))))

  (unwrap-tail [asts]
    (either (flat-map (last asts)
                      (fn [tail]
                        (store asts (dec (count asts))
                               (unwrap-tail tail))))
            asts))

  (tail-call [asts params]
    (either (flat-map (last asts)
                      (fn [tail]
                        (store asts (dec (count asts))
                               (tail-call tail params))))
            asts)))

(defn set-result-constraint [result-var file-name line-number]
  ;; TODO: shouldn't be returning the result-constraint
  (for [_ (update-subs (for [result-c (typ/get-constraint "#result")
                             var-c (typ/get-constraint result-var)
                             :let [final (c/intersect result-c var-c)
                                   _ (and (= c/bottom-type final)
                                          (do
                                            (print-err "Invalid return value for function at" file-name line-number)
                                            (c/conflicting-assertions final file-name line-number)
                                            (abort)))]
                             _ (typ/set-constraint result-var final)]
                         final))
        result-constraint (sm/get-in-val [.fn-context .subs 0 result-var])
        _ (ev/traverse (c/extract-items-constraints result-constraint)
                       (fn [c]
                         (constrain-var file-name line-number (c/extract-var c) c)))]
    result-constraint))

(deftype TailExpr [ast]
  Stringable
  (string-list [_]
    (list (str ast)))

  Emitter
  (emit [_]
    (for [expr (emit ast)
          _ (set-result-constraint (.c-var expr) "" 0)]
      expr)))

(deftype TailHashMap [m]
  Stringable
  (string-list [_]
    (list (str m)))

  Emitter
  (emit [_]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context (.subs init-fn-context [{}]))
          value (encode m)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)
          _ (set-result-constraint (.c-var value) "" 0)]
      (c-code (.c-var value) ["return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint))))

(defn collisionArray [m]
  (inline C Vector "
  HashCollisionNode *node = (HashCollisionNode *)m_0;
  int cnt = node->count;
  Vector *v = empty_vect;
  for (int i = 0; i < cnt; i++) {
    Value *val = node->array[i];
    incRef(val, 1);
    v = mutateVectConj(v, val);
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiArray [m]
  (inline C Vector "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  int cnt = __builtin_popcount(node->bitmap);
  Vector *v = empty_vect;
  for (int i = 0; i < cnt * 2; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((List *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiBitmap [m]
  (inline C Integer "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  Value *result = integerValue(node->bitmap);
  dec_and_free(m_0, 1);
  return((Value *)result);
  "))

(defn arrayNodeArray [m]
  (inline C Vector "
  ArrayNode *node = (ArrayNode *)m_0;
  Vector *v = empty_vect;
  for (int i = 0; i < ARRAY_NODE_LEN; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((List *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))


;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity-info [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-var])]
                 [expr s]))))

(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (wrap sm/zero-sm (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            {} c/top-type)))

  (emit-defined-value [_ x] (wrap sm/zero-sm []))
  (emit-definition [_] (wrap sm/zero-sm []))

  (tail-call [ast params]
    (TailExpr ast)))


(extend-type HashSet
  Emitter
  (encode-static [hs]
    (comp (sm/get-in-val [.constants .encoded hs])
          (for [m (encode-static (.set-map hs))
                struct (global-var "set_")
                var (global-var "set_")
                _ (constrain-var "" 0 var (c/TypeConstraint {(get-type hs) #{}}
                                                            empty-list 'HashSet nothing ""))
                _ (declare ["ReifiedVal " struct " = {" (str (get-type hs))
                            ", -2, 0, 1, (Value *)&" (.c-struct m) "};\n"
                            "Value *" var " = (Value *)&" struct ";" line-sep])
                :let [expr (c-static-val var [] {} struct)]
                _ (sm/assoc-in-val [.constants .encoded hs] expr)]
            expr)))

  (emit [hs]
    (for [expr (encode (.set-map hs))
          var (genlocal "set_")]
      (-> expr
          (.c-var var)
          (.init (comp (.init expr) ["Value *" var " = newHashSet((List *)0, " (.c-var expr) ");" line-sep]))))))

(defn emit-tail-expr [ast expr]
  ;; TODO: periodically enable this to check on things
  ;; (print-err 'check (some return-assertions assert-return-type) return-type
  ;;            (ast/file-name ast) (ast/line-number ast))
  (collapse-expressions [expr
                         (c-code (.c-var expr)
                                 ["return(" (.c-var expr) ");" line-sep]
                                 {(.c-var expr) 1}
                                 c/top-type)]))

(deftype TailCall [ast params]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))

  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (emit-recursive-call ast params)
            (for [expr (emit ast)
                  curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
                  result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
                  checked-var (genlocal 'checked)
                  :let [expr (cond (instance? Tagged ast)
                                   (.refs-map expr {})
                                   expr)
                        check-result (cond (instance? c-param expr)
                                           ""
                                           (let [rt-check (runtime-check (c/update-var result-const (.c-var expr))
                                                                         curr-const file-name line-number
                                                                         checked-var)]
                                             (either (empty? rt-check)
                                                     ["if(1){int " checked-var " = 1;" line-sep
                                                      rt-check
                                                      "if(!" checked-var "){abort();}}" line-sep])))]
                  _ (constrain-var file-name line-number (.c-var expr) result-const)
                  final-expr (emit-tail-expr ast (.init expr [(.init expr) check-result]))
                  _ (set-result-constraint (.c-var final-expr) file-name line-number)]
              final-expr)))))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (for [expr (comp (sm/get-in-val [.constants .strings str-val])
                     (for [str-idx (sm/new-sm (fn [s]
                                                (assert (instance? GlobalContext s))
                                                (-> s
                                                    .constants
                                                    .strings
                                                    count
                                                    (vector s)
                                                    maybe)))
                           :let [str-sym (str "str" str-idx)
                                 str-ptr (str "strPtr" str-idx)
                                 constraint (c/TypeConstraint {c/StringBufferType #{}}
                                                              empty-list 'String nothing str-ptr)]
                           _ (sm/assoc-in-val [.constants .strings str-val]
                                              (c-static-str str-ptr [] {} constraint str-sym))
                           _ (declare ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        Integer *hash;
        int64_t len;
        char buffer["
                                       (inc str-len)
                                       "];\n} " str-sym " = {StringBufferType, -1, 0, "
                                       str-len ", \"" (escape-chars str-val) "\"};\n"
                                       "Value *" str-ptr " = (Value *)&" str-sym ";\n"])]
                       (c-static-str str-ptr [] {} constraint str-sym)))
          _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
      expr)))

(extend-type String
  Emitter
  (emit [str-val]
    (make-static-string str-val)))

(defn make-static-num [num]
  (for [expr (comp (sm/get-in-val [.constants .numbers num])
                   (for [num-idx (sm/new-sm (fn [s]
                                              (assert (instance? GlobalContext s))
                                              (-> s
                                                  .constants
                                                  .numbers
                                                  count
                                                  (vector s)
                                                  maybe)))
                         :let [num-sym (str "num" num-idx)
                               num-ptr (str "numPtr" num-idx)
                               constraint (c/StaticIntConstraint num empty-list nothing num-ptr)
                               var (c-static-int num-ptr [] {} constraint num-sym)]
                         _ (sm/assoc-in-val [.constants .numbers num] var)
                         _ (declare ["Integer " num-sym " = {IntegerType, -2, " num "};\n"
                                     "Value *" num-ptr " = (Value *)&" num-sym ";\n"])]
                     var))
        _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
    expr))

(extend-type Integer
  Emitter
  (emit [num]
    (make-static-num num)))

(extend-type BitmapIndexedNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; _ (debug 'encoding-bmi m
                items (ev/traverse (bmiArray m) (fn [v]
                                                  (either (map v (fn [v]
                                                                   (map (encode-static v) maybe)))
                                                          (wrap sm/zero-sm nothing))))
                struct (global-var "bmi_")
                var (global-var "bmi_")
                :let [new-items (cond (empty? items)
                                      "0"
                                      (interpose (map items
                                                      (fn [v]
                                                        (either (map v (fn [expr]
                                                                         (and (instance? String (.c-struct expr))
                                                                              (empty? (.c-struct expr))
                                                                              (do
                                                                                ;; TODO: remove sometime
                                                                                (print-err 'wtf-boom expr)
                                                                                (abort)))
                                                                         (str "(Value *)&"
                                                                              (.c-struct expr))))
                                                                "NULL")))
                                                 ", "))]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/BitmapIndexedType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["BitmapIndexedNode " struct " = {BitmapIndexedType, -2, 0, "
                            (str (bmiBitmap m)) ", " new-items "};\n"
                            "Value *" var " = (Value *)&" struct ";\n"])
                expr (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                                 [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type HashCollisionNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; TODO: see just what is being encoded
                ;; _ (debug 'encoding-hash-collistion m)
                items (ev/traverse (collisionArray m) encode-static)
                struct (global-var "collision_")
                var (global-var "collision_")
                :let [new-items (interpose (map items
                                                (fn [expr]
                                                  (str "(Value *)&" (.c-struct expr))))
                                           ", ")]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/HashCollisionNodeType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["HashCollisionNode " struct " = {HashCollisionNodeType, -2, 0, "
                            (str (count items)) ", " new-items "};\n"
                            "Value *" var " = (Value *)&" struct ";\n"])
                expr (collapse-expressions (comp items [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type ArrayNode
  Emitter
  (encode-static [m]
    (comp (sm/get-in-val [.constants .encoded m])
          (for [;; _ (debug 'encoding-array-node m
                items (ev/traverse (arrayNodeArray m) (fn [v]
                                                        (either (map v (fn [v]
                                                                         (map (encode-static v) maybe)))
                                                                (wrap sm/zero-sm nothing))))
                struct (global-var "arrayNode_")
                var (global-var "arrayNode_")
                :let [new-items (cond (empty? items)
                                      "0"
                                      (interpose (map items
                                                      (fn [v]
                                                        (either (map v (fn [expr]
                                                                         (str "(Value *)&"
                                                                              (.c-struct expr))))
                                                                "NULL")))
                                                 ", "))]
                _ (constrain-var "" 0 var (c/TypeConstraint {c/ArrayNodeType #{}}
                                                            empty-list 'HashMap nothing ""))
                _ (declare ["ArrayNode " struct " = {ArrayNodeType, -2, 0, " new-items "};"
                            line-sep "Value *" var " = (Value *)&" struct ";" line-sep])
                expr (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                                 [(c-static-val var [] {} struct)]))
                _ (sm/assoc-in-val [.constants .encoded m] (c-static-val var [] {} struct))]
            expr))))

(extend-type HashMap
  Emitter
  (emit [m]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context (.subs init-fn-context [{}]))
          value (comp (encode-static m)
                      (encode m))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)]
      (c-code (.c-var value) ["return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint)))

  (tail-call [m params]
    (TailHashMap m))

  (encode [m] (encode m "var_"))

  (encode [m var-prefix]
    (comp (encode-static m)
          (for [map-var (global-var var-prefix)
                _ (declare ["Value *" map-var " = (Value *)&emptyBMI;\n"])
                assocs (ev/traverse (seq m)
                                    (fn [[sym var]]
                                      (for [sym-var (cond (instance? Tagged sym)
                                                          (emit (ast/quoted-ast sym))
                                                          (emit sym))
                                            expr (comp (encode-static var)
                                                       (encode var))]
                                        [(.init sym-var) (.init expr)
                                         map-var " = hashMapAssoc((Value *)" map-var
                                         ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"])))
                _ (constrain-var "" 0 map-var hashmap-constraint)]
            (c-code map-var (comp* [] assocs) {} hashmap-constraint)))))

(extend-type c/KeysConstraint
  Emitter
  (runtime-check [constraint value-info sym-location checked-var]
    []))

;; (to-constraint [ast]
;;                (map (ev/traverse (.alts ast) to-constraint)
;;                     (partial .alts ast)))

;; (emit [ast]
;;       (flat-map (to-constraint ast) emit-sym-constraint))

(extend-type ast/quoted-ast
  Emitter
  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (for [expr (sm/get-in-val [.constants .symbols sym])
                  _ (constrain-var (ast/file-name ast) (ast/line-number ast)
                                   (.c-var expr) (.constraints expr))]
              expr)
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (c/update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-static-sym sym-ptr [] {} constraint sym-var))
                  _ (constrain-var (ast/file-name ast) (ast/line-number ast)
                                   sym-ptr constraint)
                  _ (declare ["SubString " sym-var " = {SymbolType, -1, 0, " (count (str sym))
                              ", 0, \"" sym "\"};\n"
                              "Value *" sym-ptr " = (Value *)&" sym-var ";\n"])]
              (c-static-sym sym-ptr [] {} constraint sym-var))))))


(def LiteralValues (any-of ast/quoted-ast
                           ast/string-ast
                           ast/integer-ast
                           Integer
                           String))

(extend-type LiteralValues
  Emitter
  (encode-static [n]
    (emit n))

  (replace-syms [ast _]
    (wrap sm/zero-sm ast))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params]
    (TailCall x params)))

(defn update-constraint [var f]
  (update-subs (flat-map (typ/get-constraint var)
                          (fn [c]
                            (typ/set-constraint var (f c))))))

(extend-type ast/string-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-string (.string ast))
          _ (update-constraint (.c-var expr)
                               (fn [c]
                                 (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(extend-type ast/integer-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-num (.int ast))
          _ (update-constraint (.c-var expr)
                               (fn [c]
                                 (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(defn call-vector [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [vect-sym (genlocal "newVect")
          result-sym (genlocal "vect")
          line (line-macro target "// call-vector")
          _ (update-subs
             (typ/constrain-contents result-sym vect-constraint (map args .c-var) file-name line-number))]
      (c-init result-sym
              [line
               "Vector *" vect-sym " = empty_vect;" line-sep
               (map args
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [vect-sym " = mutateVectConj(" vect-sym ", "
                         arg-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
              {} file-name line-number))))

(defn call-list [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "list")
          _ (update-subs
             (typ/constrain-contents result-sym list-constraint (map args .c-var) file-name line-number))]
      (c-init result-sym
              [line "List *" list-sym " = empty_list;" line-sep
               (map (reverse args)
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [list-sym " = listCons(" "(Value *)" arg-sym
                         ", " list-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
              {} file-name line-number))))

(defn call-maybe [target arg]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-maybe")
          result-sym (genlocal "maybe")
          _ (update-subs
             (typ/propogate-constraint (.c-var arg) result-sym
                                       (fn [inner]
                                         (either (= inner c/top-type)
                                                 (c/intersect maybe-constraint
                                                              (c/InferredInner inner empty-list
                                                                              nothing result-sym))))
                                       file-name line-number))]
      (c-init result-sym
              [line "Value *" result-sym " = (Value *)maybe((List *)0, (Value *)0, " (.c-var arg) ");" line-sep]
              {} file-name line-number))))

(def conj-like #{'conj 'store 'mutate-vect-conj})

(defn constrain-collection [coll-var v-var result-var file-name line-number]
  (for [coll-const (typ/get-constraint coll-var)
        :let [coll-type (c/extract-collection-of coll-const)
              contents-type (c/extract-contents-constraint coll-type)]
        _ (typ/append-constraint v-var contents-type file-name line-number)
        _ (typ/append-constraint result-var coll-type
                                 file-name line-number)]
    '_))

(defn add-hash-map-constraints [ast result args]
  (either (for [_ (= (.call-target ast) 'assoc)
                coll-var (map (nth args 0) .c-var)
                k-var (map (nth args 1) .c-var)
                v-var (map (nth args 2) .c-var)]
            (let [file-name (ast/file-name ast)
                  line-number (ast/line-number ast)]
              (update-subs (for [_ (constrain-collection coll-var v-var result file-name line-number)
                                 coll-const (typ/get-constraint coll-var)
                                 _ (typ/append-constraint k-var (c/extract-key-constraint coll-const)
                                                          file-name line-number)]
                             '_))))
            (wrap sm/zero-sm '_)))

(defn add-contents-constraint [ast result args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target (.call-target ast)]
    (either (or (for [_ (= target 'cons)
                      v (first args)
                      coll (second args)]
                  (let [v-var (.c-var v)
                        coll-var (.c-var coll)]
                    (update-subs (for [_ (constrain-collection (.c-var coll) (.c-var v) result file-name line-number)
                                       coll-const (typ/get-constraint coll-var)
                                       v-const (typ/get-constraint v-var)
                                       _ (typ/append-constraint result
                                                                (c/ItemsConstraint [v-const] coll-const
                                                                                   empty-list nothing result)
                                                                file-name line-number)]
                                   '_))))
                (for [_ (conj-like target)
                      coll (first args)
                      v (second args)]
                  (update-subs (constrain-collection (.c-var coll) (.c-var v) result file-name line-number))))
            (wrap sm/zero-sm '_))))

(defn inner-constraint-for-reduce [result-var ast args]
  (and (= (.call-target ast) 'reduce)
       (= 3 (count args))
       (let [[v initial-val f] (take args 3)
             file-name (ast/file-name ast)
             line-number (ast/line-number ast)]
         (for [arity-info (or (get-in f [.arities 2])
                              (get-in f [.arities 'variadic]))]
           (let [inner-const (either (map (-> arity-info .param-constraints c/extract-items-constraints second)
                                          (fn [c]
                                            (c/InferredInner c (list [file-name line-number])
                                                             nothing (.c-var v))))
                                     c/top-type)
                 init-const (either (-> arity-info .param-constraints c/extract-items-constraints first)
                                    c/top-type)
                 result-c (.result-constraint arity-info)]
             (for [_ (constrain-var file-name line-number (.c-var v) inner-const)
                   _ (constrain-var file-name line-number (.c-var initial-val) init-const)
                   _ (constrain-var file-name line-number result-var result-c)]
               '_))))))

(def ignore-result-type #{'split-with 'filter 'drop-while 'take-while})
(def map-fns #{'map 'map-vals 'list-map 'maybe-map 'add-promise-action 'add-future-action})

(defn add-inner-constraint [result-var ast args]
  (or (inner-constraint-for-reduce result-var ast args)
      (let [file-name (ast/file-name ast)
            line-number (ast/line-number ast)]
        (and (or (map-fns (.call-target ast))
                 (= (.call-target ast) 'flat-map)
                 (ignore-result-type (.call-target ast)))
             (< 1 (count args))
             (let [[v f] (take args 2)]
               (for [arity-info (or (get-in f [.arities 1])
                                    (get-in f [.arities 'variadic]))]
                 (let [inner-const (either (map (-> arity-info .param-constraints c/extract-items-constraints first)
                                                (fn [c]
                                                  (c/InferredInner c (list [file-name line-number])
                                                                  nothing (.c-var v))))
                                           c/top-type)
                       result-c (cond
                                 (map-fns (.call-target ast))
                                 (-> (c/InferredInner (.result-constraint arity-info)
                                                      empty-list nothing "")
                                     (c/update-path file-name line-number))

                                 (= (.call-target ast) 'flat-map)
                                 (c/update-path (.result-constraint arity-info)
                                                file-name line-number)

                                 c/top-type)]
                   (for [_ (constrain-var file-name line-number (.c-var v) inner-const)
                         _ (constrain-var file-name line-number result-var result-c)]
                     '_))))))))

(defn constrain-args [arg-vars param-constraints file-name line-number]
  (for [checked-var (genlocal 'checked)
        checks (ev/traverse (zip-lists arg-vars
                                       (c/extract-items-constraints param-constraints))
                            (fn [[expr constraint]]
                              (let [var (.c-var expr)]
                                (for [curr-const (sm/get-in-val [.fn-context .subs 0 var] c/top-type)
                                      _ (constrain-var file-name line-number var constraint)]
                                  (either (and (instance? c-param expr)
                                               (maybe ""))
                                          (-> constraint
                                              (c/update-var var)
                                              (runtime-check curr-const file-name line-number checked-var)))))))]
    (either (and (every checks empty?)
                 (maybe []))
            ["if(1){int " checked-var " = 1;" line-sep
             checks line-sep
             "if(!" checked-var "){abort();}}" line-sep])))

(defn call-proto-impl [arg-vars ast]
  (let [target (.call-target ast)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [dispatch-var (map (sm/when (first arg-vars)) .c-var)
          disp-type  (var-type-num dispatch-var)
          ;; _ (cond (= file-name "test.toc")
          ;;         (debug 'cpi file-name line-number (.call-target ast) (first arg-vars) dispatch-var disp-type)
          ;;         (sm/state-maybe 0))
          :when-not (= c/UnknownType disp-type)
          result-sym (genlocal "rslt")
          impl-info (get-proto-impl target num-args disp-type)
          ;; _ (debug 'cpi file-name line-number target disp-type "\n"
          ;;          (.param-constraints impl-info) "\n"
          ;;          result-sym (.result-constraint impl-info))
          ;; _ (debug 'arg-vars arg-vars)
          _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                  (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
          check-args (constrain-args arg-vars (.param-constraints impl-info)
                                     file-name line-number)
          _ (constrain-var file-name line-number result-sym (.result-constraint impl-info))
          _ (ev/traverse (zip-lists (map arg-vars .c-var)
                                    (c/extract-items-constraints (.param-constraints impl-info)))
                         (fn [[var constraint]]
                           (constrain-var file-name line-number var constraint)))
          line (line-macro target (str "// call proto fn " target))
          _ (either (add-inner-constraint result-sym ast arg-vars)
                    (wrap sm/zero-sm '_))
          _ (add-contents-constraint ast result-sym  arg-vars)
          _ (add-hash-map-constraints ast result-sym  arg-vars)]
      (c-init result-sym
              [line
               check-args
               "Value *" result-sym " = " (.c-fn impl-info) "("
               (interpose (list* "(List *)0" (map arg-vars .c-var)) ", ")
               ");" line-sep]
              {} file-name line-number))))

(defn inline-get-field [name args]
  (for [reified-val (nth args 0)
        field-index (nth args 1)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit reified-val)
          rslt (genlocal "rslt")]
      (c-field rslt ["Value *" rslt " = ((ReifiedVal *)" (.c-var dispatch-val) ")->impls[" (str field-index) "];\n"]
               {} c/top-type (.c-var dispatch-val)))))

(defn inline-wrap-and-apply [name args]
  (for [dispatch-ast (first args)
        wrapped (second args)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= c/UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name (count args) dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
          new-ast (-> impl-ast
                      (replace-bound-vars {})
                      (inline-expr (list dispatch-val wrapped)))]
      new-ast)))

(defn inline-flat-map [name args]
  (for [dispatch-ast (first args)
        f-ast (second args)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= c/UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name 2 dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (ev/traverse (.body impl-ast)
                                  (fn [ast]
                                    (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(defn inline-first [[arg]]
  (for [_ (instance? ast/call-ast arg)
        :let [target (.call-target arg)]
        :when (or (= target 'list)
                  (= target 'vector))
        head (first (.args arg))]
    (let [head-sym (ast/tag "#head" (ast/file-name arg) (ast/line-number arg))]
      (sm/state-maybe (ast/let-ast [(ast/binding head-sym head)]
                                   (conj (rest (.args arg))
                                         (ast/call-ast (ast/tag 'maybe) [head-sym])))))))

(defn inline-rest [[arg]]
  (for [_ (instance? ast/call-ast arg)
        :let [target (.call-target arg)]
        :when (or (= target 'list)
                  (= target 'vector))
        head (first (.args arg))]
    ;TODO: what about any ItemsConstraints or MinCount (when it arrives)
    (map (emit head)
         (fn [head]
           (cond (empty? (.init head))
                 (.args arg (rest (.args arg)))
                 (ast/let-ast [] [head (.args arg (rest (.args arg)))]))))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(defn inline-partial [[call-target & args]]
  ;; TODO: some test exprs for this
  ;; (partial subs 8)
  ;; (partial subs "bogus" 'sym 8)
  ;; (partial subs "bogus" 8 9 10)

  (let [file (ast/file-name call-target)
        line (ast/line-number call-target)
        more-args (ast/tag 'more-args file line)
        fn-sym (ast/tag (str "partial_" (either (instance? Tagged call-target)
                                                'anon)))]
    (-> (ast/fn-ast
         (maybe fn-sym)
         [(ast/fn-arity-ast fn-sym ""
                            (ast/params [] (maybe more-args)) ""
                            [(ast/call-ast (ast/tag 'apply file line)
                                           [call-target (ast/call-ast (ast/tag 'list* file line)
                                                                      (comp (vec args) [more-args]))])]
                            c/empty-items-constraint c/top-type)])
        sm/state-maybe
        maybe)))

(defn inline-comp* [[arg args]]
  (let [file (ast/file-name args)
        line (ast/line-number args)]
    (maybe (for [expr (emit arg)
                 dispatch-type (var-type-num (.c-var expr))
                 :when-not (= c/UnknownType dispatch-type)
                 impl-ast (map (get-proto-impl 'comp* 2 dispatch-type) .ast)
                 :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
                 args (either (flat-map (instance? ast/call-ast args)
                                        (fn [ast]
                                          (let [target (.call-target ast)]
                                            (and (= target 'rest)
                                                 (maybe (inline-expr target (.args args)))))))
                              (sm/state-maybe args))
                 :when (and (instance? ast/call-ast args)
                            (let [target (.call-target args)]
                              (or (= target 'list)
                                  (= target 'vector))))
                 arg-exprs (ev/traverse (.args args) emit)
                 :let [impl-ast (replace-bound-vars impl-ast {})
                       disp-binding (ast/binding-ast (ast/tag "dispArg" file line) expr)
                       args-bindings (-> (range (count arg-exprs))
                                         (map (fn [n]
                                                (ast/tag (str "arg" n) file line)))
                                         (make-bindings arg-exprs))
                       args-ast (.args args (map args-bindings .binding))
                       [dispatch-sym args-sym] (.fixed (.params impl-ast))]
                 body-exprs (ev/traverse (.body impl-ast)
                                         (fn [ast]
                                           (replace-syms ast {dispatch-sym (.binding disp-binding)
                                                              args-sym args-ast})))]
             (ast/let-ast (comp [disp-binding]
                                args-bindings)
                          body-exprs)))))

(defn inline-comp [args]
  (let [file (ast/file-name args)
        line (ast/line-number args)]
    (maybe (for [[expr & exprs] (ev/traverse args emit)]
             (let [[binding & bindings] (make-bindings (map (range (count args))
                                                            (fn [n]
                                                              (ast/tag (str "arg" n) file line)))
                                                       (comp [expr]
                                                             exprs))]
               (ast/let-ast
                (comp [binding] bindings)
                [(ast/call-ast (ast/tag 'comp* file line)
                               [(.binding binding)
                                (ast/call-ast (ast/tag 'list file line)
                                              (vec (map bindings .binding)))])]))))))

(def get-field-sym (ast/tag 'get-field 'core 0))

(extend-type Tagged
  Emitter
  (get-param-constraints [sym subs]
    (for [expr (lookup-sym (ast/tag sym))]
      (-> (get subs (.c-var expr) c/top-type)
          (c/update-var (.c-var expr))
          (c/update-sym (ast/untag sym)))))

  (bind-param [binding expr]
    (for [r (bind binding expr)
          _ (set-sym binding (c-param (.c-var expr) [] {(.c-var expr) 1} c/top-type
                                      (ast/file-name binding) (ast/line-number binding)))]
      r))

  (bind-param [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] {arg-var 1} c/top-type)]
          r (bind-param binding arg)]
      r))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] {arg-var 1} c/top-type)]
          r (bind binding arg)]
      r))

  (bind [binding evalled]
    (assert (instance? BindingValue evalled))

    (let [file-name (ast/file-name binding)
          line-number (ast/line-number binding)]
      
      (for [_ (comp (redef-proto-fn-error binding)
                    (for [_ (sm/when (instance? c-field evalled))
                          expr (sm/get-in-val [.fn-context .syms (ast/tag binding)])
                          :when (instance? c-param expr)
                          _ (compilation-error "The parameter" (str "'" binding "'")
                                               "shadows a field of the same name at"
                                               (.file-name expr)
                                               (.line-number expr))]
                      '_)
                    (set-sym binding (c-code (.c-var evalled) [] {(.c-var evalled) 1}
                                             c/top-type)))]
        (either (and (empty? (.init evalled))
                     (maybe (ParamBinding (.c-var evalled) [] "" [evalled])))
                (ParamBinding (.c-var evalled)
                              [] ""
                              [(either (instance? c-field evalled)
                                       (c-init (.c-var evalled) (.init evalled)
                                               (.refs-map evalled) file-name line-number))])))))

  (emit [sym]
    (lookup-sym (ast/tag sym)))

  (emit-defined-value [sym defined-sym]
    (for [value (emit (ast/tag sym))
          _ (new-module-def defined-sym value)]
      [value]))

  (tail-call [ast params]
    (TailCall ast params))

  (inline-expr [name arg-asts]
    ;; TODO: inline 'get-in', 'update-in'
    (let [args (remove arg-asts (partial instance? ast/NoCode))
          num-args (count args)]
      (either (or (and (or (= name 'wrap)
                           (= name 'apply))
                       (inline-wrap-and-apply name args))
                  (and (= name get-field-sym)
                       (inline-get-field name args))
                  (and (or (= name 'flat-map)
                           (= name 'map))
                       (inline-flat-map name args))
                  (and (= name '=)
                       (= num-args 2)
                       (-> '=*
                           (ast/tag (ast/file-name name) (ast/line-number name))
                           (ast/call-ast arg-asts)
                           sm/state-maybe 
                           maybe))
                  (and (= name 'partial)
                       (inline-partial args))
                  (and (= name 'first)
                       (= 1 num-args)
                       (inline-first args))
                  (and (= name 'rest)
                       (= 1 num-args)
                       (inline-rest args))
                  (and (= name 'comp*)
                       (= 2 num-args)
                       (inline-comp* args))
                  (and (= name 'comp)
                       (< 1 num-args)
                       (inline-comp args)))
              sm/zero-sm))))

(extend-type ast/tagged-symbol
  Emitter
  (replace-syms [ast subs]
    (wrap sm/zero-sm (get subs ast ast)))

  (replace-bound-vars [ast subs]
    (get subs ast ast))

  (encode-static [x]
    (emit (ast/quoted-ast (.sym x)))))

(extend-type Symbol
  Emitter
  (replace-syms [sym subs]
    (let [sym (ast/tag sym)]
      (wrap sm/zero-sm (get subs sym sym))))

  (replace-bound-vars [sym subs]
    (let [sym (ast/tag sym)]
      (get subs sym sym)))

  (encode-static [sym]
    (emit (ast/quoted-ast sym))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (ev/traverse (.value-exprs ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] {} c/top-type)]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))
                  _ (declare ["Value *" c-var ";\n"])]
              [(.c-var c-info "")])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (wrap sm/zero-sm (c-code "empty_list" [] {} c/top-type)))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str "at " file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(List *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

(defprotocol ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(deftype StaticArity [arity-fn-var c-fn param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr c-fn))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))

  Stringable
  (string-list [_]
    (list "(StaticArity " (str arity-fn-var) " " (str param-count) " "
          (str var-info) " " (str param-constraints)
          " " (str result-constraint) ")"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (sm/update-in-val [.reify-fn-index] inc)
          _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraint c-fn)]
      var-info)))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arity-info arg-vars ast]
  (assert (instance? StaticArityInfo arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [result-sym (genlocal "rslt")
          ;; _ (comp (for [_ (sm/when (= (str (.call-target ast)) "pr-bands"))
          ;;               _ (debug 'csf file-name line-number (.call-target ast) (.c-var target) "\n"
          ;;                        (.param-constraints arity-info) "\n"
          ;;                        result-sym (.result-constraint arity-info))
          ;;               _ (debug 'arg-vars arg-vars)
          ;;               _ (ev/traverse arg-vars (fn [v]
          ;;                           (flat-map (sm/get-in-val [.fn-context .subs 0 (.c-var v)] c/top-type)
          ;;                                     (fn [c]
          ;;                                       (debug 'v (.c-var v) 'c c)))))]
          ;;           '_)
          ;;         (sm/state-maybe '_))
          [param-cs result-c] (comp (for [fn-var (sm/when (and (= (.call-target ast) 'fn-apply)
                                                               (first arg-vars)))
                                          applied-fn (sm/when (first (.args ast)))
                                          fn-info (sm/get-in-val [.fns (.c-var fn-var)])]
                                      ;; TODO: catch problems at compile time
                                      (let [file (ast/file-name applied-fn)
                                            line (ast/line-number applied-fn)
                                            param-constraints (-> (seq fn-info)
                                                                  (map (fn [[_ v]]
                                                                         (-> v
                                                                             .param-constraints
                                                                             c/extract-items-constraints)))
                                                                  ((fn [vs] (vec (apply zip-lists vs))))
                                                                  (map c/sum-type))
                                            result-constraint (-> (vals fn-info)
                                                                  (map .result-constraint)
                                                                  c/sum-type)]
                                        [(-> (c/ItemsConstraint [fn-constraint
                                                                 (c/ItemsConstraint param-constraints
                                                                                    c/coll-of-any
                                                                                    empty-list
                                                                                    nothing "")]
                                                                c/coll-of-any
                                                                empty-list
                                                                nothing "")
                                             (c/update-path file line))
                                         (c/update-path result-constraint file line)]))
                                    (sm/state-maybe [(.param-constraints arity-info)
                                                     (.result-constraint arity-info)]))
          _ (constrain-var file-name line-number result-sym result-c)
          check-args (constrain-args arg-vars param-cs
                                     file-name line-number)

          _ (update-call-site-count (.c-var arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-var arity-info) file-name line-number)]
      (c-init result-sym
              [check-args
               line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              {} file-name line-number))))

(defn call-static-variadic [target arity-info arg-vars ast]
  (assert (instance? StaticArityInfo arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [_ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (ast/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg []))))
          result-sym (genlocal "rslt")
          ;; _ (debug 'csv file-name line-number (.call-target ast) (.c-var target) "\n"
          ;;          (.param-constraints arity-info) "\n"
          ;;          result-sym (.result-constraint arity-info))
          _ (constrain-var file-name line-number result-sym (.result-constraint arity-info))
          check-args (constrain-args arg-vars (.param-constraints arity-info)
                                     file-name line-number)
          _ (constrain-var file-name line-number (.c-var args-list) (.param-constraints arity-info))
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               check-args
               line
               "Value *" result-sym " = " (.c-var arity-info) "((List *)0, (Value *)"
               (.c-var args-list) ");" line-sep]
              {} (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        type-num (var-type-num (.c-var target))
        :when (= c/FunctionType type-num)
        result-sym (genlocal "rslt")
        ;; _ (debug 'cdf (ast/file-name ast) (ast/line-number ast) (.call-target ast) (.c-var target) "\n"
        ;;          result-sym)
        ;; _ (debug 'target target)
        _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        line (line-macro ast "// dynamic fn type")]
    (let [args (map args .c-var)
          arg-syms (comp [(str arity-sym "->closures")] args)
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              {} (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (ast/tag "#symbols"))
(def protocols-sym (ast/tag "#protocols"))
(def invoke-sym (ast/tag 'invoke 'core 0))
(def Type-sym (ast/tag 'Type 'core 0))
(def Function-sym (ast/tag 'Function 'core 0))
(def Container-sym (ast/tag 'Container 'core 0))
(def Stringable-sym (ast/tag 'Stringable 'core 0))
(def type-name-sym (ast/tag 'type-name 'core 0))
(def type-mapping-sym (ast/tag 'type-mapping 'core 0))
(def =*-sym (ast/tag '=* 'core 0))
(def apply-sym (ast/tag 'apply 'core 0))
(def get-type-sym (ast/tag 'default-get-type 'core 0))
(def extract-sym (ast/tag 'extract 'core 0))
(def instance?-sym (ast/tag 'instance? 'core 0))
(def string-list-sym (ast/tag 'string-list 'core 0))
(def list-sym (ast/tag 'list 'core 0))
(def has-field-sym (ast/tag 'has-field 'core 0))
(def identical-sym (ast/tag 'identical 'core 0))
(def Eq-sym (ast/tag 'Eq 'core 0))
(def Associative-sym (ast/tag 'Associative 'core 0))
(def get-symb (ast/tag 'get 'core 0))
(def maybe-sym (ast/tag 'maybe 'core 0))
(def HashMapNode-sym (ast/tag 'HashMapNode 'core 0))
(def Hashable-sym (ast/tag 'Hashable 'core 0))
(def sha1-sym (ast/tag 'sha1 'core 0))
(def sha1-update-sym (ast/tag 'sha1-update 'core 0))
(def sha1-init-sym (ast/tag 'sha1-init 'core 0))
(def sha1-finalize-sym (ast/tag 'sha1-finalize 'core 0))
(def sha1-update-type-sym (ast/tag 'sha1-update-type 'core 0))
(def assoc-sym (ast/tag 'assoc 'core 0))
(def update-field-sym (ast/tag 'update-field 'core 0))
(def store-sym (ast/tag 'store 'core 0))
(def default-type-args-sym (ast/tag 'default-type-args 'core 0))
(def nth-sym (ast/tag 'nth 'core 0))
(def partial-sym (ast/tag 'partial 'core 0))
(def some-sym (ast/tag 'some 'core 0))
(def nothing-sym (ast/tag 'nothing 'core 0))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (lookup-core-fn-arity invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")
          sym-location (emit (either (= "\"\"" file-name)
                                     (str "\"at " file-name ": " line-number "\"")))]
      (let [args (map args .c-var)
            arg-syms (comp [(str arity-sym "->closures")] args)]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 result-sym " = " invoke-arity-sym "("
                 (interpose (list* (str "(List *)" (.c-var sym-location))
                                   (.c-var target) args) ", ") ");"
                 line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                {} file-name line-number)))))

(defn call-invoke [target arg-vars ast]
  (let [arg-vars (comp [target] arg-vars)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [target-type (var-type-num (.c-var target))
          :when-not (= c/UnknownType target-type)
          invoke-info (get-proto-impl Function-sym invoke-sym num-args target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          result-sym (genlocal "rslt")
          ;; _ (debug 'ci file-name line-number target num-args 'target-type target-type "\n"
          ;;          (.param-constraints invoke-info) "\n"
          ;;          result-sym (.result-constraint invoke-info))
          ;; _ (debug 'arg-vars arg-vars)
          ;; _ (debug 'param-consts (.param-constraints invoke-info))
          check-args (constrain-args arg-vars (.param-constraints invoke-info)
                                     file-name line-number)

          _ (constrain-var file-name line-number result-sym (.result-constraint invoke-info))
          _ (ev/traverse (zip-lists (map arg-vars .c-var)
                                    (c/extract-items-constraints (.param-constraints invoke-info)))
                         (fn [[var constraint]]
                           (constrain-var file-name line-number var constraint)))

          ;; _ (debug "-----")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line check-args
               "Value *" result-sym " = " (.c-fn invoke-info) "("
               (interpose (list* "(List *)0" (map arg-vars .c-var)) ", ")
               ");" line-sep]
              {} file-name line-number))))

(defprotocol CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (call-dyn-fn-value target args ast)
          (call-dyn-unknown-type target args ast))))

(extend-type c-static-reified
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(extend-type c-constructor
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(defn static-call-site [target args ast]
  (comp (for [fn-info (sm/get-in-val [.fns (.c-var target)])
              expr (either (or (map (get fn-info (count args))
                                    (fn [arity-info]
                                      (call-static-fixed target arity-info args ast)))
                               (map (get fn-info 'variadic)
                                    (fn [arity-info]
                                      (call-static-variadic target arity-info args ast))))
                           sm/zero-sm)
              _ (either (add-inner-constraint (.c-var expr) ast args)
                        (wrap sm/zero-sm '_))
              _ (add-hash-map-constraints ast (.c-var expr) args)
              _ (add-contents-constraint ast (.c-var expr) args)]
          expr)
        (compilation-error "No arity with" (count args) "arguments found"
                           (either (map (instance? Tagged (.call-target ast))
                                        (fn [sym]
                                          (str "for '" sym "'")))
                                   "")
                           "at:" (ast/file-name ast) (ast/line-number ast))))

(extend-type c-maybe-fn
  CallSite
  (emit-call-site [target args ast]
    (either (map (and (= 1 (count args))
                      (first args))
                 (partial call-maybe (.call-target ast)))
            (compilation-error "Call to 'maybe' in" (ast/file-name ast) "at line" (ast/line-number ast)
                               "has the wrong number of arguments. Only a single argument is valid."))))

(extend-type c-list-fn
  CallSite
  (emit-call-site [target args ast]
    (call-list (.call-target ast) args)))

(extend-type c-vector-fn
  CallSite
  (emit-call-site [target args ast]
    (call-vector (.call-target ast) args)))

(extend-type c-static-fn
  CallSite
  (emit-call-site [target args ast]
    (static-call-site target args ast)))

;; TODO: test add-inner-constraint on state-maybe values
;; TODO: add inner constraint to Strings
;; TODO: insert InferredInner into anon fn passed to higher order fn

(def returns-inner #{'seq 'vec 'rest 'butlast 'reverse 'vals 'last 'nth 'get 'first})

(defn propogate-inner-constraint [result-var ast args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    ;; TODO: do hash-seq, list-concat, comp-vect as well
    (for [_ (or (returns-inner (.call-target ast))
                (= (.call-target ast) 'extract))
          arg (first args)]
      (update-subs
       (typ/propogate-constraint (.c-var arg) result-var
                                 (fn [constraint]
                                   (let [inner-c (c/extract-coll-constraint constraint)]
                                     (either (and (= (.call-target ast) 'extract)
                                                  (maybe (c/extract-contents-constraint inner-c)))
                                             inner-c)))
                                 file-name line-number)))))

(extend-type c-protocol-fn
  CallSite
  (emit-call-site [target args ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [expr (comp (call-proto-impl args ast)
                       (static-call-site target args ast))
            _ (either (propogate-inner-constraint (.c-var expr) ast args)
                      (wrap sm/zero-sm '_))
            _ (either (for [_ (= (.call-target ast) 'wrap)
                            _ (or (= 2 (count args))
                                  (do
                                    (print-err "Wrong number of arguments to 'wrap' in"
                                               file-name "at line" line-number)
                                    (maybe (abort))))
                            wrapped (second args)]
                        (update-subs
                         (typ/propogate-constraint (.c-var wrapped) (.c-var expr)
                                                   (fn [inner]
                                                     (c/InferredInner inner empty-list nothing ""))
                                                   file-name line-number)))
                      (wrap sm/zero-sm '_))]
        expr))))

(extend-type c/SumConstraint
  Emitter
  (runtime-check [constraint value-info sym-location checked-var]
    (let [alts (.alts constraint)
          var (c/extract-var constraint)]

      (either (and (c/satisfied-by constraint value-info)
                   (maybe []))
              ["if (" checked-var "){"
               "int checkPassed = 0;"
               (reduce alts []
                       (fn [ss alt]
                         (comp ss
                               ["if(!checkPassed){" line-sep
                                checked-var " = 1;" line-sep
                                ;; TODO: what if runtime-check is empty?
                                (runtime-check (c/update-var alt var)
                                               value-info checked-var)
                                "if(" checked-var "){checkPassed = 1;}"])))
               (repeat (count alts) "}")
               "if (!checkPassed){"
               ;; "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Invalid type of value for '"
               (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
               ;; TODO: this error message needs to be more clearer
               "fprintf(stderr, \"Got %s\\n\", extractStr(type_name((List *)0, " var ")));" 
               "fprintf(stderr, \"Needed a value specified in\\n"
               (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
               "\\n\");"
               ;; "\n#endif\n"
               "abort();}}" line-sep])))

  (runtime-check [constraint value-info checked-var]
    (let [alts (.alts constraint)
          var (c/extract-var constraint)]
      (either (and (c/satisfied-by constraint value-info)
                   (maybe []))
              ["if (" checked-var "){"
               checked-var " = 0;" line-sep
               (reduce alts []
                       (fn [ss alt]
                         (comp ss
                               ["if(!" checked-var "){" line-sep
                                checked-var " = 1;" line-sep
                                ;; TODO: what if runtime-check is empty?
                                (runtime-check (c/update-var alt var)
                                               value-info checked-var)])))
               (repeat (count alts) "}") "}" line-sep])))

  (to-constraint [ast]
    (map (ev/traverse (.alts ast) to-constraint)
         (partial .alts ast)))

  (emit [ast]
    (flat-map (to-constraint ast) emit-sym-constraint)))

(extend-type c/ValueConstraint
  Emitter
  (emit-defined-value [constraint defined-sym]
    (let [file-name (ast/file-name constraint)
          line-number (ast/line-number constraint)
          x* (ast/tag "#x")
          y* (ast/tag "#y")]
      (for [constraint (to-constraint constraint)
            :let [types-info (either (c/extract-type-map constraint)
                                     {})]
            _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types (ast/untag defined-sym)] constraint)
            exprs (emit-defined-value
                   (ast/reified
                    nothing
                    {(ast/tag Eq-sym file-name line-number)
                     {=*-sym
                      [(ast/fn-arity-ast
                        (str defined-sym "_EQ_QMARK_") ""
                        (ast/params [x* y*]) ""
                        [(ast/call-ast =*-sym
                                       [(ast/call-ast get-type-sym [x*])
                                        (ast/call-ast get-type-sym [y*])])]
                        c/empty-items-constraint c/top-type)]}

                     (ast/tag Type-sym file-name line-number)
                     {instance?-sym
                      [(ast/fn-arity-ast
                        (str defined-sym "_instance_QMARK_") ""
                        (ast/params [x* y*]) ""
                        [(ast/and-ast
                          ;; TODO: this needs to be replace with runtime-check
                          [(ast/call-ast some-sym
                                         [(ast/call-ast list-sym (vec (keys types-info)))
                                          (ast/call-ast partial-sym
                                                        [=*-sym
                                                         (ast/call-ast get-type-sym [y*])])])
                           (ast/call-ast maybe-sym [y*])])]
                        c/empty-items-constraint c/top-type)]

                      type-mapping-sym
                      [(ast/fn-arity-ast
                        (str defined-sym "_type_mapping") ""
                        (ast/params [x*]) ""
                        [(map-vals types-info (fn [field-set]
                                                (map field-set ast/quoted-ast)))]
                        c/empty-items-constraint c/top-type)]}

                     (ast/tag Stringable-sym file-name line-number)
                     {string-list-sym
                      [(ast/fn-arity (ast/params [x*]) ""
                                     [(ast/call-ast list-sym ["<SumType " (str defined-sym) ">"])])]}})
                   defined-sym)]
        exprs))))

(defn define-enum-type [fn-val defined-sym]
  (let [file-name (ast/file-name defined-sym)
        line-number (ast/line-number defined-sym)]
    (for [_ (sm/when (= (.call-target fn-val) 'enum))
          type-maps (comp (ev/traverse (.args fn-val)
                                       (fn [sym]
                                         (comp (flat-map (sm/get-in-val [.modules (ast/file-name sym)
                                                                         .types (ast/untag sym)])
                                                         (fn [_]
                                                           (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                              " at:" file-name line-number)))
                                               (for [expr (comp (find-global-sym sym)
                                                                (compilation-error "Invalid enum value "
                                                                                   (str "'" sym "'")
                                                                                   " at:" file-name line-number))
                                                     :when (instance? c-static-reified expr)
                                                     type-map (sm/when (-> expr
                                                                           expr-constraints
                                                                           c/extract-type-map))]
                                                 type-map))))
                          (compilation-error "Invalid enum values at:" file-name line-number))
          :let [type-map (comp* {} type-maps)
                x* (ast/tag "#x")
                y* (ast/tag "#y")]
          reified-type-num (sm/update-val .type-counter inc)
          _ (sm/assoc-in-val [.modules file-name .types (ast/untag defined-sym)]
                             (c/TypeConstraint type-map empty-list defined-sym nothing ""))
          exprs (emit-defined-value
                 (ast/reified
                  (maybe reified-type-num)
                  {Type-sym
                   {instance?-sym
                    [(ast/fn-arity-ast
                      (str defined-sym "_instance_QMARK_") ""
                      (ast/params [x* y*]) ""
                      [(ast/and-ast
                        [(ast/call-ast some-sym
                                       [(ast/call-ast list-sym (vec (keys type-map)))
                                        (ast/call-ast partial-sym
                                                      [=*-sym (ast/call-ast get-type-sym [y*])])])
                         (ast/call-ast maybe-sym [y*])])]
                      c/empty-items-constraint c/top-type)]

                    type-mapping-sym
                    [(ast/fn-arity-ast
                      (str defined-sym "_type_mapping") ""
                      (ast/params [x*]) ""
                      [(map-vals type-map (fn [field-set]
                                            (map field-set ast/quoted-ast)))]
                      c/empty-items-constraint c/top-type)]}

                   Stringable-sym
                   {string-list-sym
                    [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                   [(ast/call-ast list-sym
                                                  ["<SumType " (str defined-sym) ">"])])]}})
                 defined-sym)]
      exprs)))

(defn init-at-runtime [ast defined-sym]
  (for [map-var (lookup-sym (ast/tag symbols-sym (ast/file-name defined-sym) (ast/line-number defined-sym)))
        init-fn-context (sm/get-in-val [.rt-init .fn-context])
        fn-context (reset-fn-context (.subs init-fn-context [{}]))

        sym-var (emit (ast/quoted-ast defined-sym))

        value (emit ast)
        constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
        init-fn-context (reset-fn-context fn-context)
        _ (constrain-var (ast/file-name ast) (ast/line-number ast) (.c-var value) constraint)
        _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)]
    (.init value [(.init value)
                  (.c-var map-var) " = hashMapAssoc((Value *)" (.c-var map-var) ", "
                  (.c-var sym-var) ", " (.c-var value) ");\n"])))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [target-lang (wrap sm/zero-sm 'C)
            :when (= (.lang ast) target-lang)
            line-info (line-macro ast "// inline")
            :let [init [line-info (.txt ast) "\n#\n"]]

            expr (comp (for [type-sym (sm/when (.result-type ast))
                             constraint (get-type-sym-info type-sym)
                             c-var (genlocal "rslt")
                             _ (constrain-var file-name line-number c-var constraint)]
                         (c-code c-var init {} constraint))
                       (wrap sm/zero-sm (c-code "" init {} c/top-type)))
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr)))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          constraint (either (map (.result-type ast)
                                  (fn [type-sym]
                                    (to-constraint (c/TypeConstraint {} (list [(ast/file-name ast)
                                                                               (ast/line-number ast)])
                                                                     type-sym nothing ""))))
                             (wrap sm/zero-sm c/top-type))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] {} constraint))
          line-info (line-macro ast "// inline")
          _ (declare [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"])
          r (init-at-runtime (c-code c-var [] {} constraint) defined-sym)]
      [r]))

  (emit-definition [ast]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          _ (declare [(.txt ast)])]
      [empty-c-code]))

  (tail-call [ast params]
    (TailExpr ast))

  (replace-syms [ast _]
    (wrap sm/zero-sm ast)))

(extend-type ast/call-ast
  Emitter
  (emit-recursive-call [ast params]
    (for [_ (sm/when (instance? Tagged (.call-target ast)))
          target (emit (.call-target ast))
          _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
          args (ev/traverse (.args ast) emit)
          line (line-macro ast "// recursive-fixed")]
      (do
        ;; TODO: collapse-expressions doesn't seem to work
        ;; (collapse-expressions (comp args
        ;;                             [(c-code ""
        ;;                                      [line
        ;;                                       (map (zip-lists params (map args .c-var))
        ;;                                            (fn [[param arg]]
        ;;                                              [param " = " arg ";" line-sep]))]
        ;;                                      {} c/top-type)]))
        (comp* empty-c-code (comp args
                                  [(c-code ""
                                           [line
                                            (map (zip-lists params (map args .c-var))
                                                 (fn [[param arg]]
                                                   [param " = " arg ";" line-sep]))]
                                           {} c/top-type)])))))

  (emit-defined-value [fn-val defined-sym]
    (comp (define-enum-type fn-val defined-sym)
          (for [value (init-at-runtime fn-val defined-sym)
                constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                _ (new-module-def defined-sym (c-code var [] {} (c/update-var constraint var)))
                _ (declare ["Value *" var ";\n"])]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          "if(" var "->refs > 0)" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     (.refs-map value) (ast/file-name fn-val) (ast/line-number fn-val))])))

  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    (either (and (instance? Symbol target-ast)
                                                 (maybe (ast/tag target-ast)))
                                            target-ast))))]
      (comp (flat-map (inline-expr (.call-target ast) (.args ast))
                      (fn [x]
                        (for [r (emit x)
                              ;; _ (debug 'old "\n" ast)
                              ;; _ (debug 'new "\n" x)
                              ]
                          r)))
            (flat-map (ev/traverse (.args ast) emit)
                      (fn [args]
                        (comp (for [target (emit (.call-target ast))
                                    call-site (emit-call-site target args ast)]
                                (do
                                  ;; TODO: why does 'collapse-expressions' not work here?
                                  ;; (collapse-expressions (comp [target] args [call-site]))
                                  (comp* target (comp args [call-site]))))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (tail-call [ast params]
    (TailCall ast params))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (ev/traverse (.args ast) (fn [ast]
                                          (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    (either (for [_ (instance? ast/call-ast ast)
                  ;; TODO: this needs to be generalized
                  _ (= (.call-target ast) 'new-sm)
                  fn-ast (first (.args ast))]
              (inline-expr fn-ast arg-asts))
            (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                  new-ast (inline-expr new-call-target arg-asts)]
              new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

;; TODO: when a proto impl is wrong (ie; wrong number of args)
;; the error message is trash
(extend-type C-expr
  Emitter
  (replace-syms [v _]
    (wrap sm/zero-sm v))

  (tail-call [expr _]
    (TailExpr expr))

  (emit [x]
    (wrap sm/zero-sm x))

  (bind-list [list-var params bind-fn]
    ;; TODO: wow, this is too complex
    (let [file-name (ast/file-name params)
          line-number (ast/line-number params)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (ast/tag "restArgs"))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind-fn tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            :let [tail-var (.bound tail-binding)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding (.c-var list-var)
                                                       [] tail-var
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq((List *)0, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                {(.c-var list-var) 1}
                                                                file-name line-number)]))))
                    (for [content-vars (ev/traverse (.fixed params)
                                                    (fn [target]
                                                      (genlocal target "arg")))
                          _ (constrain-var file-name line-number
                                           (.c-var list-var)
                                           (rdr/assert-min-count file-name line-number fixed-count))
                          _ (update-subs
                             (typ/propogate-contents-constraints (.c-var list-var) content-vars tail-var
                                                                 file-name line-number))
                          fixed-bindings (ev/traverse (vec (zip-lists (.fixed params)
                                                                      content-vars))
                                                      (fn [[target var]]
                                                        (bind-fn target (c-code var [] {} c/top-type))))
                          dest-args (genlocal "destArgs")]
                      (ParamBinding (.c-var list-var)
                                    fixed-bindings tail-var
                                    (comp [list-var
                                           (c-code ""
                                                   (destruct-seq (.c-var list-var)
                                                                 (conj content-vars tail-var)
                                                                 (str dest-args) file-name line-number)
                                                   {(.c-var list-var) 1} c/top-type)]
                                          (map (conj content-vars tail-var)
                                               (fn [var]
                                                 (c-init var [] {} file-name line-number)))
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type c-code
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-field
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-param
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-constructor
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-reified
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-protocol-fn
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-int
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-str
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-sym
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-fn
  C-Code
  (expr-constraints [expr new-c]
    (.constraints expr new-c))

  (expr-constraints [expr]
    (.constraints expr)))

(extend-type ast/tagged-symbol
  Emitter
  (all-symbols [ast]
    [ast]))

(extend-type ast/params-ast
  Emitter
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  (get-param-constraints [params subs]
    (for [items-constraints (ev/traverse (.fixed params) (fn [param]
                                                           (get-param-constraints param subs)))
          tail-constraint (either (map (.variadic params)
                                       (fn [param]
                                         (get-param-constraints param subs)))
                                  (wrap sm/zero-sm c/top-type))]
      (-> c/empty-items-constraint
          (c/update-path (ast/file-name params) (ast/line-number params))
          (.tail-constraint tail-constraint)
          (.items-constraints items-constraints))))

  (bind-param [params]
    (for [param-var (genlocal "arg")
          destruct (bind-param params (c-code param-var [] {} c/top-type))]
      destruct))

  (bind-param [params expr]
    (bind-list expr params bind-param))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] {} c/top-type)
                              params
                              bind)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params bind))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [locals get-syms
            bindings (ev/traverse (.bindings ast) emit)
            body-exprs (ev/traverse (.body ast) emit)
            _ (ev/traverse bindings
                           (fn [binding]
                             (update-subs (constrain-params binding))))
            code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))
            result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                               (genlocal "let_rslt"))
            _ (update-subs
               (typ/propogate-constraint (.c-var code) result-var identity
                                         file-name line-number))
            _ (set-syms locals)]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.refs-map code) file-name line-number))))

  (emit-defined-value [ast defined-sym]
    (for [value (init-at-runtime ast defined-sym)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          val-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
          _ (new-module-def defined-sym (c-code var [] {} val-constraint))
          _ (declare ["Value *" var ";\n"])]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    "if(" var "->refs > 0)" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               (.refs-map value) (ast/file-name ast) (ast/line-number ast))]))

  (unwrap-tail [ast]
    (.body ast (comp (filter (.body ast) (partial instance? c/Constraints))
                     (-> ast
                         .body
                         (remove (partial instance? ast/NoCode))
                         (unwrap-tail)))))

  (tail-call [ast params]
    (.body ast (comp (filter (.body ast) (partial instance? c/Constraints))
                     (-> ast
                         .body
                         (remove (partial instance? ast/NoCode))
                         (tail-call params)))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (wrap sm/zero-sm new-bindings)))]
      (for [new-bindings (f (.bindings ast) empty-list subs)
            new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_]
                                      (ast/tag (gensym "#arg") (ast/file-name ast) (ast/line-number ast))))
          new-body (either (empty? (.body ast))
                           (let [[tail & init] (-> (.body ast)
                                                   (remove (partial instance? ast/NoCode))
                                                   reverse)]
                             (-> (ast/call-ast tail unique-syms)
                                 (cons init)
                                 reverse
                                 vec)))
          new-body (comp (filter (.body ast) (partial instance? c/Constraints))
                         new-body)]
      (wrap sm/zero-sm
            (ast/let-ast
             (comp (make-bindings unique-syms arg-asts)
                   (.bindings ast))
             new-body))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (assert (instance? (vector-of ast/binding-ast) bindings))

              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (do
                                                        ;; TODO: putting this in blows up
                                                        ;; (print-err 'bad (ast/tag (str "#" sym)
                                                        ;;                          (ast/file-name ast)
                                                        ;;                          (ast/line-number ast)))
                                                        (assoc new-subs sym
                                                               (ast/tag (str "#" sym)
                                                                        (ast/file-name sym)
                                                                        (ast/line-number sym))))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))
          [new-bindings new-subs] (f (.bindings ast) empty-list subs)
          new-body (map (.body ast) (fn [ast]
                                      (replace-bound-vars ast new-subs)))]
      (ast/let-ast (vec new-bindings) (vec new-body)))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          _ (constrain-var file-name line-number
                           reified-sym (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                                         nothing reified-sym))]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = " (count impl-fns) ";" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (apply merge-with (list* + (map impl-fns .refs-map))) file-name line-number))))

(defn static-reified-value [file-name line-number type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")
        _ (constrain-var file-name line-number
                         reified-ptr
                         (c/TypeConstraint {type-num #{}} (list [file-name line-number])
                                           (symbol "<Reified Type Value>")
                                           nothing (str reified-ptr)))
        _ (declare ["ReifiedVal " reified-sym " = {"
                    type-num ", -2, 0, "
                    "0, {}};" line-sep
                    "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep])]
    (c-static-reified reified-ptr [] {}
                      (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                        nothing (str reified-ptr))
                      reified-sym)))

(defn new-static-arity [fn-ptr num-params arity-var param-constraints result-constraint]
  (assert (instance? CFnPtr arity-var))

  (sm/assoc-in-val [.fns fn-ptr num-params]
                   (StaticArityInfo arity-var param-constraints result-constraint)))

(deftype ClosureArity [arity-fn-var params param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (ev/traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym) fn-arity-sym) arity-ast
                              param-constraints result-constraint 
                              (StaticFnPtr (str impl-fn-sym)))
            _ (sm/update-in-val [.reify-fn-index] inc)
            _ (declare ["// implementation of " fn-name "\n"
                        "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                        "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                        ")->impls[" reify-fn-index "];" line-sep
                        "incRef(" dispArg ", 1);" line-sep
                        "if (arityPtr->count != " param-count ") {\n"
                        "fprintf(stderr, \"Booom\\n\");\nabort();\n}\n"
                        "Value *rval = ((FnType" param-count
                        " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                        "dec_and_free(" dispArg ", 1);" line-sep
                        "return(rval);" line-sep
                        "};\n\n"
                        "FnArity " fn-arity-sym " = {FnArityType, -2, " param-count
                        ", (List *)0, 0, " impl-fn-sym ", (Value *)0, (Value *)0};" line-sep])]
        var-info))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name params)
        line-number (ast/line-number params)
        constraints-list (c/extract-items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")
          line (line-macro params "// paramChecker")
          checked-var (genlocal 'checked)]
      (cond
       (.variadic params)
       (c-code checking-fn-var
               ["Value *" checking-fn-var
                "(List *closures, Value *args) {\n"
                line
                "int " checked-var "= 1;"
                (-> constraints
                    (c/update-var "args")
                    ;; TODO: what if runtime-check is empty?
                    (runtime-check c/top-type file-name line-number checked-var))
                "if(!" checked-var "){abort();}" line-sep
                "return(" arity-fn-var
                "(closures, args));\n};\n"]
               {} c/top-type)
       (every constraints-list (partial = c/top-type))
       (c-code arity-fn-var [] {} c/top-type)

       (c-code checking-fn-var
               ["Value *" checking-fn-var "("
                (-> param-vars
                    (map (fn [param] (str "Value *" param)))
                    (seq)
                    (conj "List *closures")
                    (interpose ", "))
                ") {\n"
                line
                "int " checked-var "= 1;"
                (for [[constraint var] (zip-lists constraints-list
                                                  param-vars)]
                  ;; TODO: what if runtime-check is empty?
                  (-> constraint
                      (c/update-var var)
                      (runtime-check c/top-type file-name line-number checked-var))) 
                "if(!" checked-var "){abort();}" line-sep
                "return(" arity-fn-var "("
                (-> param-vars
                    (seq)
                    (conj "closures")
                    (interpose ", "))
                "));\n};\n"]
               {} c/top-type)))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (comp [(c-code ""
                      [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                       "incRef((Value *)closures, 1);" line-sep
                       "Value **" destArgs "[" closure-count "] = {"
                       (interpose (map closures (fn [arg] ["&" arg])) ", ")
                       "};" line-sep
                       "destructValue(\"\", \"\", (Value *)closures"
                       ", " closure-count ", " destArgs ");" line-sep]
                      {} c/top-type)]
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] {} "" 0)))))))

(defn emit-closure-arity [fn-sym fn-context c-fn params param-vars body-exprs]
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [closures (sm/new-sm (fn [s]
                                (assert (instance? GlobalContext s))
                                (let [closures (-> s .fn-context .closed-over .closures)]
                                  (and (first closures)
                                       (maybe [closures s])))))
          closure-subs (sm/get-in-val [.fn-context .subs])
          closures-destruct (destruct-closures closures)
          body (collapse-expressions (comp closures-destruct
                                           body-exprs))
          
          result-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var body)] c/top-type)
          param-constraints (flat-map (sm/get-in-val [.fn-context .subs 0] {})
                                      (fn [sub]
                                        (get-param-constraints params sub)))
          _ (reset-fn-context fn-context)
          closed-over (ev/traverse closures (fn [[closed-over sym]]
                                              (map (lookup-sym sym)
                                                   (fn [expr]
                                                     [closed-over (.c-var expr)]))))
          _ (update-subs (typ/traverse (for [closure-sub closure-subs
                                             [closure outer] closed-over
                                             :let [closure-c (get closure-sub closure)]
                                             :when closure-c]
                                         [outer (extract closure-c)])
                                       (fn [[outer-var constraint]]
                                         (typ/append-constraint outer-var constraint file-name line-number))))
          arity-var (genlocal fn-sym "dynArity")
          closure-vars (ev/traverse closures (fn [[closed-over sym]]
                                               (for [closure (lookup-sym sym)]
                                                 (c-code ""
                                                         [arity-var "->closures = listCons((Value *)"
                                                          (.c-var closure) ", (List *)" arity-var
                                                          "->closures);" line-sep]
                                                         {(.c-var closure) 1}
                                                         (c/update-var list-constraint (str (.c-var closure)))))))

          line (line-macro fn-sym "// paramChecker")
          checked-var (genlocal 'checked)
          :let [check-params (either (for [_ (.variadic params)
                                           var-args (first param-vars)]
                                       (-> param-constraints
                                           (c/update-var var-args)
                                           (runtime-check c/top-type file-name line-number checked-var)))
                                     (for [[constraint var] (zip-lists (c/extract-items-constraints param-constraints)
                                                                       param-vars)]
                                       ;; TODO: what if runtime-check is empty?
                                       (-> constraint
                                           (c/update-var var)
                                           (runtime-check c/top-type file-name line-number checked-var))))]
          _ (declare ["Value *" c-fn "("
                      (-> param-vars
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      line
                      "if(1){int " checked-var " = 1;" line-sep
                      check-params
                      "if(!" checked-var "){abort();}}" line-sep
                      (.init body)
                      line-sep "};};\n"])
          :let [arity-init ["FnArity *" arity-var
                            " = malloc_fnArity();" line-sep
                            arity-var "->count = " (count param-vars)
                            ";" line-sep
                            arity-var "->variadic = "
                            (cond (.variadic params)
                                  "1"
                                  "0")
                            ";" line-sep
                            arity-var "->fn = " c-fn ";" line-sep
                            arity-var "->closures = empty_list;" line-sep]]
          expr (collapse-expressions (comp [(c-code arity-var arity-init {} c/top-type)]
                                           closure-vars
                                           [(c-init arity-var [] {} file-name line-number)]))]
      (ClosureArity c-fn params (cond (.variadic params)
                                      'variadic
                                      (count params))
                    expr
                    param-constraints result-constraint))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars body-exprs]
  (assert (instance? ast/params-ast params))
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [body (collapse-expressions body-exprs)
          arity-var (global-var fn-sym "staticArity")
          result-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var body)] c/top-type)
          param-constraints (flat-map (sm/get-in-val [.fn-context .subs 0] {})
                                      (fn [sub]
                                        (get-param-constraints params sub)))
          runtime-check-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)
          param-struct (encode-static param-constraints)
          rslt-struct (encode-static result-constraint)
          _ (declare ["Value *" c-fn "("
                      (-> param-vars
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\nwhile (1) {\n"
                      (.init body)
                      line-sep "};};\n"
                      (.init runtime-check-fn)
                      "FnArity " arity-var " = {FnArityType, -2, "
                      (count param-vars)
                      ", (List *)0, " (cond (.variadic params)
                                            "1"
                                            "0")
                      ", " (.c-var runtime-check-fn) ", (Value *)&" (.c-struct param-struct)
                      ", (Value *)&" (.c-struct rslt-struct)
                      "};" line-sep])]
      (let [expr (c-static-arity (ArityValPtr (str "&" arity-var) arity-var) [] {} arity-var)]
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= c/UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn (cond (.variadic params)
                                       'variadic
                                       (count params))
                     expr
                     param-constraints result-constraint)))))


(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? CFnPtr c-fn))

   ;; TODO: there are two ResultConstraint's in 'body'
   (either (and (empty? (remove body (partial instance? ast/NoCode)))
                (maybe sm/zero-sm))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 constraints (filter body (partial instance? c/Constraints))
                 body (remove body (partial instance? ast/NoCode))
                 fn-constraint (-> fn-constraint
                                   (c/update-var (str fn-var))
                                   (c/update-sym (ast/untag fn-sym)))
                 fn-sym (either (instance? ast/tagged-symbol fn-sym)
                                (ast/tag fn-sym file-name line-number))]
             (for [fn-context (reset-fn-context)
                   ;; _ (debug "------------\n" (ast/file-name fn-sym) (ast/line-number fn-sym) 'fn-arity fn-sym)
                   p-bindings (cond (.variadic params)
                                    (map (bind-param params) vector)
                                    (for [p-bindings (ev/traverse (.fixed params) bind-param)
                                          _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] '_)]
                                      p-bindings))
                   :let [param-vars (map p-bindings .bound)
                         param-destruct (cond
                                         (some body (partial instance? ast/inline-ast))
                                         []

                                         (.variadic params)
                                         (flat-map p-bindings .destruct)

                                         (comp (map param-vars
                                                    (fn [var]
                                                      (c-init var [] {}
                                                              (ast/file-name params)
                                                              (ast/line-number params))))
                                               (flat-map p-bindings .destruct)))]
                   _ (update-subs (typ/traverse (conj param-vars "#result")
                                                (fn [var]
                                                  (typ/set-constraint var c/top-type))))

                   syms get-syms
                   _ (either (map (get syms fn-sym) sm/state-maybe)
                             (set-sym fn-sym (c-code fn-var [] {} fn-constraint)))
                   body-exprs (-> (comp param-destruct constraints body)
                                  (tail-call param-vars)
                                  ;; ((fn [b] (print-err 'body "\n" (interpose b "\n")) b))
                                  (ev/traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars body-exprs))
                   ;; _ (debug "============")
                   ]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-sym arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-sym "staticArity")
          arity-impl-var (global-var (str type-str fn-sym) "arityImpl")
          c-fn (global-var (str type-str fn-sym) "arityFn")
          :let [impl-fn-var impl-fn-var
                arity-impl-var (ArityValPtr arity-impl-var "")
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (get-proto-impl proto-sym fn-sym num-args 0)
          :let [sym-map (reduce (zip-lists (-> dispatcher-info .ast .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (assoc m old-sym new-sym)))]
          param-assertions (-> dispatcher-info
                               .param-constraints
                               (replace-syms sym-map)
                               (map (fn [c]
                                      (-> c
                                          c/extract-items-constraints
                                          (map (fn [c]
                                                 (c/update-var c "")))))))
          :let [arity-ast (.body arity-ast (comp [(c/ResultConstraint (.result-constraint dispatcher-info))]
                                                 param-assertions (.body arity-ast)))]
          _ (new-static-arity impl-fn-var num-args c-fn
                              c/empty-items-constraint c/top-type)
          _ (new-proto-impl proto-sym fn-sym num-args type-num arity-impl-var arity-ast
                            c/empty-items-constraint c/top-type c-fn)
          _ (declare ["Value *" c-fn "("
                      (interpose (cons "List *closures"
                                       (seq (map (-> arity-ast .params .fixed)
                                                 (fn [param]
                                                   (str "Value *")))))
                                 ", ")
                      ");\n"
                      "FnArity *" arity-impl-var ";\n"])]
      (ProtoImplDeclaration proto-sym fn-sym
                            arity-ast
                            arity-impl-var c-fn))))

(deftype ConstrainVar [constraint]
  (assert (instance? c/ValueConstraint constraint))

  Stringable
  (string-list [_]
    (list "(ConstrainVar " (str constraint) ")"))

  Emitter
  (replace-syms [_ subs]
    (map (replace-syms constraint subs) ConstrainVar))

  (replace-bound-vars [_ subs]
    (ConstrainVar (replace-bound-vars constraint subs)))

  (emit [_]
    (either (map (c/extract-sym constraint)
                 (fn [sym]
                   (for [sym-info (-> sym
                                      (ast/tag (ast/file-name constraint) (ast/line-number constraint))
                                      lookup-sym)
                         _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                          (.c-var sym-info) constraint)]
                     empty-c-code)))
            (wrap sm/zero-sm empty-c-code))))

(defn emit-impl [type-str disp-constraint type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)
        disp-constraint (either (for [type-map (c/extract-type-map disp-constraint)
                                      :when (< 1 (count type-map))
                                      fields (get type-map type-num)]
                                  (c/TypeConstraint {type-num fields} empty-list
                                                    (symbol type-str)
                                                    (maybe (ast/untag disp-param)) ""))
                                disp-constraint)]
    (for [
          ;; _ (debug 'impl file-name line-number type-str fn-sym num-args)
          default-impl (get-proto-impl fn-sym num-args 0)
          ext-fn (comp (emit-fn-arity (symbol (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [disp-constraint
                                             (-> (.result-constraint default-impl)
                                                 (c/update-path file-name line-number)
                                                 c/ResultConstraint)]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.init reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast constraint type-num]
  (assert (instance? Integer type-num))

  (let [impl-arities (for [[proto-sym impl-fns] (seq (.impls ast))
                           [fn-name arities] (seq impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (wrap sm/zero-sm (str "_" type-num "_")))
                _ (ev/traverse (keys (.impls ast)) verify-proto-name)
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (ev/traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (ev/traverse impl-arities (partial emit-impl type-str constraint type-num))]
            (cons head-fn fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [file (ast/file-name ast)
          line (ast/line-number ast)]
      (for [reified-type-num (sm/update-val .type-counter inc)
            reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast
                                   (c/TypeConstraint {(.type-num ast) #{}} (list [file line])
                                                     (symbol (str "reified at " file ": " line))
                                                     nothing "")
                                   reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (either (map (every impl-fns (partial instance? c-static-arity))
                                        (fn [_]
                                          (static-reified-value file line
                                                                reified-type-num impl-fns)))
                                 (closure-reified-value reified-type-num impl-fns
                                                        file line))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (let [x* (ast/tag "#x")
          y* (ast/tag "#y")
          ast (cond (get-in ast [.impls Eq-sym =*-sym])
                    ast
                    (assoc-in ast [.impls Eq-sym =*-sym]
                              [(ast/fn-arity-ast
                                (str defined-sym "_EQ_QMARK_") ""
                                (ast/params [x* y*]) ""
                                [(ast/and-ast
                                  [(ast/call-ast =*-sym
                                                 [(ast/call-ast get-type-sym [x*])
                                                  (ast/call-ast get-type-sym [y*])])
                                   (ast/call-ast maybe-sym [y*])])]
                                c/empty-items-constraint c/top-type)]))]
      (for [value (init-at-runtime ast defined-sym)
            value (comp (map (lookup-declaration defined-sym)
                             (fn [c-info]
                               (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                                 (.c-var value) ";" line-sep]
                                                 (.refs-map value)
                                                 (.constraints value)
                                                 (.c-struct value))))
                        (wrap sm/zero-sm value))
            _ (new-module-def defined-sym (c-static-reified (.c-var value) [] {}
                                                            (.constraints value)
                                                            (.c-struct value)))]
        [value])))

  (tail-call [ast params]
    (TailCall ast params)))

(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          line-number (ast/line-number clause)]
      (for [syms get-syms
            expr (emit clause)
            curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)
            _ (set-syms syms)
            checked-var (genlocal 'checked)]
        (cond (= (.c-var expr) "")
              expr
              (.init expr [(.init expr)
                           (cond  (instance? c-param expr)
                                  ""
                                  (let [rt-check (-> maybe-constraint
                                                     (c/update-path file-name line-number)
                                                     (c/update-var (.c-var expr))
                                                     (runtime-check curr-const file-name line-number checked-var))]
                                    (either (empty? rt-check)
                                            ["if(1){int " checked-var " = 1;" line-sep
                                             rt-check
                                             line-sep "if(!" checked-var "){abort();}}" line-sep])))]))))))

(extend-type TailCall
  EmitCond
  (emit-cond-clause [clause]
    (emit clause)))

(extend-type Tagged
  EmitCond
  (emit-cond-clause [sym]
    (let [file-name (ast/file-name sym)
          line-number (ast/line-number sym)]
      (for [expr (emit sym)
            curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)
            checked-var (genlocal 'checked)]
        (.init expr [(.init expr)
                     (cond (instance? c-param expr)
                           ""
                           (let [rt-check (-> maybe-constraint
                                              (c/update-path file-name line-number)
                                              (c/update-var (.c-var expr))
                                              (c/update-sym (ast/untag sym))
                                              (runtime-check curr-const file-name line-number checked-var))]
                             (either (empty? rt-check)
                                     ["if(1){int " checked-var " = 1;" line-sep
                                      rt-check
                                      line-sep "if(!" checked-var "){abort();}}" line-sep])))])))))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (assert (instance? Vector init))
  (assert (instance? C-expr clause))

  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj init
           [(.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            (either (empty? cond-test)
                    [cond-test result-var ",\"\",0)) {" line-sep])
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))
        last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))
        last-init [(.init last-clause)
                   (either (= "" (.c-var last-clause))
                           [result-var " = " (.c-var last-clause) ";" line-sep])]]
    (conj clause-inits last-init)))

(defn clause-refs [exprs result-var]
  (-> (apply merge-with (list* + (map exprs .refs-map)))
      (dissoc result-var)))

(defn emit-and-expr [result-var clauses tail-return]
  (let [file-name (ast/file-name clauses)
        line-number (ast/line-number clauses)]
    (either (map (first clauses)
                 (fn [clause]
                   (for [subs (sm/get-in-val [.fn-context .subs] [])
                         expr (emit-cond-clause clause)
                         final-subs (sm/get-in-val [.fn-context .subs] [])

                         exprs (ev/traverse (rest clauses)
                                            (fn [clause]
                                              (for [_ (sm/assoc-in-val [.fn-context .subs] subs)
                                                    expr (emit-cond-clause clause)]
                                                expr)))
                         :let [exprs (comp [expr] exprs)]
                         _ (sm/assoc-in-val [.fn-context .subs] final-subs)
                         last-expr (sm/when (last exprs))
                         _ (update-subs
                            (typ/propogate-constraint (.c-var last-expr) result-var
                                                      identity file-name line-number))]
                     (let [refs-map (clause-refs exprs result-var)]
                       (c-init result-var
                               ["Value *" result-var ";" line-sep
                                (-> exprs
                                    (clause-inits "if (isNothing("  refs-map result-var)
                                    (interpose [tail-return "} else {" line-sep
                                                "dec_and_free(" result-var ", 1);" line-sep]))
                                (-> (count exprs)
                                    dec
                                    (repeat (str "}" line-sep)))]
                               refs-map file-name line-number)))))
            (wrap sm/zero-sm empty-c-code))))

(deftype TailAnd [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "andRslt")
            _ (constrain-var file-name line-number "#result" maybe-constraint)
            check-fn (global-var 'checker)
            expr (emit-and-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode))
                                (str "return(nothing);" line-sep))
            result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
            expr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr))))

(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (flat-map (genlocal "andRslt")
                (fn [result-var]
                  (emit-and-expr result-var clauses "")))))

  (tail-call [ast params]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (map (last clauses) (fn [last-c]
                                    (TailAnd (conj (butlast clauses)
                                                   (tail-call last-c params)))))
              ast)))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(defn assert-maybe-of [type-expr]
  (assert (instance? c/ValueConstraint type-expr))

  (let [path (list [(ast/file-name type-expr) (ast/line-number type-expr)])]
    (c/MultiConstraint [maybe-constraint (c/CollectionOf type-expr path nothing "")])))

(defn emit-or-expr [result-var clauses tail-return]
  (let [file-name (ast/file-name clauses)
        line-number (ast/line-number clauses)]
    (either (map (first clauses)
                 (fn [clause]
                   (for [subs (sm/get-in-val [.fn-context .subs] [])
                         expr (emit-cond-clause clause)
                         final-subs (sm/get-in-val [.fn-context .subs] [])

                         expr-cs (ev/traverse (rest clauses)
                                              (fn [clause]
                                                (for [_ (sm/assoc-in-val [.fn-context .subs] subs)
                                                      expr (emit-cond-clause clause)
                                                      constraint (sm/get-in-val [.fn-context .subs 0 (.c-var expr)]
                                                                                c/top-type)]
                                                  [constraint expr])))
                         _ (sm/assoc-in-val [.fn-context .subs] final-subs)
                         ;; TODO: do I really need to do this?
                         ;; appears so, but see if there's a different way
                         exprs (ev/traverse expr-cs
                                            (fn [[c expr]]
                                              (map (constrain-var
                                                    file-name line-number (.c-var expr)
                                                    (either (c/compose-constraints file-name line-number
                                                                                   c maybe-constraint)
                                                            (abort)))
                                                   (fn [_]
                                                     expr))))
                         :let [result-c (-> expr-cs
                                            (map (fn [[c]]
                                                   (c/extract-contents-constraint c)))
                                            c/sum-type
                                            assert-maybe-of
                                            (c/update-path file-name line-number))]
                         _ (constrain-var file-name line-number result-var result-c)]
                     (let [exprs (comp [expr]
                                       (map expr-cs (fn [[_ expr]] expr)))
                           refs-map (clause-refs exprs result-var)]
                       (c-init result-var
                               ["Value *" result-var ";" line-sep
                                (-> exprs
                                    (clause-inits "if (!isNothing(" refs-map result-var)
                                    (interpose [tail-return "} else {" line-sep
                                                "dec_and_free(" result-var ", 1);" line-sep]))
                                (-> (count exprs)
                                    dec
                                    (repeat (str "}" line-sep)))]
                               refs-map file-name line-number)))))
            (wrap sm/zero-sm empty-c-code))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "orRslt")
            _ (constrain-var file-name line-number "#result" maybe-constraint)
            check-fn (global-var 'checker)
            expr (emit-or-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode))
                               (str "return(" check-fn "(" result-var "));" line-sep))
            result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
            expr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr))))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-or-expr result-var (remove (.clauses ast) (partial instance? ast/NoCode))
                              line-sep))))

  (tail-call [ast params]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (map (last clauses) (fn [last-c]
                                    (TailOr (conj (butlast clauses)
                                                  (tail-call last-c params)))))
              ast)))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      ;; TODO: this is so fantastically wrong.
      ;; How does the alt result-var get constrained?
      (for [result-var (genlocal "tailEither_rslt")
            cond-val (emit-cond-clause clause)
            alt-val (emit alt)
            result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
            cond-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var cond-val)] c/top-type)
            alt-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var alt-val)] c/top-type)
            :let [expr-const (-> (c/sum-type [(c/extract-contents-constraint cond-constraint)
                                              alt-constraint])
                                 (c/update-path file-name line-number))]
            _ (constrain-var file-name line-number result-var expr-const)
            _ (set-result-constraint result-var file-name line-number)
            checked-var (genlocal 'checked)]
        (let [cond-rslt (.c-var cond-val)
              refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
          (c-code result-var
                  [(.init cond-val)
                   "Value *" result-var ";" line-sep
                   "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                   result-var " = maybeExtract(" cond-rslt ");" line-sep
                   (map (seq (.refs-map alt-val))
                        (fn [[c-sym remaining]]
                          (either (and (= 0 remaining)
                                       (maybe ""))
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                   (let [rt-check (runtime-check (c/update-var result-const result-var)
                                                 expr-const file-name line-number checked-var)]
                     (either (empty? rt-check)
                             ["int " checked-var " = 1;" line-sep
                              rt-check
                              line-sep "if(!" checked-var "){abort();}"]))
                   "return(" result-var ");" line-sep
                   "} else {" line-sep
                   "dec_and_free(" cond-rslt ", 1);" line-sep
                   (.init alt-val)
                   (either (= "" (.c-var alt-val))
                           [result-var " = " (.c-var alt-val) ";" line-sep])
                   "}" line-sep]
                  refs-map
                  c/top-type))))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "eitherRslt")
            cond-val (emit-cond-clause (.clause ast))
            syms get-syms
            alt-val (emit (.alt ast))
            _ (set-syms syms)
            cond-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var cond-val)] c/top-type)
            alt-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var alt-val)] c/top-type)
            _ (constrain-var file-name line-number result-var
                             (c/sum-type [(c/extract-contents-constraint cond-constraint)
                                          alt-constraint]))]
        (let [cond-rslt (.c-var cond-val)
              refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                           (filter-vals (partial < 0)))]
          (c-init result-var
                  [(.init cond-val)
                   "Value *" result-var ";" line-sep
                   "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                   result-var " = maybeExtract(" cond-rslt ");" line-sep
                   (map (seq (.refs-map alt-val))
                        (fn [[c-sym remaining]]
                          (either (and (= 0 remaining)
                                       (maybe ""))
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                   "} else {" line-sep
                   "dec_and_free(" cond-rslt ", 1);" line-sep
                   (.init alt-val)
                   result-var " = " (.c-var alt-val) ";" line-sep
                   "}" line-sep]
                  refs-map file-name line-number)))))

  (tail-call [ast params]
    (TailEither (.clause ast)
                (tail-call (.alt ast) params)))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))

(extend-type ast/cond-val-ast
  EmitCond
  (emit-cond-clause [ast]
    (let [file-name (ast/file-name (.value ast))
          line-number (ast/line-number (.value ast))]
      (for [cond-val (emit-cond-clause (.conditional ast))
            final-subs (sm/get-in-val [.fn-context .subs] [])
            syms get-syms
            value (emit (.value ast))
            _ (sm/assoc-in-val [.fn-context .subs] final-subs)
            _ (set-syms syms)
            result-var (genlocal "cvRslt")
            do-value (genlocal "doValue")]
        (let [refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map value))
                           (filter-vals (partial < 0)))]
          (c-init result-var
                  [(.init cond-val)
                   "Value *" result-var " = " (.c-var cond-val) ";" line-sep
                   "int " do-value " = !isNothing(" result-var ",\"\",0);" line-sep
                   "if (" do-value ") {" line-sep
                   "dec_and_free(" result-var ", 1);" line-sep
                   (.init value)
                   result-var " = " (.c-var value) ";" line-sep
                   "} else {" line-sep
                   (map (seq (.refs-map value)) (fn [[c-sym remaining]]
                                                  (either (and (= 0 remaining)
                                                               (maybe ""))
                                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                   "}" line-sep "if (" do-value ") {" line-sep]
                  refs-map file-name line-number)))))

  Emitter
  (replace-syms [ast subs]
    (for [new-condit (replace-syms (.conditional ast) subs)
          new-value (replace-syms (.value ast) subs)]
      (ast/cond-val-ast new-condit new-value)))

  (replace-bound-vars [ast subs]
    (ast/cond-val-ast (replace-bound-vars (.conditional ast) subs)
                      (replace-bound-vars (.value ast) subs))))

(defn emit-cond-expr [ast result-var tail-return]
    (let [[clause & clauses] (.conditionals ast)
          file-name (ast/file-name clause)
          line-number (ast/line-number clause)]
      (for [subs (sm/get-in-val [.fn-context .subs] [])
            expr (emit-cond-clause clause)
            first-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)]
                                     c/top-type)
            final-subs (sm/get-in-val [.fn-context .subs] [])

            expr-cs (ev/traverse clauses
                                 (fn [clause]
                                   (for [_ (sm/assoc-in-val [.fn-context .subs] subs)
                                         expr (emit-cond-clause clause)
                                         constraint (sm/get-in-val [.fn-context .subs 0 (.c-var expr)]
                                                                   c/top-type)]
                                     [constraint expr])))
            _ (sm/assoc-in-val [.fn-context .subs] subs)
            default-expr (emit (.default ast))
            def-const (sm/get-in-val [.fn-context .subs 0 (.c-var default-expr)]
                                     c/top-type)
            _ (sm/assoc-in-val [.fn-context .subs] final-subs)
            :let [exprs (comp [expr]
                              (map expr-cs (fn [[_ expr]] expr))
                              [default-expr])
                  result-c (-> expr-cs
                               (map (fn [[c]] c))
                               (conj def-const)
                               (conj first-const)
                               c/sum-type
                               (c/update-path file-name line-number))]
            _ (constrain-var file-name line-number result-var result-c)]
        (let [refs-map (clause-refs exprs result-var)
              [exprs] (reduce (rest exprs) [[expr ] (.c-var expr)]
                              (fn [[exprs prev-var] expr]
                                [(conj exprs (.init expr ["dec_and_free(" prev-var ", 1);" line-sep
                                                          (.init expr)]))
                                 (.c-var expr)]))]
          (c-init result-var
                  ["Value *" result-var ";" line-sep
                   (-> exprs
                       (clause-inits "" refs-map result-var)
                       (interpose [tail-return "} else {" line-sep]))
                   (-> (count exprs)
                       dec
                       (repeat (str "}" line-sep)))]
                  refs-map file-name line-number)))))

(deftype TailCond [conditionals default]
  Stringable
  (string-list [_]
    (list "(TailCond " (str conditionals) " " (str default) ")"))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name conditionals))

  (ast/line-number [_]
    (ast/line-number conditionals))

  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [result-var (genlocal "condRslt")
            check-fn (global-var 'checker)
            expr (emit-cond-expr ast result-var 
                                 (str "return(" check-fn "(" result-var "));" line-sep))
            result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
            expr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            checked-var (genlocal 'checked)
            _ (declare ["Value *" check-fn "(Value *arg){" line-sep
                        (let [rt-check (runtime-check (c/update-var result-const "arg")
                                                      expr-const file-name line-number checked-var)]
                          (either (empty? rt-check)
                                  ["int " checked-var " = 1;" line-sep
                                   rt-check
                                   line-sep "if(!" checked-var "){abort();}"]))
                        line-sep "return(arg);}" line-sep])
            _ (set-result-constraint (.c-var expr) file-name line-number)]
        expr)))

  (tail-call [ast _]
    ast)

  (replace-syms [ast subs]
    (for [new-condits (replace-syms (.conditionals ast) subs)
          new-value (replace-syms (.default ast) subs)]
      (TailCond new-condits new-value)))

  (replace-bound-vars [ast subs]
    (TailCond (replace-bound-vars (.conditionals ast) subs)
              (replace-bound-vars (.default ast) subs))))

(extend-type ast/cond-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "condRslt")
          expr (emit-cond-expr ast result-var "")]
      expr))

  (tail-call [ast params]
    (TailCond (.conditionals ast)
              (tail-call (.default ast) params)))

  (replace-syms [ast subs]
    (for [new-condits (replace-syms (.conditionals ast) subs)
          new-value (replace-syms (.default ast) subs)]
      (ast/cond-ast new-condits new-value)))

  (replace-bound-vars [ast subs]
    (ast/cond-ast (replace-bound-vars (.conditionals ast) subs)
                  (replace-bound-vars (.default ast) subs))))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [
          ;; _ (debug "=======\n*** " 'main-fn)
          ;; TODO: add param assertions
          fn-arity (emit-fn-arity (ast/tag 'main) "" (.params ast) (.body ast))
          ;; _ (debug "======= done main")
          _ (new-static-arity 'main 1 (.c-fn fn-arity)
                              c/empty-items-constraint c/top-type)]
      [empty-c-code])))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (ev/traverse arities
                                     (fn [static-arity]
                                       (for [_ (new-static-arity fn-var
                                                                 (.param-count static-arity)
                                                                 (.c-fn static-arity)
                                                                 (.param-constraints static-arity)
                                                                 (.result-constraint static-arity))]
                                         (.var-info static-arity))))
        :let [arity-count (count emitted-arities)
              fn-constraint (c/update-path fn-constraint
                                           (ast/file-name fn-sym) (ast/line-number fn-sym))]
        _ (constrain-var (ast/file-name fn-sym) (ast/line-number fn-sym)
                         fn-var fn-constraint)
        _ (declare ["Function " struct-var " = {FunctionType, -2, \""
                    fn-sym "\", " arity-count ", "
                    "{" (to-str (interpose (map emitted-arities .c-var)
                                           ", "))
                    "}};\n"
                    "Value *" fn-var " = (Value *)&" struct-var ";\n\n"])]
    (cond
     (= fn-sym 'list)
     (c-list-fn fn-var [] {} struct-var)

     (= fn-sym 'maybe)
     (c-maybe-fn fn-var [] {} struct-var)

     (= fn-sym 'vector)
     (c-vector-fn fn-var [] {} struct-var)

     (c-static-fn fn-var [] {}
                  fn-constraint struct-var
                  (reduce arities {}
                          (fn [m arity]
                            (assoc m (.param-count arity) arity)))))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities (partial instance? ClosureArity)))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))
        :let [emitted-arities (map arities .var-info)]]
    (let [arity-count (count arities)]
      (c-closure-fn (str fn-var)
                    [(map emitted-arities .init)
                     line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
                     struct-var "->name = \"" fn-sym "\";" line-sep
                     struct-var "->arityCount = " arity-count ";" line-sep
                     (map (zip-lists (map emitted-arities .c-var)
                                     (range arity-count))
                          (fn [[sym index]]
                            (str struct-var "->arities[" index "] = " sym ";" line-sep)))
                     "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
                    (apply merge-with (list* + (map emitted-arities .refs-map)))
                    (reduce arities {}
                            (fn [m arity]
                              (assoc m (.param-count arity) arity)))
                    (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn call-universal-proto-fn [fn-sym disp-arg args]
  (let [args (cons disp-arg args)]
    (str "Value *protoRslt;\n"
         "if (universalProtoFn != 0){\n"
         "  List *args = empty_list;\n"
         (to-str (flat-map (reverse args)
                           (fn [arg]
                             (list "  args = listCons(" "(Value *)" arg ", args);\n"))))
         "  args = listCons(symbol(stringValue(\"" fn-sym "\")), args);\n"
         "  args = listCons(stringValue(\"" (ast/file-name fn-sym) "\"), args);\n"
         "  protoRslt = fnApply(universalProtoFn, (Value *)args);\n"
         "  if (protoRslt->type == MaybeType && !isNothing(protoRslt,\"\",0)) {\n"
         "    Value *result = ((Maybe *)protoRslt)->value;\n"
         "    incRef(result, 1);\n"
         "    dec_and_free(protoRslt, 1);\n"
         "    dec_and_free(" disp-arg ", 1);\n"
         "    return(result);\n"
         "}\n} else {\n"
         (to-str (flat-map args (fn [arg]
                                  (list
                                   "  dec_and_free(" arg ", 1);\n"))))
         "protoRslt = nothing;}\n")))

(deftype InsertCode [fn-sym prototype]
  Stringable
  (string-list [_]
    (list "<InsertCode>"))

  Emitter
  (emit [_]
    (let [num-args (-> prototype .params .fixed count)
          [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                            (range num-args))
                                 (fn [[arg idx]]
                                   (either (check-C-var (str arg "_" idx))
                                           (str "arg" idx))))]
      (sm/state-maybe (c-code "protoRslt"
                              [(call-universal-proto-fn fn-sym disp-arg args)]
                              (reduce args {disp-arg 1}
                                      (fn [m arg]
                                        (assoc m arg 1)))
                              c/top-type)))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (let [num-args (-> prototype .params .fixed count)
        [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                          (range num-args))
                               (fn [[arg idx]]
                                 (either (check-C-var (str arg "_" idx))
                                         (str "arg" idx))))]
    (comp (filter (.default-body prototype) (partial instance? c/Constraints))
          [(c-code ""
                   ["incRef(" disp-arg ", 1);"
                    ;; TODO: maybe use 'InsertCode' instead
                    (call-universal-proto-fn fn-sym disp-arg args)
                    (to-str (line-marker (ast/file-name fn-sym) (ast/line-number fn-sym) ""))
                    "if (closures != (List *)0) {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments %s\\n\", "
                    "((String *)type_name((List *)0, " disp-arg "))->buffer, " num-args
                    ", ((String *)closures)->buffer);abort();"
                    "} else {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments.\\n\", "
                    "((String *)type_name((List *)0, " disp-arg "))->buffer, " num-args ");abort();"
                    "}"]
                   (reduce args {disp-arg 1}
                           (fn [m arg]
                             (assoc m arg 1)))
                   c/top-type)])))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [default-body (missing-impl-body protocol-sym fn-sym prototype)
        default-constraints (filter (.default-body prototype)
                                    (partial instance? c/Constraints))
        body (remove (.default-body prototype) (partial instance? ast/NoCode))
        arity-ast (ast/fn-arity (.params prototype) ""
                                (cond (empty? body)
                                      default-body
                                      body))
        params (.params prototype)]
    (for [arity-impl-var (map (global-var (str "Default_" fn-sym) "arityImpl")
                              ProtoDispFnPtr)
          fn-context (reset-fn-context)

          ;; create vars for all the parameters
          ;; TODO: this could probably be simplified after 'bind-list' is refactored
          p-bindings (cond (.variadic params)
                           (map (bind-param params) vector)
                           (ev/traverse (.fixed params) bind-param))

          ;; clear any constraints for the parameter vars
          _ (update-subs (-> p-bindings
                             (map .bound)
                             (typ/traverse (fn [var]
                                             (typ/set-constraint var c/top-type)))))

          ;; constrain those vars with the given assertions
          _ (ev/traverse default-constraints emit)

          ;; save the constraints specified for the parameters
          pcs (flat-map (sm/get-in-val [.fn-context .subs 0] {})
                        (fn [sub]
                          (get-param-constraints params sub)))
          _ (reset-fn-context fn-context)

          ;; compute the given result constraints
          result-constraint (-> (.default-body prototype)
                                (filter (partial instance? c/ResultConstraint))
                                (map .assertion)
                                (ev/traverse to-constraint)
                                (map (fn [result-constraints]
                                       (reduce result-constraints c/top-type c/intersect))))

          ;; emit the default proto function
          static-arity (emit-fn-arity (symbol (str "Default_" fn-sym)) disp-fn-var params
                                      (comp default-constraints
                                            (cond (empty? body)
                                                  default-body
                                                  [(ast/either-ast
                                                    (InsertCode fn-sym prototype)
                                                    (ast/let-ast [] body))]))
                                      arity-impl-var)

          :let [param-count (.param-count static-arity)
                default-impl (ProtoImpl 0 (.c-var (.var-info static-arity)) arity-ast
                                        pcs result-constraint arity-impl-var)]
          
          _ (sm/assoc-in-val [.fns disp-fn-var param-count .param-constraints] pcs)
          _ (sm/assoc-in-val [.fns disp-fn-var param-count .result-constraint] result-constraint)

          ;; this is the info used to emit the implementations
          _ (comp (sm/update-in-val [.modules (ast/file-name protocol-sym) .protocols
                                     (ast/untag protocol-sym) (ast/untag fn-sym)]
                                    (fn [p-disp]
                                      (assert (instance? ev/ProtoDispatcher p-disp))
                                      (assoc-in p-disp [.p-impls param-count 0]
                                                default-impl)))
                  (sm/assoc-in-val [.modules (ast/file-name protocol-sym) .protocols
                                    (ast/untag protocol-sym) (ast/untag fn-sym)]
                                   (ev/ProtoDispatcher (ast/untag fn-sym)
                                                       (cond (= 'core (ast/file-name protocol-sym))
                                                             ""
                                                             (ast/file-name protocol-sym))
                                                       {param-count {'param-consts pcs
                                                                     0 default-impl}}
                                                       ev/empty-state)))]
      static-arity)))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [_ (emit (ast/quoted-ast proto-sym))
        _ (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        arities-info (ev/traverse arities
                                  (fn [arity]
                                    (let [arg-count (count (.params arity))]
                                      (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                            _ (new-static-arity fn-var arg-count (ProtoDispFnPtr c-fn)
                                                                c/empty-items-constraint
                                                                c/top-type)]
                                        ["Value *" c-fn "("
                                         (-> (map (range arg-count) (fn [n] (str "Value *arg" n)))
                                             (conj "List *closures")
                                             (interpose ", "))
                                         ");\n"]))))
        _ (declare ["\n// proto fn for " proto-sym "/" fn-sym "\n"
                    "\n// --------- " fn-sym " -------------\n"
                    "Value *" fn-var ";\n"
                    arities-info])
        _ (new-module-def fn-sym (c-protocol-fn fn-var [] {} fn-constraint "" {}))
        default-fns (ev/traverse arities (partial emit-proto-default proto-sym fn-sym fn-var))
        :let [default-arities (reduce default-fns {}
                                      (fn [m arity]
                                        (assoc m (.param-count arity) arity)))]
        _ (sm/assoc-in-val [.modules (ast/file-name fn-sym) .values fn-sym .arities]
                           default-arities)]
    []))

(defn unique-protocol [proto-sym]
  ;; Ensure all protocol symbols are unique
  (comp (for [proto-info (comp (sm/get-in-val [.modules (ast/file-name proto-sym)
                                               .protocols (ast/untag proto-sym)])
                               (sm/get-in-val [.modules 'core .protocols (ast/untag proto-sym)]))]
          (do
            (print-err  "Duplicate protocol"
                        (str "'" proto-sym "'") "at"
                        (str (ast/file-name proto-sym) ":")
                        (ast/line-number proto-sym))
            (abort)))
        (wrap sm/zero-sm '_)))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (unique-protocol proto-name)
            decl (ev/traverse (seq prototype-map)
                              (partial create-dispatcher proto-name))]
        [empty-c-code]))))


(extend-type ast/fn-arity-ast
  Emitter
  (unwrap-tail [ast]
    (.body ast (unwrap-tail (.body ast))))

  (emit [ast]
    ;; TODO: doesn't look like the arity's ast gets saved
    (emit-fn-arity (cond (= "" (.fn-sym ast))
                         'anon
                         (.fn-sym ast))
                   (str (.fn-var ast)) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (let [fixed-args (take arg-asts (count (.fixed (.params ast))))
          new-bindings (conj (make-bindings (.fixed (.params ast)) fixed-args)
                             (ast/binding-ast (either (.variadic (.params ast))
                                                      (ast/tag "#_"))
                                              (ast/call-ast list-sym
                                                            (-> arg-asts
                                                                (drop (count (.fixed (.params ast))))
                                                                vec))))]
      (replace-syms (ast/let-ast new-bindings (.body ast))
                    (reduce new-bindings {} (fn [m binding]
                                              (assoc m (.binding binding)
                                                     (ast/tag (.binding binding)
                                                              (ast/file-name arg-asts)
                                                              (ast/line-number arg-asts))))))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (ast/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (either (map (.fn-sym ast)
                   (fn [fn-sym]
                     (for [ ;; _ (debug "=========")
                           ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                           fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                                        (global-var fn-sym "fn"))
                           _ (declare ["\n// --------- " fn-sym " -------------\n"
                                       "Value *" fn-var ";\n"])
                           _ (constrain-var file-name line-number fn-var fn-constraint)
                           arities (ev/traverse (map (.arities ast) (fn [arity]
                                                                      (-> arity
                                                                          (.fn-sym fn-sym)
                                                                          (.fn-var fn-var))))
                                                emit)
                           fn-expr (comp (closure-fn fn-sym fn-var arities)
                                         (static-fn fn-sym fn-var arities))
                           ;; _ (debug "---------")
                           ]
                       fn-expr)))
              (for [fn-var (global-var "fn")
                    _ (declare ["Value *" fn-var ";\n"])
                    _ (constrain-var file-name line-number fn-var fn-constraint)
                    arities (ev/traverse (.arities ast) emit)
                    fn-expr (comp (closure-fn (str "anonymous function at "
                                                   (ast/file-name ast) ": " (ast/line-number ast))
                                              fn-var arities)
                                  (static-fn (str "anonymous function at "
                                                  (ast/file-name ast) ": " (ast/line-number ast))
                                             fn-var arities))]
                fn-expr))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params]
    (TailCall x params))

  (inline-expr [ast arg-asts]
    (either (map (-> (.arities ast)
                     (filter (fn [arity]
                               (= (count arg-asts) (count (.params arity)))))
                     first)
                 (fn [arity] 
                   (inline-expr arity arg-asts)))
            sm/zero-sm))

  (replace-syms [ast subs]
    (for [new-arities (ev/traverse (.arities ast)
                                   (fn [arity]
                                     (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [constraint (to-constraint (c/TypeConstraint {} empty-list type-sym nothing ""))
                  fns (flat-map (get-type-sym-info type-sym)
                                (fn [constraint]
                                  (-> (either (c/extract-type-map constraint)
                                              {})
                                      keys
                                      (ev/traverse (partial extend-type* ast constraint))
                                      (map flatten))))]
              fns)
            (compilation-error "Could not extend type: "
                               (str "'" type-sym "'") "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn emit-constructor [new-type-name type-num new-type-constraint fields assertions]
 (assert (instance? ast/tagged-symbol new-type-name))
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? (vector-of Symbol) fields))
  (assert (instance? c/ItemsConstraint assertions))

  (let [file-name (ast/file-name new-type-name)
       line-number (ast/line-number new-type-name)
        x* (ast/tag "#x")
        y* (ast/tag "#y")
        field-count (count fields)
        args (map (range field-count)
                  (fn [n]
                    (ast/tag (symbol (str "arg" n)))))
        args-map (reduce (zip-lists fields args) {}
                         (fn [m [k v]]
                           (assoc m k v)))]
    (for [assertions (replace-syms assertions args-map)
          reified-type-num (sm/update-val .type-counter inc)
          :let [ast (ast/reified (maybe reified-type-num)
                                 {(ast/tag Eq-sym file-name line-number)
                                  {(ast/tag =*-sym file-name line-number)
                                   [(ast/fn-arity-ast
                                     (str new-type-name "_EQ_QMARK_") ""
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast =*-sym
                                                      [type-num
                                                       (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast maybe-sym [y*])])]
                                     c/empty-items-constraint c/top-type)]}

                                  (ast/tag Type-sym file-name line-number)
                                  {type-name-sym
                                   [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                                      (ast/params [(ast/tag '_)]) ""
                                                      [(str "*" new-type-name " constructor*")]
                                                      c/empty-items-constraint c/top-type)]
                                   type-mapping-sym
                                   [(ast/fn-arity-ast (str new-type-name "_const_type_map") ""
                                                      (ast/params [(ast/tag '_)]) ""
                                                      [(map-vals (.type-maps new-type-constraint)
                                                                 (fn [field-set]
                                                                   (map field-set ast/quoted-ast)))]
                                                      c/empty-items-constraint c/top-type)]
                                   instance?-sym
                                   [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                                      (ast/params [x* y*]) ""
                                                      [(ast/and-ast
                                                        [(ast/call-ast =*-sym
                                                                       [type-num
                                                                        (ast/call-ast get-type-sym [y*])])
                                                         (ast/call-ast maybe-sym [y*])])]
                                                      c/empty-items-constraint c/top-type)]}

                                  (ast/tag Function-sym file-name line-number)
                                  {invoke-sym
                                   [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                                      (ast/params (comp [(ast/tag '_)] args)) ""
                                                      (comp
                                                       (c/extract-items-constraints assertions)
                                                       [(c/update-var new-type-constraint "#result")
                                                        (ast/inline-ast (ast/tag 'C)
                                                         (maybe new-type-name)
                                                         (str "ReifiedVal *rv = malloc_reified("
                                                              field-count ");\n"
                                                              "#ifdef SINGLE_THREADED\n"
                                                              "rv->refs = refsInit;\n#else\n"
                                                              " __atomic_store(&rv->refs,"
                                                              " &refsInit, __ATOMIC_RELAXED);\n"
                                                              "#endif\n"
                                                              "rv->type = " type-num ";\n"
                                                              (to-str (map (range field-count)
                                                                           (fn [idx]
                                                                             (str "rv->impls[" idx "] = arg" idx
                                                                                  "_" (inc idx) ";\n"))))
                                                              "return((Value *)rv);\n")
                                                         "" 0)])
                                                      c/empty-items-constraint c/top-type)]}

                                  (ast/tag Container-sym file-name line-number)
                                  {apply-sym
                                   [(ast/fn-arity-ast (str new-type-name "_apply_ST_") ""
                                                      (ast/params [(ast/tag '_) (ast/tag 'fields)]) ""
                                                      [(-> (c/MultiConstraint [vect-constraint assertions])
                                                           (c/update-path file-name line-number)
                                                           (c/update-var "fields_1"))

                                                       (ast/inline-ast (ast/tag 'C)
                                                                       (maybe new-type-name)
                                                                       (str "return(newTypeValue(" type-num
                                                                            ", (Vector *)fields_1));")
                                                                       "" 0)]
                                                      c/empty-items-constraint c/top-type)]}

                                  (ast/tag Stringable-sym file-name line-number)
                                  {string-list-sym
                                   [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                                  [(ast/call-ast list-sym
                                                                 ["<ValueConstructor " (str new-type-name) " ["
                                                                  (to-str (interpose fields ", "))
                                                                  "]>"])])]}})]
          value (init-at-runtime ast new-type-name)
          expr (comp (map (lookup-declaration new-type-name)
                          (fn [c-info]
                            (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                              (.c-var value) ";" line-sep]
                                              (.refs-map value)
                                              (.constraints value)
                                              (.c-struct value))))
                     (wrap sm/zero-sm value))
          _ (new-module-def new-type-name (c-constructor (.c-var expr) [] {}
                                                         (.constraints expr)
                                                         (.c-struct expr)
                                                         type-num fields))]
      [expr])))

(defn default-type-impls [type-sym type-num fields]
  (let [x* (ast/tag "#x")
        y* (ast/tag "#y")
        field* (ast/tag "#field")
        ctxt* (ast/tag "#ctxt")]
    {Type-sym
     [[type-name-sym
       [(ast/fn-arity-ast (str type-sym "_type_name") ""
                          (ast/params [x*]) ""
                          [(str type-sym)]
                          c/empty-items-constraint c/top-type)]]
      [has-field-sym
       [(ast/fn-arity-ast
         (str type-sym "_has_field") ""
         (ast/params [x* field*]) ""
         [(ast/or-ast
           (conj (map fields
                      (fn [field]
                        (ast/call-ast identical-sym
                                      [(ast/tag (str "." field))
                                       field*])))
                 nothing-sym))]
         c/empty-items-constraint c/top-type)]]]

     Eq-sym
     [[=*-sym
       [(ast/fn-arity-ast
         (str type-sym "_EQ_STAR_") ""
         (ast/params [x* y*]) ""
         [(ast/and-ast
           [(ast/call-ast
             =*-sym [(ast/call-ast get-type-sym [x*])
                     (ast/call-ast get-type-sym [y*])])
            (ast/call-ast
             =*-sym [(ast/call-ast default-type-args-sym [x*])
                     (ast/call-ast default-type-args-sym [y*])])
            (ast/call-ast maybe-sym [x*])])]
         c/empty-items-constraint c/top-type)]]]

     Associative-sym
     [[get-symb
       [(ast/fn-arity-ast
         (str type-sym "_get") ""
         (ast/params [x* field*]) ""
         [(ast/and-ast
           [(ast/call-ast has-field-sym [x* field*])
            (ast/call-ast maybe-sym
                          [(ast/call-ast field* [x*])])])]
         c/empty-items-constraint c/top-type)]]

      [assoc-sym
       [(ast/fn-arity-ast
         (str type-sym "_assoc_") ""
         (ast/params [x* field* (ast/tag 'new-value)]) ""
         [(ast/cond-ast
           [(ast/cond-val-ast (ast/call-ast has-field-sym [x* field*])
                              (ast/call-ast field* [x* 'new-value]))]
           x*)]
         c/empty-items-constraint c/top-type)]]]

     Hashable-sym
     [[sha1-update-sym
       [(ast/fn-arity-ast
         (str type-sym "_sha1_update") ""
         (ast/params [x* ctxt*]) ""
         [(ast/call-ast sha1-update-type-sym [x* ctxt*])
          (ast/call-ast
           sha1-update-sym
           [(ast/call-ast default-type-args-sym [x*]) ctxt*])]
         c/empty-items-constraint c/top-type)]]
      [sha1-sym
       [(ast/fn-arity-ast
         (str type-sym "_sha1") ""
         (ast/params [x*]) ""
         [(ast/call-ast
           sha1-finalize-sym
           [(ast/call-ast
             sha1-update-sym
             [x* (ast/call-ast sha1-init-sym [])])])]
         c/empty-items-constraint c/top-type)]]]}))

(defn declare-getters [new-type-name fields]
  (ev/traverse fields
               (fn [field]
                 (let [getter-sym (ast/tag (str "." field) 'core 0)]
                   (comp (map (sm/get-in-val [.modules 'core .protocols (ast/untag Type-sym) (ast/untag getter-sym)])
                              (fn [_] []))
                         (create-dispatcher Type-sym
                                            [getter-sym
                                             [(ast/prototype getter-sym
                                                             (ast/params [(ast/tag "#x")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint (ast/untag getter-sym)
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])
                                              (ast/prototype getter-sym
                                                             (ast/params [(ast/tag "#x") (ast/tag "#y")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint (ast/untag getter-sym)
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])]]))))))

(defn create-getters [sym fields field-constraints]
  (let [type-value (ast/tag "#value")
        field-arg (ast/tag "#field")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [field-constraint (c/update-path field-constraint
                                                  (ast/file-name sym) (ast/line-number sym))]
              [(ast/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value field-arg]) ""
                                  [(c/update-sym field-constraint (ast/untag field-arg))
                                   (ast/inline-ast (ast/tag 'C) (maybe sym)
                                                   (str "return(updateField(value_0, field_1, "
                                                        field-index "));\n")
                                                   "" 0)]
                                  c/empty-items-constraint c/top-type)
                (ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value]) ""
                                  [(c/ResultConstraint (c/clear-sym field-constraint))
                                   (ast/inline-ast (ast/tag 'C) nothing
                                                   (str "
  Value *result = incRef(((ReifiedVal *)value_0)->impls[" field-index "], 1);
  dec_and_free(value_0, 1);
  return(result);
")
                                                   "" 0)]
                                  c/empty-items-constraint c/top-type)]])))}))

(defn destruct-impl-fields [type-const field-constraints ast arity]
  (assert (instance? ast/type-ast ast))

  (let [[type-value-parameter] (.fixed (.params arity))
        fields (.fixed (.fields ast))
        field-count (count fields)
        body-exprs (remove (.body arity) (partial instance? c/Constraints))
        body-exprs (either (flat-map (last body-exprs) 
                                     (fn [last-expr]
                                       (store body-exprs (dec (count body-exprs))
                                              (CollectFieldConsts (.fields ast) last-expr))))
                           body-exprs)
        new-body (comp (filter (.body arity) (partial instance? c/Constraints))
                       [(ConstrainVar (c/update-sym type-const (ast/untag type-value-parameter)))
                        (-> (zip-lists fields
                                       (range field-count))
                            (map (fn [[field-sym index]]
                                   (ast/binding field-sym
                                     (ast/call-ast get-field-sym
                                                   [type-value-parameter index]))))
                            vec
                            (ast/let-ast (-> (c/extract-items-constraints field-constraints)
                                             (map ConstrainVar)
                                             (comp body-exprs))))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str (.sym ast) "_" fn-name)))))

(defn destructure-fields [type-const field-constraints ast]
  (let [impls (comp* {} (-> (.impls ast)
                            (filter (partial instance? HashMap))))]
    (map-vals impls
              (fn [impl-arities]
                (map (seq impl-arities)
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields type-const field-constraints ast))]))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'TypeConstraint c/TypeConstraintType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      'MultiConstraint c/MultiConstraintType
                      'ResultConstraint c/ResultConstraintType
                      'ItemsConstraint c/ItemsConstraintType
                      'FieldConstraint c/FieldConstraintType
                      'StaticIntConstraint c/StaticIntConstraintType
                      'MinValue c/MinValueType
                      'MaxValue c/MaxValueType
                      'InferredInner c/InferredInnerType
                      'StaticLengthConstraint c/StaticLengthConstraintType
                      'StaticStrConstraint c/StaticStrConstraintType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (map (get pre-defed-types type-symbol)
               sm/state-maybe)
          (sm/update-val .type-counter inc)))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (ast/untag (.sym ast))
          fields (-> ast
                     .fields
                     all-symbols
                     (map ast/untag))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) (partial instance? c/ValueConstraint))]
      (comp (for [_ (comp (sm/get-in-val [.modules file-name .types sym])
                          (sm/get-in-val [.modules 'core .types sym]))
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (cond (= file-name 'core)
                                                  "$TOCCATA_DIR/core.toc"
                                                  file-name)
                                            ", " line-number))]
              "")

            (for [type-num (new-type-number sym)
                  :let [type-map {type-num (-> fields
                                               (map (fn [name]
                                                      (symbol (str "." name))))
                                               set)}
                        new-type-constraint (c/TypeConstraint type-map (list [file-name line-number])
                                                              (.sym ast) nothing "")]
                  _ (emit-definition (ast/declaration-ast (.sym ast)))
                  _ (sm/assoc-in-val [.modules file-name .types sym] new-type-constraint)
                  _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                  _ (declare-getters sym fields)

                  ;; TODO: this whole section is bogus
                  field-assertions (ev/traverse field-assertions to-constraint)
                  :let [field-map (reduce field-assertions
                                          {} (fn [m c]
                                               (validate-field c m fields file-name line-number)))
                        field-constraints (c/ItemsConstraint
                                           (map fields (fn [field]
                                                         (either (get field-map field)
                                                                 c/top-type)))
                                           c/coll-of-any
                                           empty-list (maybe (symbol (str sym " fields"))) "")
                        impls (merge-with comp
                                          (default-type-impls sym type-num fields)
                                          (destructure-fields new-type-constraint field-constraints ast))
                        impl-arities (for [[proto-sym impl-fns] (seq impls)
                                           [fn-name arities] (seq impl-fns)
                                           impl-arity arities]
                                       [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
                  _ (sm/assoc-in-val [.fn-context .field-constrs] (maybe field-constraints))

                  impl-arities (ev/traverse impl-arities (partial declare-impl (str sym) type-num))
                  _ (ev/traverse impl-arities (partial emit-impl (str sym) new-type-constraint type-num))

                  new-field-constrs (sm/get-in-val [.fn-context .field-constrs])
                  :let [field-constraints (either (map new-field-constrs
                                                       (fn [fc]
                                                         (-> fc
                                                             (c/update-var "")
                                                             (c/update-sym (symbol (str sym " fields")))
                                                             (.items-constraints (map (.items-constraints fc)
                                                                                      (fn [c]
                                                                                        (c/update-var c "")))))))
                                                  field-constraints)

                        field-constraints (promote-inferred field-constraints)
                        getter-arities (create-getters (.sym ast) fields
                                                       (c/extract-items-constraints field-constraints))
                        getter-arities (for [[proto-sym impl-fns] (seq getter-arities)
                                             [fn-name arities] (seq impl-fns)
                                             impl-arity arities]
                                         [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]

                  getter-arities (ev/traverse getter-arities (partial declare-impl (str sym) type-num))
                  _ (ev/traverse getter-arities (partial emit-impl (str sym) new-type-constraint type-num))
                  _ (sm/assoc-in-val [.fn-context .field-constrs] nothing)

                  type-constructor (emit-constructor (.sym ast) type-num new-type-constraint
                                                     fields field-constraints)
                  ;; TODO: this should be better
                  const-type-num (flat-map (lookup-sym (.sym ast))
                                           (fn [expr]
                                             (var-type-num (.c-var expr))))
                  _ (sm/assoc-in-val [.modules 'core .protocols (ast/untag Function-sym) (ast/untag invoke-sym)
                                      .p-impls const-arity-index const-type-num .result-constraint]
                                     new-type-constraint)]
              type-constructor)))))

;; (defn js-callable-arity [[num-args expr]]
;;   (for [c-fn-name (global-var (str (.sym ast) "_" num-args))
;;         :let [c-fn-name (either (check-C-var c-fn-name)
;;                                 c-fn-name)
;;               js-wrapper (c-code ""
;;                                  ["\nEM_ASM(\n" (str (.sym ast)) " = function("
;;                                   (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
;;                                   "_" c-fn-name "("
;;                                   (interpose (map (range num-args)
;;                                                   (fn [idx]
;;                                                     ["sendValue(arg" idx ")"]))
;;                                              ", ")
;;                                   ");\n return; \n};);\n"]
;;                                  [] {} {})]
;;         _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
;;                                                 (conj exprs js-wrapper)))]
;;     [c-fn-name num-args]
;;     [(c-code "" []
;;              ["EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
;;               (interpose (map (range num-args) (partial str "int64_t arg")) ", ")
;;               ") {\ndec_and_free("
;;               (.c-var expr) "("
;;               (interpose (cons "empty_list"
;;                                (map (range num-args)
;;                                     (fn [idx]
;;                                       ["(Value *)arg" idx])))
;;                          ", ")
;;               "), 1);\n return; \n};\n"]
;;              {} {})]))

(extend-type ast/JS-callable
  Emitter
  (emit-definition [ast]
    (let [num-args (.num-args ast)]
      (comp (for [fn-var (map (lookup-sym (.sym ast)) .c-var)
                  expr (lookup-static-arity-info fn-var num-args)
                  c-fn-name (global-var (str (.sym ast)))
                  :let [c-fn-name (either (check-C-var c-fn-name)
                                          c-fn-name)
                        js-wrapper (c-code ""
                                           ["\n#ifdef TOCCATA_WASM\n"
                                            "EM_ASM(\n" (str (.sym ast)) " = function("
                                            (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
                                            "return _" c-fn-name "("
                                            (interpose (map (range num-args)
                                                            (fn [idx]
                                                              ["sendValue(arg" idx ")"]))
                                                       ", ")
                                            ");\n};);\n"
                                            "#endif\n"]
                                           {} c/top-type)]
                  _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                          (conj exprs js-wrapper)))
                  _ (declare ["\n#ifdef TOCCATA_WASM\n"
                              "EMSCRIPTEN_KEEPALIVE\n Value * " c-fn-name "("
                              (interpose (map (range num-args) (partial str "int arg")) ", ")
                              ") {\nreturn("
                              (.c-var expr) "("
                              (interpose (cons "(List *)0"
                                               (map (range num-args)
                                                    (fn [idx]
                                                      (str "(Value *)arg" idx))))
                                         ", ")
                              "));\n};\n"
                              "#endif\n"])]
              [empty-c-code])
            (compilation-error "Could not find function" (.sym ast) "or an arity with" num-args "arguments.")))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures [] [{}]
                                                         nothing)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures [] [{}]
                                                                      nothing)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names {} {})
                                   0                        ;; reify-fn-index
                                   c/TypeCount))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");\n"]))

(defn declare-dispatcher [file-name [fn-sym arities]]
  (let [arities (.p-impls arities)]
    (for [disp-fn (sm/get-in-val [.modules file-name .values (ast/tag fn-sym)])
          :let [fn-var (.c-var disp-fn)]
          c-fns (ev/traverse (keys arities)
                             (fn [arg-count]
                               (for [disp-arity (lookup-static-arity-info fn-var arg-count)
                                     arity-var (global-var "arity")]
                                 [arg-count arity-var (.c-var disp-arity)])))
          struct-var (global-var "dispFnStruct")

          _ (sm/assoc-in-val [.modules file-name .values (ast/tag fn-sym) .c-struct] struct-var)
          checked-var (genlocal 'checked)
          _ (declare [(map c-fns
                           (fn [[arg-count arity-var c-fn]]
                             (let [impls (extract (get arities arg-count))]
                               ["Value *" c-fn "(List *"
                                (interpose (cons "closures" (map (range arg-count)
                                                                 (partial str "Value *arg")))
                                           ",")
                                ") {\nFnArity *arity;\n#\n"
                                "FnType" arg-count " *_fn;\n"
                                "int " checked-var "= 1;"
                                "switch (arg0->type) {\n"
                                (map (seq (dissoc impls 0 'param-consts 'result-const))
                                     (fn [[type-num arity-info]]
                                       (assert (instance? ProtoImpl arity-info))

                                       ["case " (str type-num) ": arity = "
                                        (.c-var arity-info) ";\n_fn = (FnType"
                                        arg-count " *)" (.c-fn arity-info) ";\n"
                                        (for [[constraint var] (-> (.param-constraints arity-info)
                                                                   c/extract-items-constraints
                                                                   (zip-lists (map (range arg-count)
                                                                                   (partial str "arg")))
                                                                   rest)]
                                          (-> constraint
                                              (c/update-var var)
                                              (runtime-check c/top-type
                                                             (str "(closures == (List *)0 ? \"\" : "
                                                                  "((String *)closures)->buffer)")
                                                             checked-var)))
                                        "\nclosures = arity->closures;\nbreak;\n"]))
                                (let [arity-info (extract (get impls 0))]
                                  ["default: // bogus\n"
                                   (for [[constraint var] (-> (.param-constraints arity-info)
                                                              c/extract-items-constraints
                                                              (zip-lists (map (range arg-count)
                                                                              (partial str "arg")))
                                                              rest)]
                                     (-> constraint
                                         (c/update-var var)
                                         (runtime-check c/top-type
                                                        (str "(closures == (List *)0 ? \"\" : "
                                                             "((String *)closures)->buffer)")
                                                        checked-var)))
                                   "_fn = (FnType" arg-count
                                   " *)" (.c-fn arity-info) ";\nbreak;\n"])
                                "}\n"
                                "if(!" checked-var "){abort();}" line-sep
                                ;; "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n" 
                                "return(_fn(closures, " (-> (range arg-count)
                                                            (map (partial str "arg"))
                                                            (interpose ", "))
                                "));\n}\n"
                                "FnArity " arity-var " = {FnArityType, -2, "
                                arg-count
                                ", (List *)0, 0, " c-fn ", (Value *)0, (Value *)0};\n"])))
                      "Function " struct-var " = {FunctionType, -2, \""
                      fn-sym "\", " (count c-fns) ", "
                      "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                      "}};\n"
                      "Value *" fn-var " = (Value *)&" struct-var ";\n\n"])]
      '_)))

(defn gather-protocols [file-name]
  (comp (for [protocols (sm/get-in-val [.modules file-name .protocols])
              expr (encode-static protocols)
              x (apply (wrap sm/zero-sm list)
                       (map (for [[_ proto-fns] (seq protocols)
                                  [fn-sym arities] (seq proto-fns)]
                              [fn-sym arities])
                            (partial declare-dispatcher file-name)))
              protos-var (sm/get-in-val [.modules file-name .values protocols-sym])
              r (collapse-expressions [expr
                                       (c-code (.c-var protos-var)
                                               [(.c-var protos-var) " = " (.c-var expr) ";\n"]
                                               {} c/top-type)])]
          r)
        (compilation-error "Could not gather the protocols for" (str "'" file-name "'"))))

(defn gather-symbols [file-name]
  (for [symbols (sm/get-in-val [.modules file-name .values])
        expr (-> symbols
                 (dissoc symbols-sym protocols-sym)
                 (assoc 'filename (either (instance? String file-name)
                                          ""))
                 seq
                 (reduce {} (fn [m [k v]]
                              (either (and (instance? c-code v)
                                           (maybe m))
                                      (assoc m k v))))
                 (encode "symbols_"))
        sym-var (sm/get-in-val [.modules file-name .values symbols-sym])
        r (collapse-expressions [expr
                                 (c-code (.c-var sym-var)
                                         [(.c-var sym-var) " = " (.c-var expr) ";\n"]
                                         {} c/top-type)])]
    r))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity-info 'main 1)
                      (compilation-error "'main' function is missing"))
        modules (sm/get-in-val [.modules])
        protos (ev/traverse (keys modules) gather-protocols)
        symbols (ev/traverse (keys modules) gather-symbols)
        values (sm/get-in-val [.rt-init .exprs])
        decl (sm/get-in-val [.fn-context .decl])
        _ (sm/assoc-in-val [.fn-context .decl] [])]
    (do
      (write-strings decl)
      (write-strings ["\n#\n"
                      "\nint main (int argc, char **argv) {\n"
                      "prErrSTAR = &defaultPrErrSTAR;\n"
                      "#ifdef SINGLE_THREADED\n"
                      "#ifdef CHECK_MEM_LEAK\n"
                      "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
                      "at same time.\");\n "
                      "abort();\n"
                      "#endif\n"
                      "#endif\n"
                      "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                      "maybeNothing->refs = -1;\n"
                      "outstream = stdout;\n"
                      "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                      "futuresQueue.output = empty_list;\n"
                      "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                      "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                      "pthread_mutex_init(&shutDown.access, NULL);\n"
                      "startWorkers();\n"
                      (map protos .init)
                      (map symbols .init)
                      (map values .init)
                      "\n#\n"
                      "  List *argList = malloc_list();\n"
                      "  argList->len = 0;\n"
                      "  argList->head = (Value *)0;\n"
                      "  argList->tail = (List *)0;\n"
                      "  List *tail = argList;\n"
                      "  for(int i = 0; i < argc; i++) {\n"
                      "     List *newTail = malloc_list();\n"
                      "     newTail->len = 0;\n"
                      "     newTail->tail = (List *)0;\n"
                      "     newTail->head = (Value *)0;\n"
                      "     tail->head = stringValue(argv[i]);\n"
                      "     tail->tail = newTail;\n"
                      "     tail = newTail;\n"
                      "     argList->len++;\n}\n"
                      "  argList->refs = -1;\n"
                      "Value *the_final_answer = " (.c-var main-fn)
                      "((List *)0, (Value *)argList);\n\n"
                      "#ifdef CHECK_MEM_LEAK\n"
                      "cleaningUp = 1;\n"
                      "mainThreadDone = 1;\n"
                      "waitForWorkers();\n"
                      (map (vals modules) (fn [module]
                                            (either (map (get-in module [.values symbols-sym])
                                                         (fn [expr]
                                                           (free-global (c-init (.c-var expr) [] {} "" 0))))
                                                    "")))
                      (map values free-global)
                      "\n#\n"
                      "for(List *l = argList; l != (List *)0; l = l->tail) {\n"
                      "   l->refs = 1;\n"
                      "}\n"
                      "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                      "  if (malloc_count - free_count != 0)\n"
                      "    return(1);\n"
                      "#endif"
                      "\n#\n"
                      "  return(0);\n};\n"]))))

(defn get-proto-dispatch-sym [fn-sym num-args]
  (for [fn-var (lookup-sym fn-sym)
        arity-var (sm/get-in-val [.fns (.c-var fn-var) num-args])]
    (.c-var arity-var)))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (for [protos-var (global-var "protos_")
                              symbols-var (global-var "symbols_")
                              _ (sm/assoc-in-val [.modules module-name]
                                                 (Module module-name
                                                         {protocols-sym (c-code protos-var [] {} c/top-type)
                                                          symbols-sym (c-code symbols-var [] {} c/top-type)}
                                                         {} {} {} {}))
                              _ (declare ["Value *" protos-var " = (Value *)&emptyBMI;\n"
                                          "Value *" symbols-var " = (Value *)&emptyBMI;\n"])]
                          '_)
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              _ (map (sm/get-in-val [.fn-context .decl]) write-strings)
                              _ (sm/assoc-in-val [.fn-context .decl] [])
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))


(def fixup-native-symbols*
  (apply (wrap sm/zero-sm (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (ast/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'vals) 1)
                     (fn [arity-sym]
                       ["Value *(*vals)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'first) 1)
                     (fn [arity-sym]
                       ["Value *(*first)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'rest) 1)
                     (fn [arity-sym]
                       ["Value *(*rest)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (ast/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (ast/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (ast/tag 'new-hash-set) 1)
                     (fn [arity-ptr]
                       ["Value *(*newHashSet)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (ast/tag 'apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (ast/tag 'pr-value) 1)
                     (fn [arity-ptr]
                       ["Value *(*prValue)(List *, Value*) = " arity-ptr ";\n"]))
                )))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ev/Evaluator
  (ev/eval [x]
    (let [file (.file-path x)]
      (comp (for [curr-file-name (sm/get-val .file-name)
                  curr-file-path (sm/when (sys/file-directory curr-file-name))
                  :let [file (str curr-file-path file)]
                  mod-syms (comp (sm/get-in-val [.ns file .syms])
                                 (for [asts (sm/when (for [file-in (fio/file-in file)
                                                           asts (ev/parse {'file-name file
                                                                           'line-number 1}
                                                                          (lazy-list file-in))]
                                                       asts))
                                       _ (sm/set-val .file-name file)
                                       base-imports (sm/get-val .base-imports)
                                       _ (sm/assoc-in-val [.ns file] (ev/EvalNamespace file base-imports {}
                                                                                       {} [{}]))
                                       _ (ev/eval asts)
                                       mod-syms (sm/get-in-val [.ns file .syms])]
                                   mod-syms))
                  _ (sm/assoc-in-val [.ns curr-file-name .imports file] mod-syms)]
              mod-syms)
            (ev/abort-interp "Could not import module" (str "'" file "'") "at"
                             (ev/ast-location-str x))))) 

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def repo-cloner (agent {}))

(defn clone-repo* [ast proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sh/command "/usr/bin/git" (list "clone" "--branch" branch
                                                  (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sh/command "/usr/bin/git"
                                            (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ev/Evaluator
  (ev/eval [ast]
    ;; Only called when interpreting a file (I think)
    (let [file (.file ast)]
      (either (and (-> file
                      seq
                      (some (partial = "/")))
                   (maybe (ev/abort-interp "For git dependencies,"
                                           "files may only be imported from root of repository,"
                                           file "is invalid.")))
              (comp (for [script-dir (sm/get-val .script-dir)
                          :let [clone-waiter (promise)
                                dep-path (do
                                           (clone-repo {} ast clone-waiter script-dir)
                                           (extract clone-waiter))
                                module-path (str dep-path "/" file)
                                _ (or (sys/access module-path)
                                      (do
                                        (print-err "Dependency file" file "missing from cloned repository"
                                                   (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                                        (abort)))]
                          curr-file-name (sm/get-val .file-name)
                          _ (sm/set-val .file-name module-path)
                          r (ev/eval (ast/module-ast file))
                          _ (sm/set-val .file-name curr-file-name)]
                      r)
                    (ev/abort-interp "Could not import module" (str "'" file "'") "from git repo at"
                                     (ev/ast-location-str ast))))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      [waiter ast])))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                ;; old code
                                ;; (map modules extract)
                                (map modules
                                     (fn [[waiter ast]]
                                       ;; TODO: refactor this mess
                                       (send ast-emitter
                                             (fn [context ns-file-name mod-file-name ns-sym]
                                               (update-context
                                                context
                                                (for [syms (sm/get-in-val [.modules ns-file-name .values])
                                                      _ (sm/assoc-in-val [.modules mod-file-name .ns-syms ns-sym]
                                                                         syms)]
                                                  '_)))
                                             (extract waiter) (ast/file-name ast) (.ns-sym ast)))))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn fixup-generated-symbols [context file-name protocols-sym symbols-sym]
  (update-context context
                  (for [protocols-var (sm/get-in-val [.modules file-name .values protocols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'protocols]
                                           protocols-var)
                        symbols-var (sm/get-in-val [.modules file-name .values symbols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'symbols]
                                           symbols-var)
                        _ (sm/update-in-val [.rt-init .exprs]
                                            (fn [exprs]
                                              (conj exprs (c-code "" ["if(" (.c-var symbols-var) "->refs > 0)\n"
                                                                      (.c-var symbols-var) "->refs = -1;\n"]
                                                                  {} c/top-type))))]
                    '_)))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)
                          _ (send ast-emitter
                                  (fn [context]
                                    (update-context
                                     context
                                     (sm/assoc-in-val [.modules 'core .types]
                                                      {'Integer int-constraint
                                                       'StringBuffer (c/TypeConstraint {c/StringBufferType #{}}
                                                                                       empty-list 'StringBufer
                                                                                       nothing "")
                                                       'SubString (c/TypeConstraint {c/SubStringType #{}}
                                                                                    empty-list 'SubString nothing "")
                                                       'FnArity (c/TypeConstraint {c/FnArityType #{}}
                                                                                  empty-list 'FnArity nothing "")
                                                       'BitmapIndexedNode (c/TypeConstraint {c/BitmapIndexedType #{}}
                                                                                  empty-list 'BitmapIndexedNode
                                                                                  nothing "")
                                                       'ArrayNode (c/TypeConstraint {c/ArrayNodeType #{}}
                                                                                  empty-list 'ArrayNode nothing "")
                                                       'HashCollisionNode (c/TypeConstraint
                                                                           {c/HashCollisionNodeType #{}}
                                                                           empty-list 'HashCollisionNode nothing "")
                                                       'Fn fn-constraint
                                                       'List list-constraint
                                                       'Maybe maybe-constraint
                                                       'Vector vect-constraint
                                                       'Symbol sym-constraint
                                                       'HashMap hashmap-constraint
                                                       'Promise (c/TypeConstraint {c/PromiseType #{}} empty-list
                                                                                  'Promise nothing "")
                                                       'Future (c/TypeConstraint {c/FutureType #{}} empty-list
                                                                                 'Future nothing "")
                                                       'Agent (c/TypeConstraint {c/AgentType #{}} empty-list
                                                                                'Agent nothing "")
                                                       'Opaque (c/TypeConstraint {c/OpaqueType #{}} empty-list
                                                                                 'Opaque nothing "")}))))]

                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter
                        fixup-generated-symbols 'core protocols-sym symbols-sym)
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? (map-of String Promise) loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (let [r (analyze-forms {'file-name file-name
                                                                         'root-directory root-dir
                                                                         'project-directory proj-dir
                                                                         'line-number 1}
                                                                        (lazy-list file-in))]
                                                   (send ast-emitter
                                                         fixup-generated-symbols file-name
                                                         protocols-sym symbols-sym)
                                                   r)))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(extend-type ev/Thunk
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type ev/EvalState
  Emitter
  (encode-static [x]
    (for [args (ev/traverse (type-args x) encode-static)
          struct (global-var "cnstr_")
          var (global-var "cnstr_")
          _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
                      (str (count args)) (flat-map args (fn [expr]
                                                          [",(Value *)&" (.c-struct expr)]))
                      "};" line-sep
                      "Value *" var " = (Value *)&" struct ";" line-sep])
          expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
      expr)))

(extend-type ev/ProtoDispatcher
  Emitter
  (encode-static [x]
    (for [args (ev/traverse (type-args x) encode-static)
          struct (global-var "cnstr_")
          var (global-var "cnstr_")
          _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, 0, "
                      (str (count args)) (flat-map args (fn [expr]
                                                          [",(Value *)&" (.c-struct expr)]))
                      "};" line-sep
                      "Value *" var " = (Value *)&" struct ";" line-sep])
          expr (collapse-expressions (conj args (c-static-val var [] {} struct)))]
      expr))

  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type sm/new-sm
  ev/Evaluator
  (ev/apply-fn [mv [state]]
    (wrap sm/zero-sm (mv state))))

(main [params]
  (either (or (and (< (count params) 2)
                   (do
                     (print-err "A filename to compile must be provided.")
                     (maybe -1)))
              (and (< 2 (count params))
                   (let [[_ option file-name & args] params]
                     (or (and (= "--script" option)
                              (flat-map (or (sys/file-directory file-name)
                                            (do
                                              (print-err "Could not open file:" file-name)
                                              (abort)))
                                        (fn [script-dir]
                                          (interp/interp-file
                                           file-name script-dir
                                           [(interp/CompiledNs 'file (either (get fio/symbols 'filename)
                                                                             "")
                                                               fio/symbols fio/protocols)
                                            (interp/CompiledNs 'reader (either (get rdr/symbols 'filename)
                                                                               "")
                                                               rdr/symbols rdr/protocols)
                                            (interp/CompiledNs 'grammar  (either (get grmr/symbols 'filename)
                                                                                 "")
                                                               grmr/symbols grmr/protocols)
                                            (interp/CompiledNs 'parse  (either (get rd/symbols 'filename)
                                                                               "")
                                                               rd/symbols rd/protocols)
                                            (interp/CompiledNs 'ast  (either (get ast/symbols 'filename)
                                                                             "")
                                                               ast/symbols ast/protocols)
                                            (interp/CompiledNs 'sys  (either (get sys/symbols 'filename)
                                                                             "")
                                                               sys/symbols sys/protocols)
                                            (interp/CompiledNs 'state-maybe  (either (get sm/symbols 'filename)
                                                                                     "")
                                                               sm/symbols sm/protocols)
                                            (interp/CompiledNs 'const  (either (get c/symbols 'filename)
                                                                               "")
                                                               c/symbols c/protocols)
                                            (interp/CompiledNs 'shell  (either (get sh/symbols 'filename)
                                                                               "")
                                                               sh/symbols sh/protocols)
                                            (interp/CompiledNs 'strm  (either (get strm/symbols 'filename)
                                                                              "")
                                                               strm/symbols strm/protocols)]
                                           args))))
                         (do
                           (print-err "The only option for the compiler is '--script'")
                           (maybe -1))))))
          (let [[_ file-name] params
                waiter (promise)]
            (or (map (sys/file-directory file-name)
                     (fn [root-dir]
                       (write-strings ["\n#define _XOPEN_SOURCE 600"
                                       "\n#include <stdlib.h>"
                                       "\n#include \"core.h\"\n"])
                       (send module-compiler compile-module file-name waiter root-dir root-dir)))
                (do
                  (print-err "Could not find " (str "'" file-name "'"))
                  (abort)))
            (extract waiter)
            (send ast-emitter (fn [context]
                                (write-strings ["\nint typeCount = "
                                                (str (either (map context .type-counter)
                                                             "no idea"))
                                                ";\n"])
                                context))
            (send ast-emitter emit-main)
            (send ast-emitter fixup-native-symbols)
            (send ast-emitter (fn [ctxt]
                                (map (get-in ctxt ['_ .constants .other])
                                     (fn [counts]
                                       (apply print-err (list* "\n" (interpose (map (seq counts)
                                                                                     (fn [[k v]]
                                                                                       (str k ": " v)))
                                                                               "\n")))
                                       (print-err "number of types" (either (map ctxt .type-counter)
                                                                            "no idea"))))))
            ;; wait for agents to clear their queues
            (let [waiter (promise)]
              (send ast-emitter (fn [_]
                                  (send string-writer (fn [_]
                                                        (deliver waiter 'x)))))
              (extract waiter)))))
