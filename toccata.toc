
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "0e6a4fb"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "ecde30b"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1616a3a"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "956a8bb"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "b41dd1d"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e67c808"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "4f6b41b"))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-macro [ast marker]
  (sm/state-maybe (either (= "" (ast/file-name ast))
                          ["\n" marker "\n#line "
                           (str (ast/line-number ast)) " " "\""
                           (either (and (= 'core (ast/file-name ast))
                                        (maybe path-to-core))
                                   (ast/file-name ast))
                           "\"\n"])))

(def IgnoreType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IgnoreType};"))
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def HashMapType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashMapType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 SubStringType "SubString"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 HashMapType "HashMap"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 'Symbol SymbolType
                 'BitmapIndexedNode BitmapIndexedType
                 'ArrayNode ArrayNodeType
                 'HashCollisionNode HashCollisionNodeType
                 'HashMap HashMapType
                 'Promise PromiseType
                 'Future FutureType
                 'Agent AgentType
                 'Opaque OpaqueType
                 'TypeCount TypeCount})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params return-constraints])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast]
    (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args call-expr-ast]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x))))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol CollapseExprs
  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  (assert (instance? String c-var))
  (assert (instance? Vector init))
  (assert (instance? Vector decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  CollapseExprs
  (collapse-expressions* [x y] y)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  ;; (assert (instance? String c-var))
  ;; (assert (instance? Vector init))
  ;; (assert (instance? Vector decl))
  ;; (assert (instance? Integer type-num))
  ;; (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))))

  CollapseExprs
  (collapse-expressions* [x y]
    (c-code (.c-var y)
            [(.init x) (.init y)]
            [(.decl x) (.decl y)]
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y))))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-code (.c-var c)
                           [(.init result) (.init c)]
                           [(.decl result) (.decl c)]
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  CollapseExprs
  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" [line-sep "incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(defn collapse-expressions [cs]
  (either (and (empty? cs) (maybe empty-c-code))
          (let [[c & cs] (reverse cs)
                cs (remove cs empty?)]
            (reduce cs c (fn [y x]
                           (collapse-expressions* x y))))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? Vector closures))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

(deftype SymbolInfo [emitted constraints]
  ;; (assert (instance? c-code emitted))
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_]
    (list "<SymbolInfo " (str emitted) " " (str constraints) ">")))

(deftype SymbolsInfo [info]
  (assert (instance? HashMap info))
  
  Stringable
  (string-list [_]
    (list (str "<SymbolsInfo " info ">")))

  Seqable
  (seq [_]
    (seq info))

  Associative
  (assoc [_ k v]
    ;; (assert (instance? rdr/tagged-symbol k))
    ;; (assert (instance? SymbolInfo v))
    (or (instance? rdr/tagged-symbol k)
        (instance? Symbol k)
        (do
          (print-err 'bad-key (type-name k) k)
          (abort)))
    (or (instance? SymbolInfo v)
        (do
          (print-err 'bad-assoc-value (type-name v) v)
          (abort)))
    (SymbolsInfo (assoc* info k v (sha1 k) 0)))

  (get [m k]
    (for [v (get info k)
          _ (or (instance? SymbolInfo v)
                (do
                  (print-err 'bad-get-value (type-name v) v)
                  (abort)))]
      v)))

(deftype ExpressionContext [syms shadowed-syms]
  ;; syms               the symbols local to the function that are currently interned
  ;;                    hash-map from Symbol to SymbolInfo
  (assert (instance? HashMap syms))
  ;; shadowed-syms      info for symbols that were shadowed in the expression at time of shodowing
  (assert (instance? HashMap shadowed-syms))

  Stringable
  (string-list [_]
    (list "<ExpressionContext " (count syms) ">")))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count expr-context context-syms closed-over
                               constraints params]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; expr-context  info need for the expression currently being emitted
  (assert (instance? ExpressionContext expr-context))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; constraints   constraints on C variables 
  (assert (instance? HashMap context-syms))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list expr-context)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; proto-fns        map of protocol fn symbols to fn information
  (assert (instance? HashMap proto-fns))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))
  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context init modules fns namespaces constants reify-fn-index other]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))
  ;; other                  a map of anything
  (assert (instance? HashMap other))
  Stringable
  (string-list [_] (list "<GlobalContext>")))

(deftype TypeConstraint [type-num path]
  (assert (instance? Integer type-num))
  (assert (instance? Vector path)))

(defn reset-fn-context
  ([]
   (for [curr-fn-context (sm/get-val .fn-context)
         :let [new-context (comp (-> curr-fn-context .context-syms)
                                 (-> curr-fn-context .expr-context .syms))]
         _ (sm/set-val .fn-context (FunctionArityContext {} 0
                                                         (ExpressionContext {} {})
                                                         new-context empty-closures {} []))]
     curr-fn-context))
  ([new-fn-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-fn-context)]
     curr-fn-context)))

(defn sym-ns-path [sym]
  (comp (for [ns-sym (sm/when (rdr/namespace sym))
              path (comp (sm/get-in-val [.namespaces (ast/file-name sym) ns-sym])
                         (sm/get-in-val [.namespaces (ast/file-name sym) (rdr/tag ns-sym)]))]
          path)
        (sm/state-maybe (ast/file-name sym))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (comp (for [protocol-path (sym-ns-path proto-sym)
              proto-info (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          proto-info)
        (sm/get-in-val [.modules 'core .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])
              _ (compilation-error "Duplicate protocol function" (str "'" fn-sym "'") "at"
                                   (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defn find-protocol-path [fn-sym]
  (comp (for [namespace (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym namespace)]
          path)
        (lookup-protocol-path fn-sym (ast/file-name fn-sym))
        (lookup-protocol-path fn-sym 'core)))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym return-type
                             return-constraints param-constraints type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) " " (str return-type) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym return-type
                            return-constraints param-constraints]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym return-type
                                       return-constraints param-constraints {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-var ast]
  (assert (instance? Integer dispatch-type))
  ;; TODO: fix this
  ;; (assert (instance? String c-var))

  Stringable
  (string-list [_] (list "<ProtoImpl " (target-type-name dispatch-type) " " c-var ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))


(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start (seq remaining)))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (rdr/tag (str pre sym-count))))
  ([sym arg-name]
   (for [sym-count (sm/get-in-val [.fn-context .sym-count])
         _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
     (rdr/tag (str (either (check-C-var (str sym "_"))
                           arg-name)
                   sym-count)))))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype ParamBinding [vars destruct]
  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (assert-result x (instance? sm/new-sm x))

  ;; TODO: use a vector instead
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts args return-constraints]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args return-constraints)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts params return-constraints]
    (let [asts (filter asts produces-code?)]
      (extract (or (empty? asts)
                   (flat-map (last asts)
                             (fn [tail]
                               (store asts (dec (count asts))
                                      (tail-call tail params return-constraints)))))))))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym arg-name)))
  ([sym arg-name]
   (sm/state-maybe (gensym (either (check-C-var (str sym "_"))
                                   arg-name)))))


(defn lookup-module-def [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (for [_ (sm/when (rdr/namespace sym))
                ns-file (sym-ns-path sym)
                var (comp (sm/get-in-val [.modules ns-file .values (.base sym)])
                          (sm/get-in-val [.modules ns-file .values (rdr/tag (.base sym))]))]
            var)
          (sm/get-in-val [.modules sym-file .values sym]))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .declarations sym '_]))

(defn lookup-core-def [sym]
  (sm/get-in-val [.modules 'core .values sym]))

(defn already-closed-over [sym]
  (for [closed-over (sm/get-in-val [.fn-context .closed-over .closures])
        closure-var (sm/when (some closed-over (fn [[closure-var sym-literal]]
                                                 (for [_ (= sym sym-literal)]
                                                   closure-var))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        c-sym (sm/get-in-val [.fn-context .context-syms sym])

        ;; if 'sym' is in the context, it should be in .closed-over
        closure-var (comp (already-closed-over sym)
                          (new-closure sym))]
    (c-code closure-var [] [] (.type-num c-sym) {closure-var 1})))

(defn lookup-sym [sym]
  (comp (for [_ (sm/when-not (rdr/namespace sym))
              r (comp (sm/get-in-val [.fn-context .expr-context .syms sym])
                      (closed-over-sym sym))]
          r)
        (lookup-module-def sym)
        (lookup-declaration sym)
        (lookup-core-def sym)
        (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                           (str (ast/file-name sym) ":")
                           (ast/line-number sym))))

(deftype StaticArityInfo [c-info param-constraints])

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params .c-info]))

(defn lookup-static-constraints [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params .param-constraints] []))

(defn new-static-arity
  ([fn-var num-params arity-var type-num]
   (new-static-arity fn-var num-params arity-var type-num []))
  ([fn-var num-params arity-var type-num param-constraints]
   (sm/assoc-in-val [.fns fn-var num-params]
                    (StaticArityInfo (c-code arity-var [] [] type-num {})
                                     param-constraints))))

(defn lookup-core-fn-arity [sym num-args]
  (for [fn-sym (sm/get-in-val [.modules 'core .values sym])
        arity-sym (lookup-static-arity (.c-var fn-sym) num-args)]
    arity-sym))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params return-constraints] ast))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-in-val [.constants .strings]) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val] (c-code str-ptr [] [] StringType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value) (.type-num value) (.refs-map value)))

(defn get-type-number [type-symbol]
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-num (comp (sm/get-in-val [.modules ns-path .types type-symbol])
                             (sm/get-in-val [.modules 'core .types type-symbol]))]
          type-num)
        (sm/state-maybe UnknownType)))

(defn set-type [sym type-num]
  (comp (for [_ (sm/get-in-val [.fn-context .expr-context .syms sym])
              _ (sm/assoc-in-val [.fn-context .expr-context .syms sym .type-num] type-num)]
          "")
        sm-space))

;; TODO: line numbering starts to go wrong here

(defprotocol Assertion
  (get-param-constraints [_]
    (assert-result x (instance? sm/new-sm x)))
  (assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)
  (return-assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)
  (format-path [ast])
  (add-assertion [ast]
    (assert-result x (instance? sm/new-sm x)))
  (check-assertion [ast arg var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))
  (to-assertion [ast param])
  (assert-type [ast]
    (assert-result x (instance? Maybe x))
    nothing)
  (assert-return-type [ast]
    (assert-result x (instance? Maybe x))
    nothing))

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (replace-bound-vars [ast subs]
    (ast/assert-ast (replace-bound-vars (.assertion ast) subs)))

  (replace-syms [ast subs]
    (map (replace-syms (.assertion ast) subs)
         (fn [assertion]
           (ast/assert-ast assertion))))

  (produces-code? [ast] (produces-code? (.assertion ast)))

  (emit [ast]
    (let [assertion (.assertion ast)]
      (add-assertion (.path assertion (conj (.path assertion)
                                            [(str (ast/file-name ast) ":")
                                             (ast/line-number ast)])))))

  (tail-call [ast params return-constraints] ast))

(def string-types {StringType StringType
                   SubStringType SubStringType})
(def hash-map-types {BitmapIndexedType BitmapIndexedType
                     ArrayNodeType ArrayNodeType
                     HashCollisionNodeType HashCollisionNodeType
                     HashMapType HashMapType})

(defn satisfies-type-constraint [constraint type-num]
  (assert (instance? Integer constraint))
  (assert (instance? Integer type-num))
  (inline C Maybe "
   if (sameType(((Integer *)constraint_0)->numVal, ((Integer *)type_num_1)->numVal)) {
     dec_and_free(type_num_1, 1);
     return(maybe((List *)0, (Value *)0, constraint_0));
   } else {
     dec_and_free(constraint_0, 1);
     dec_and_free(type_num_1, 1);
     return(nothing);
   }\n"))

(defn get-asserted-type [type-symbol file-name line-number]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-num (comp (sm/get-in-val [.modules ns-path .types type-symbol])
                             (sm/get-in-val [.modules 'core .types type-symbol]))]
          type-num)
        (compilation-error "Unknown type"
                           (str "'" type-symbol "'")
                           "in assertion at"
                           (str file-name ":")
                           line-number)))

(defn type-conflict [type1 type2]
  (flat-map (sm/state-maybe '_)
            (fn [_]
              (let [path1 (format-path type1)
                    path2 (format-path type2)
                    max-path (either (> (count path1) (count path2))
                                     (count path2))
                    path1 (either (map (< (count path1) max-path)
                                       (fn [_]
                                         (comp path1 (repeat (- max-path (count path1)) ""))))
                                  path1)
                    path2 (either (map (< (count path2) max-path)
                                       (fn [_]
                                         (comp path2 (repeat (- max-path (count path2)) ""))))
                                  path2)
                    max-width (reduce path1 0 (fn [max s]
                                                (either (> max (count s))
                                                        (count s))))]
                (apply compilation-error "Conflicting assertions at"
                       (str (ast/file-name (.sym type2)) ":")
                       (ast/line-number (.sym type2))
                       "\nAssertions from\n"
                       (map (zip-lists path1 path2)
                            (fn [[x y]]
                              (str x (spaces (- max-width (count x))) "   " y "\n"))))))))

(extend-type ast/type-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))

  (replace-syms [ast subs]
    (sm/state-maybe (.sym ast (either (get subs (.sym ast))
                                      (.sym ast)))))

  (emit [ast]
    (for [type-num (get-asserted-type (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
          var (lookup-sym (.sym ast))]
      (c-code ""
              ["if (!sameType(" (.c-var var) "->type, " type-num ")) {" line-sep
               "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
               (ast/file-name ast) "\"," (ast/line-number ast)
               ");" line-sep
               "fprintf(stderr, \"Expected %s, got %s\\n\", \""
               (str (.type-sym ast)) "\", extractStr(type_name(empty_list, " (.c-var var)
               ")));" line-sep
               "abort();" line-sep
               "}" line-sep]
              [] UnknownType {})))

  Assertion
  (to-assertion [ast sym]
    (ast/assert-ast (->ast
                     (.sym sym)
                     (.path (rest (.path ast))))))

  (format-path [ast]
    (either (empty? (.path ast))
            (map (.path ast)
                 (fn [[file line]]
                   (str file " " line)))))

  (assert-type [ast] (maybe (.type-sym ast)))

  (add-assertion [ast]
    (let [sym (.sym ast)]
      (comp
       (for [_ (sm/when (or (instance? Symbol sym)
                            (instance? rdr/tagged-symbol sym)))
             var (comp (map (lookup-sym sym) .c-var)
                       (compilation-error "Invalid type assertion at"
                                          (str (ast/file-name ast) ":")
                                          (str (ast/line-number ast) ".")
                                          "Symbol" (str "'" sym "' not found.")))
             constraint-type (get-asserted-type (.type-sym ast)
                                                (ast/file-name ast) (ast/line-number ast))
             constraints (sm/get-in-val [.fn-context .constraints var] [])
             _ (comp (for [_ (sm/when-not (some constraints assert-type))
                           _ (sm/assoc-in-val [.fn-context .constraints var]
                                              (conj constraints ast))
                           _ (set-type sym constraint-type)]
                       '_)
                     (for [type-num (get-type-number (some constraints assert-type))
                           _ (either (map (satisfies-type-constraint type-num constraint-type)
                                          sm/state-maybe)
                                     (-> constraints
                                         (filter assert-type)
                                         first
                                         extract
                                         (type-conflict ast)))]
                       '_))]
         empty-c-code)
       (for [_ (sm/when (or (instance? Symbol sym)
                            (instance? rdr/tagged-symbol sym)))
             _ (debug "Could not assert type for" (str "'" sym "'") "at"
                      (str (ast/file-name ast) ":") (ast/line-number ast))]
         empty-c-code)
       (sm/state-maybe empty-c-code))))

  (check-assertion [ast arg var file-name line-number]
    (for [_ (add-assertion (-> ast
                               (.sym arg)
                               (.path (conj (.path ast)
                                            [(str file-name ":") line-number]))))
          constraint-type (get-asserted-type (.type-sym ast)
                                             (ast/file-name ast) (ast/line-number ast))
          line (line-macro ast "")
          expr (comp (for [_ (sm/when-not (= UnknownType (.type-num var)))
                           type-sym (sm/get-in-val [.constants .type-names (.type-num var)]
                                                   (.type-num var))
                           _ (comp (sm/when (satisfies-type-constraint constraint-type
                                                                       (.type-num var)))
                                   (apply compilation-error
                                          "Failed type assertion at"
                                          (str file-name ":") (str line-number ".")
                                          "\nExpected" (str "'" (.type-sym ast) "', got")
                                          (str "'" type-sym "'.")
                                          (-> "\nAssertion from" 
                                              (cons (format-path ast))
                                              (interpose "\n"))))]
                       empty-c-code)
                     (for [_ (sm/get-in-val [.fn-context .params (.c-var var)])]
                       empty-c-code)
                     (sm/state-maybe (c-code ""
                                             [line
                                              "if (!sameType(" (.c-var var) "->type, "
                                              constraint-type ")) {" line-sep
                                              line-sep
                                              "fprintf(stderr, \"Invalid type of value for "
                                              "parameter '" (.sym ast) "' at %s, line %d\\n\", \""
                                              file-name "\"," line-number
                                              ");" line-sep
                                              "fprintf(stderr, \"Needed %s, got %s\\n\", \""
                                              (str (.type-sym ast))
                                              "\", extractStr(type_name(empty_list, "
                                              (.c-var var) ")));" line-sep
                                              "abort();" line-sep
                                              "}" line-sep]
                                             [] constraint-type {})))]
      expr)))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  (assert-return-type [ast]
    (for [type-sym (assert-type (.assertion ast))
          _ (= (.sym ast) (.sym (.assertion ast)))]
      type-sym))

  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params return-constraints] ast))

(defn emit-return-constraints [expr return-constraints]
  (traverse return-constraints
            (fn [constraint]
              (for [locals (sm/get-in-val [.fn-context .expr-context])
                    _ (sm/assoc-in-val [.fn-context .expr-context .syms (.sym constraint)]
                                       expr)
                    const-expr (emit (.assertion constraint))
                    _ (sm/assoc-in-val [.fn-context .expr-context] locals)]
                const-expr))))

(defn emit-tail-expr [ast file-name line-number return-constraints expr]
  (comp (for [return-type (get-type-number (some return-constraints assert-return-type))
              :when (or (= return-type UnknownType)
                        (satisfies-type-constraint return-type (.type-num expr)))
              return-assertions (emit-return-constraints expr (remove return-constraints
                                                                      assert-return-type))]
          (collapse-expressions (comp [expr]
                                      return-assertions
                                      [(c-code ""
                                               ["return(" (.c-var expr) ");" line-sep]
                                               [] (.type-num expr) {(.c-var expr) 1})])))
        (for [return-type (get-type-number (some return-constraints assert-return-type))
              _ (sm/when (= UnknownType (.type-num expr)))
              return-assertions (emit-return-constraints expr return-constraints)]
          (do
            ;; TODO: periodically enable this to check on things
            ;; (print-err 'check (some return-constraints assert-return-type) return-type
            ;;            (ast/file-name ast) (ast/line-number ast))
            (collapse-expressions (comp [(.type-num expr return-type)]
                                        return-assertions
                                        [(c-code ""
                                                 ["return(" (.c-var expr) ");" line-sep]
                                                 [] return-type {(.c-var expr) 1})]))))
        (sm/new-sm (fn [s]
                     (print-err "Return value fails return assertion:"
                                (ast/file-name return-constraints)
                                (ast/line-number return-constraints))
                     nothing))))

(deftype TailExpr [ast params return-constraints]
  Stringable
  (string-list [expr]
    (comp (list "<TailExpr ") (string-list ast) " " (string-list return-constraints) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))
  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (or (instance? Symbol (.call-target ast))
                                    (instance? rdr/tagged-symbol (.call-target ast)))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         emit)
                line (line-macro ast "// recursive-fixed")]
            (collapse-expressions (comp args
                                        [(c-init ""
                                                 [line
                                                  (map (zip-lists params (map args .c-var))
                                                       (fn [[param arg]]
                                                         [param " = " arg ";" line-sep]))]
                                                 [] IgnoreType
                                                 (reduce (map args .c-var) {}
                                                         (fn [m arg]
                                                           (assoc m arg 1))))])))
          (flat-map (emit ast)
                    (partial emit-tail-expr
                             ast
                             (ast/file-name ast)
                             (ast/line-number ast)
                             return-constraints)))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints)))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-in-val [.constants .numbers]) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Integer
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (map (sm/get-in-val [.constants .symbols]) count)
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] SymbolType {}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      SymbolType {})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] SymbolType {}))]
      [(make-c-code quoted)]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints)))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")
        line (line-macro target "// call-vector")]
    (apply comp (comp args
                      [(c-init result-sym
                               [line
                                "Vector *" vect-sym " = empty_vect;" line-sep
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");" line-sep])))
                                "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        line (line-macro target "// call-list")
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                                [line "List *" list-sym " = empty_list;" line-sep
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");" line-sep])))
                                 "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                                [] ListType {})]))))

(defn dispatch-type-known [target args ast]
  (let [num-args (count args)]
    (for [dispatch-val (sm/when (first args))
          impl-info (get-proto-impl target num-args (.type-num dispatch-val))
          arity-info (lookup-static-arity (.c-var impl-info) num-args)
          constraints (lookup-static-constraints (.c-var impl-info) num-args)
          exprs (traverse (for [[var arg constraints] (zip-lists (seq args)
                                                                 (.args ast)
                                                                 (seq constraints))
                                constraint constraints]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-assertion constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          _ (comp (sm/update-in-val [.other 'type-known-sites] inc)
                  (sm/assoc-in-val [.other 'type-known-sites] 1))
          result-sym (genlocal "rslt") 
          line (line-macro target (str "// type-known for " target))]
      (let [return-type (either (or (and (= (.type-num arity-info) UnknownType)
                                         ;; TODO: these should be the result of
                                         ;; asserts on the protocol fn defs
                                         (or (= target 'map)
                                             (= target 'rest)
                                             (= target 'assoc*))
                                         (maybe (.type-num dispatch-val))))
                                (.type-num arity-info))]
        (apply comp (comp args
                          exprs
                          [(c-init result-sym
                                   [line "Value *" result-sym " = " (.c-var arity-info) "("
                                    (interpose (conj (map args .c-var) "empty_list")
                                               ", ")
                                    ");" line-sep]
                                   []
                                   return-type {})]))))))

(defn dispatch-type-unknown [target args ast]
  (let [num-args (count args)]
    (for [impls-info (get-protocol-dispatcher target num-args)
          :let [constraints (.param-constraints impls-info)]
          exprs (traverse (for [[var arg constraints] (zip-lists (seq args)
                                                                 (.args ast)
                                                                 (seq constraints))
                                constraint constraints]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-assertion constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          _ (comp (sm/when (or (= (ast/file-name target) 'core)))
                  (sm/update-in-val [.other 'type-unknown-sites] inc)
                  (sm/assoc-in-val [.other 'type-unknown-sites] 1))
          result-sym (genlocal "rslt")
          line (comp (map (sm/when (or (= (ast/file-name target) 'core)))
                          (fn [_] ""))
                     (line-macro target (str "// type-unknown " target)))]
      (apply comp (comp args
                        [(c-init result-sym
                                 [line "Value *" result-sym " = proto" num-args "Arg(&"
                                  (.impls-sym impls-info)
                                  ", \"" (.sym target) "\", "
                                  (interpose (comp (map args .c-var)
                                                   [(str "\"" (.file-name target) "\"")
                                                    (ast/line-number target)])
                                             ", ")
                                  ");" line-sep]
                                 []
                                 (.return-type impls-info) {})])))))

(defn call-proto-impl [name args ast]
  (for [_ (sm/when (< 0 (count args)))
        call-info (comp (dispatch-type-known name args ast)
                        (dispatch-type-unknown name args ast))]
    call-info))

(defn inline-wrap-and-apply* [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (< 0 num-args)
                          (or (= name 'wrap)
                              (= name 'apply*))))
          :let [[dispatch-ast & arg-asts] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          expr (-> impl-ast
                   (replace-bound-vars {})
                   (inline-expr (cons dispatch-val arg-asts)))]
      expr)))


(defn inline-flat-map [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (= 2 num-args)
                          (or (= name 'flat-map)
                              (= name 'map))))
          :let [[dispatch-ast f-ast] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type rdr/tagged-symbol
  Assertion
  (get-param-constraints [sym]
    (flat-map (lookup-sym sym)
              (fn [c-info]
                (sm/get-in-val [.fn-context .constraints (.c-var c-info)] []))))

  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .expr-context .syms binding]
                                   arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .expr-context .syms binding]
                                   evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints))

  (emit-call-expr [target-ast args call-expr-ast]
    (comp (call-vector target-ast args)
          (call-list target-ast args)
          (call-proto-impl target-ast args call-expr-ast)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Assertion
  (get-param-constraints [sym]
    (flat-map (lookup-sym sym)
              (fn [c-info]
                (sm/get-in-val [.fn-context .constraints (.c-var c-info)] []))))

  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .expr-context .syms binding]
                                   arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (comp (redef-proto-fn-error binding)
                  (sm/assoc-in-val [.fn-context .expr-context .syms binding]
                                   evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          line-info (line-macro ast "// inline")]
      (c-code "" [line-info (.txt ast) "\n#\n"] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] type-num {}))
          line-info (line-macro ast "// inline")]
      [(c-code "" [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] type-num {})]))

  (tail-call [ast params return-constraints]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] UnknownType {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        _ (comp (sm/update-in-val [.other 'static-fixed-sites] inc)
                (sm/assoc-in-val [.other 'static-fixed-sites] 1))
        constraints (lookup-static-constraints (.c-var target) (count arg-vars))
        exprs (traverse (for [[var arg constraints] (zip-lists (seq arg-vars)
                                                               (seq (.args ast))
                                                               (seq constraints))
                              constraint constraints]
                          [constraint arg var])
                        (fn [[constraint arg var]]
                          (check-assertion constraint arg var
                                           (ast/file-name ast)
                                           (ast/line-number ast))))
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-fixed")]
    (c-init result-sym
            [(map exprs .init)
             line "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq (map arg-vars .c-var))) ", ") ");" line-sep]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
        _ (comp (sm/update-in-val [.other 'static-variadic-sites] inc)
                (sm/assoc-in-val [.other 'static-variadic-sites] 1))
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-variadic")]
    (c-init result-sym
            [line "List *" variadic-sym " = empty_list;" line-sep
             (map (reverse arg-vars)
                  (fn [arg-sym]
                    (str variadic-sym " = (List *)listCons("
                         "(Value *)" arg-sym
                         ", " variadic-sym ");" line-sep)))
             "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
             variadic-sym ");" line-sep]
            []
            (.type-num arity-info)
            {})))

(defn call-dyn-fn-value [target args ast]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        _ (comp (sm/update-in-val [.other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              []
              UnknownType {}))))

(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type))
(def Function-sym (rdr/tag 'Function))
(def Stringable-sym (rdr/tag 'Stringable))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative))
(def get-sym (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  (let [num-args (count args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity invoke-sym (inc num-args))
                                .c-var)
          _ (comp (sm/update-in-val [.other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep

                 result-sym " = " invoke-arity-sym "(empty_list, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");" line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] UnknownType {})))))

(defn call-invoke [target arg-vars ast]
  (let [num-args (inc (count arg-vars))]
    (for [invoke-info (get-proto-impl invoke-sym num-args (.type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          _ (comp (sm/update-in-val [.other 'invoke-sites] inc)
                  (sm/assoc-in-val [.other 'invoke-sites] 1))
          constraints (lookup-static-constraints (.c-var invoke-info) num-args)
          exprs (traverse (for [[var arg constraints] (zip-lists (seq arg-vars)
                                                                 (.args ast)
                                                                 (rest (seq constraints)))
                                constraint constraints]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-assertion constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [(map exprs .init)
               line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) (map arg-vars .c-var))
                                "empty_list") ", ") ");" line-sep]
              []
              (.type-num arity-info)
              {}))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site)))
            (for [args (-> (.args ast)
                           (filter produces-code?)
                           emit)
                  call-site (comp (emit-call-expr (.call-target ast) args ast)
                                  (for [target (emit (.call-target ast))
                                        :let [arg-vars (map args .c-var)]
                                        call-site (comp
                                                   (call-static-fixed target args ast)
                                                   (call-static-variadic target arg-vars ast)
                                                   (call-invoke target args ast)
                                                   (call-dyn-fn-value target arg-vars ast)
                                                   (call-dyn-unknown-type target arg-vars ast))]
                                    (comp* empty-c-code (comp args [target call-site])))
                                  (compilation-error "Could not compile call site at:"
                                                     file-name line-number))]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site))))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))
  
  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))
  
  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defn unpack-arg-list [list-sym elem-vars file-name line-num]
  (comp (sm/when (for [elem (first elem-vars)
                       :when (= 1 (count elem-vars))
                       var (first (.vars elem))]
                   (ParamBinding [list-sym]
                                 [(c-init var ["Value *" var " = (Value *)" list-sym ";" line-sep]
                                          [] ListType {})])))
        (for [destructArgs (genlocal "destArgs")]
          (let [elem-c-vars (flat-map elem-vars .vars)
                tail-var (extract (last elem-c-vars))
                elem-count (count elem-vars)]
            (ParamBinding [list-sym]
                          (comp [(c-code ""
                                         [(map elem-c-vars (fn [var] ["Value *" var ";" line-sep]))
                                          "Value **" destructArgs "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};" line-sep "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" list-sym ", " elem-count ", "
                                          destructArgs ");" line-sep]
                                         [] UnknownType {list-sym 1})]
                                (map elem-c-vars (fn [var]
                                                   (c-init var [] []
                                                           ((= var tail-var) ListType UnknownType)
                                                           {})))
                                (flat-map elem-vars .destruct)))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type ast/params-ast
  Assertion
  (get-param-constraints [params]
    ;; TODO: flesh out
    (sm/state-maybe []))

  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (bind [params]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (rdr/tag "#tail")))
          param-var (genlocal "arg")
          destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                    (ast/file-name params)
                                    (ast/line-number params))]
      destruct))

  (bind [params evalled]
    (let [tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))]
      (for [fixed-vars (map (traverse (.fixed params) bind) vec)
            tail-var (bind tail-sym)
            destruct (unpack-arg-list (.c-var evalled) (conj fixed-vars tail-var)
                                      (ast/file-name params) (ast/line-number params))
            _ (set-type tail-sym ListType)]
        (either (and (empty? (.init evalled))
                     (empty? (.decl evalled))
                     (maybe (.vars destruct [(.c-var evalled)])))
                (-> destruct
                    (.vars [(.c-var evalled)])
                    (.destruct (comp [evalled] (.destruct destruct))))))))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(defn merge-constraints [c1 c2]
  (comp c1 c2))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .expr-context])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/assoc-in-val [.fn-context .expr-context] locals)]
      (let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))

  (tail-call [ast params return-constraints]
    (.body ast (-> ast
                   .body
                   (tail-call params return-constraints))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              type-num
              (apply merge-with + (map impl-fns .refs-map))))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            type-num {})))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (assert-result x (instance? sm/new-sm x))))

(deftype StaticArity [arity-fn-var param-count return-type var-info param-constraints]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " "
                (target-type-name return-type) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num var-info arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var return-type
                              param-constraints)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info]
  (assert (instance? String arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? c-code var-info))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl fn-name param-count dispatch-type-num
                              (c-code (str "&" fn-arity-sym) [] [] FunctionType {}) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg 
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 UnknownType {})]
          (comp reified-fn var-info))))))

(defn bind-params [params fn-var arity-fn-var]
  (comp (for [tail (sm/when (.variadic params))
              non-params (sm/get-in-val [.fn-context .expr-context .syms] {})
              fixed-vars (map (traverse (.fixed params) bind) vec)
              tail-var (bind tail)
              syms (sm/get-in-val [.fn-context .expr-context .syms] {})
              _ (sm/assoc-in-val [.fn-context .params]
                                 (-> (keys non-params)
                                     (reduce syms dissoc)
                                     (seq)
                                     (reduce {} (fn [params [_ var]]
                                                  (assoc params (.c-var var) 1)))))
              _ (sm/assoc-in-val [.fn-context .expr-context .syms tail .type-num] ListType)
              param-var (genlocal "arg")
              destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                        (ast/file-name params)
                                        (ast/line-number params))]
          destruct)
        (for [non-params (sm/get-in-val [.fn-context .expr-context .syms] {})
              vars (traverse (.fixed params) bind)
              :when-not (empty? vars)
              syms (sm/get-in-val [.fn-context .expr-context .syms] {})
              _ (sm/assoc-in-val [.fn-context .params]
                                 (-> (keys non-params)
                                     (reduce syms dissoc)
                                     (seq)
                                     (reduce {} (fn [params [_ var]]
                                                  (assoc params (.c-var var) 1)))))
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] arity-fn-var)]
          (let [[var & vars] vars
                param-vars (comp* var vars)
                param-destruct (comp (map (.vars param-vars)
                                                  (fn [var]
                                                    (c-init var [] [] UnknownType {})))
                                             (.destruct param-vars))]
            (ParamBinding (.vars param-vars) param-destruct)))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] arity-fn-var)
              _ (sm/assoc-in-val [.fn-context .params] {})]
          (ParamBinding [] []))))

(defn emit-closure-arity [fn-sym fn-context arity-fn-var params param-vars body-exprs]
  (for [closures (sm/get-in-val [.fn-context .closed-over .closures])
        :when-not (empty? closures)
        destArgs (genlocal "destArgs")
        new-constraints (sm/get-in-val [.fn-context .constraints])
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        _ (traverse closures
                    (fn [[var sym]]
                      (traverse (either (get new-constraints var)
                                        [])
                                (fn [constraint]
                                  (add-assertion (.sym constraint sym))))))
        closure-vars (traverse closures (fn [[_ sym]] (lookup-sym sym)))]
    (let [closures (-> closures
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)
          destruct-closures (cons (c-code ""
                                          [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                                           "incRef((Value *)closures, 1);" line-sep
                                           "Value **" destArgs "[" closure-count "] = {"
                                           (interpose (map closures (fn [arg] ["&" arg])) ", ")
                                           "};" line-sep
                                           "destructValue(\"\", \"\", (Value *)closures"
                                           ", " closure-count ", " destArgs ");" line-sep]
                                          []
                                          UnknownType {})
                                  (map closures (fn [arg] (c-init arg [] [] UnknownType {}))))
          body (collapse-expressions (comp (.destruct param-vars)
                                           destruct-closures
                                           body-exprs))
          arity-decl [(.decl body)
                      "Value *" arity-fn-var "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\nwhile (1) {\n"
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep

                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      ((.variadic params) "1" "0") ";" line-sep
                      arity-var "->fn = " arity-fn-var ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity arity-fn-var params
                    (comp* (c-init arity-var arity-init arity-decl FnArityType {})
                           (map closure-vars (fn [closure]
                                               (c-code arity-var
                                                       [arity-var "->closures = listCons((Value *)"
                                                        (.c-var closure) ", (List *)" arity-var
                                                        "->closures);" line-sep]
                                                       [] ListType {(.c-var closure) 1}))))))))

(defn emit-static-arity [fn-sym fn-context arity-fn-var params param-vars param-types body-exprs]
  ;; TODO: remove the 'param-types' parameter
  (let [arity-index ((.variadic params) 'variadic (count params))
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    ;; TODO: what about constraints for the variadic vars
    (for [param-constraints (traverse (.fixed params) get-param-constraints)
          _ (reset-fn-context)
          check-params (traverse (for [[constraints arg var] (zip-lists param-constraints
                                                                        (.fixed params)
                                                                        (.destruct param-vars))
                                       constraint constraints]
                                   [constraint arg var])
                                 (fn [[constraint arg var]]
                                   (either (and (= 0 (ast/line-number constraint))
                                                (maybe (check-assertion constraint arg var
                                                                        file-name line-number)))
                                           (check-assertion constraint arg var
                                                            (ast/file-name constraint)
                                                            (ast/line-number constraint)))))
          _ (reset-fn-context fn-context)
          checking-fn-var (global-var fn-sym "paramChecker")
          arity-var (comp (for [dispatch-type (sm/when (first param-types))
                                proto-impl (get-proto-impl fn-sym arity-index dispatch-type)]
                            (.c-var proto-impl))
                          (global-var fn-sym "staticArity"))]
      (let [;; TODO: handle variadic fns properly
            fn-var (either (and (or (every param-constraints empty?)
                                    (.variadic params))
                                (maybe arity-fn-var))
                           checking-fn-var)
            body (collapse-expressions (comp (.destruct param-vars) body-exprs))
            arity-decl [(.decl body)
                        "Value *" arity-fn-var "("
                        (-> (.vars param-vars)
                            (map (fn [param] (str "Value *" param)))
                            (seq)
                            (conj "List *closures")
                            (interpose ", "))
                        ") {\nwhile (1) {\n"
                        (.init body)
                        line-sep "};};\n"]
            ;; TODO: handle variadic fns properly
            checking-fn (either (and (or (every param-constraints empty?)
                                         (.variadic params))
                                     (maybe []))
                                ["Value *" checking-fn-var "("
                                 (-> (.vars param-vars)
                                     (map (fn [param] (str "Value *" param)))
                                     (seq)
                                     (conj "List *closures")
                                     (interpose ", "))
                                 ") {\n"
                                 ;; "fprintf(stderr, \"Checking params for " (str fn-sym)
                                 ;; " " (ast/file-name fn-sym) " " (ast/line-number fn-sym) "\\n\");\n"
                                 (map check-params .init)
                                 "return(" arity-fn-var "("
                                 (-> (.vars param-vars)
                                     (seq)
                                     (conj "closures")
                                     (interpose ", "))
                                 "));\n};\n"])]
        (do
          ;; TODO: use this to eliminate unknown return type values
          ;; (and (= UnknownType (.type-num body))
          ;;      (maybe (print-err 'unknown-return-type fn-sym
          ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
          (StaticArity arity-fn-var arity-index (.type-num body)
                       (c-code (str "&" arity-var) []
                               [arity-decl
                                checking-fn
                                "FnArity " arity-var " = {FnArityType, -1, "
                                (count (.vars param-vars))
                                ", (List *)0, " ((.variadic params) "1" "0")
                                ", " fn-var "};" line-sep]
                               FnArityType {})
                       param-constraints))))))

(defn check-result-assertions [result-asserts]
  (let [asserted-return-types (reduce result-asserts []
                                      (fn [asserted-types assertion]
                                        (either (map (assert-return-type assertion)
                                                     (fn [type-sym]
                                                       (conj asserted-types (maybe type-sym))))
                                                asserted-types)))]
    (for [asserted-type-nums (traverse asserted-return-types get-type-number)
          _ (sm/when (or (< (count asserted-type-nums) 2)
                         (flat-map (first asserted-type-nums)
                                   (fn [type-num]
                                     (=* type-num asserted-type-nums)))))]
      "")))

(defn emit-fn-arity
  ([fn-sym fn-var params param-types body]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))
   (flat-map (global-var fn-sym "arityImpl")
             (fn [arity-fn-var]
               (emit-fn-arity fn-sym fn-var params param-types body
                              (str arity-fn-var)))))

  ([fn-sym fn-var params param-types body arity-fn-var]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))
   (assert (instance? String arity-fn-var))

   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [return-constraints (filter body return-assertion?)]
             (for [fn-context (reset-fn-context)
                   _ (comp (check-result-assertions return-constraints)
                           (compilation-error "Conflicting result assertions in:"
                                              fn-sym "at:" (ast/file-name body)
                                              (ast/line-number body)
                                              (to-str (flat-map return-constraints
                                                                (fn [a]
                                                                  ["\n" (ast/file-name a)
                                                                   " " (ast/line-number a)])))))
                   _ (comp (sm/get-in-val [.fn-context .expr-context .syms fn-sym])
                           (sm/assoc-in-val [.fn-context .expr-context .syms fn-sym]
                                            (c-code fn-var [] [] FunctionType {})))
                   param-vars (bind-params params fn-var arity-fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   _ (traverse (zip-lists (seq (.fixed params)) (seq param-types))
                               (fn [[var type-num]] (set-type var type-num)))
                   body-exprs (-> body
                                  (tail-call (.vars param-vars) return-constraints)
                                  emit)
                   arity-info (comp (emit-closure-arity fn-sym fn-context arity-fn-var params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context arity-fn-var params
                                                       param-vars param-types body-exprs))]
               arity-info)))))

(defn validate-protocol-names [ast]
  (traverse (keys (.impls ast))
            (fn [protocol-name]
              (comp (get-protocol protocol-name)
                    (compilation-error "Invalid protocol:" protocol-name "in"
                                       (str (ast/file-name ast) ",")
                                       (ast/line-number protocol-name))))))

(defn validate-proto-fn-name [fn-name arg-count]
  (comp (get-protocol-dispatcher fn-name arg-count)
        (compilation-error "Invalid protocol fn:"
                           (str "'" fn-name "' in")
                           (str (ast/file-name fn-name) ",")
                           (ast/line-number fn-name))))

(deftype ProtoImplDeclaration [fn-name arity-ast arity-impl-var c-decl]
  (assert (instance? String arity-impl-var))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl)))

(defn declare-impl [type-str type-num [fn-name arity-ast]]
  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (map (global-var (str type-str fn-name) "arityImpl") str)
          dispatcher-info (validate-proto-fn-name fn-name num-args)
          _ (new-proto-impl fn-name num-args type-num
                            (c-code impl-fn-var [] [] (.return-type dispatcher-info) {})
                            arity-ast)
          _ (new-static-arity impl-fn-var num-args arity-impl-var (.return-type dispatcher-info))]
      (ProtoImplDeclaration fn-name arity-ast arity-impl-var
                            ["Value *" arity-impl-var "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"]))))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))
  (let [[fn-name arity-ast arity-var] (type-args impl-decl)
        params (.params arity-ast)
        num-args (count params)]
    (for [dispatcher-info (validate-proto-fn-name fn-name num-args)
          ;; _ (debug 'fn-name type-str fn-name
          ;;          (ast/file-name fn-name) (ast/line-number fn-name))
          :let [param-constraints (.param-constraints dispatcher-info)
                assertions (for [[param constraints] (zip-lists (.fixed params)
                                                                param-constraints)
                                 constraint constraints]
                             (to-assertion constraint param))]
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-name))
                                      (.fn-var arity-ast)
                                      params [type-num]
                                      (comp assertions
                                            (.return-constraints dispatcher-info)
                                            (.body arity-ast))
                                      arity-var)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-name "' in")
                                          (str (ast/file-name fn-name) ",")
                                          (ast/line-number fn-name)))
          reified (reify-arity ext-fn type-num arity-ast fn-name)
          ;; _ (debug "---------")
          ]
      reified)))

(defn extend-type* [ast type-num]
  (let [impl-arities (for [impl-fns (vals (.impls ast))
                            [fn-name arities] (seq impl-fns)
                            impl-arity arities]
                        [fn-name impl-arity])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe (str "_" type-num "_")))
                _ (validate-protocol-names ast)
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns)
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.type-num value) (.refs-map value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] (.type-num value) {}))]
      [value]))

  (tail-call [ast params return-constraints]
    (TailExpr ast params return-constraints)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defn cond-clause-init [cond-test expr-result [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs)
                     (filter-vals (partial < 0)))]
    [(conj (vec init)
           [(.init clause)
            expr-result " = " (.c-var clause) ";" line-sep
            cond-test expr-result ",\"" (ast/file-name clause) "\"," (ast/line-number clause)
            ")) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep]))])
     refs-map]))

(defn emit-cond-expr [result-var clauses cond-test tail-return]
    (for [evalled-clauses (-> clauses
                              (filter produces-code?)
                              (traverse
                               (fn [clause]
                                 (comp (for [_ (sm/when (or (instance? Symbol clause)
                                                            (instance? rdr/tagged-symbol clause)))
                                             _ (add-assertion (ast/type-assertion
                                                               'Maybe clause
                                                               (list [(str (ast/file-name clause) ":")
                                                                      (ast/line-number clause)])))
                                             expr (emit clause)]
                                         expr)
                                       (map (emit clause)
                                            (fn [expr]
                                              (either (and (or (= (.type-num expr) MaybeType)
                                                               (= "" (.c-var expr)))
                                                           (maybe expr))
                                                      (.init expr [(.init expr)
                                                                   "if (" (.c-var expr) "->type != MaybeType) {" line-sep
                                                                   "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
                                                                   (ast/file-name clause) "\","
                                                                   (ast/line-number clause)
                                                                   ");" line-sep
                                                                   "fprintf(stderr, \"Expected Maybe, got %s\\n\", extractStr(type_name(empty_list, "
                                                                   (.c-var expr) ")));" line-sep
                                                                   "abort();" line-sep
                                                                   "}" line-sep]))))))))
          last-clause (sm/when (last evalled-clauses))]
      (let [clause-vars (-> evalled-clauses
                            (remove (fn [c] (empty? (.init c))))
                            (map .c-var)
                            set)
            refs-maps (map evalled-clauses .refs-map)
            refs-map (-> (apply merge-with + refs-maps)
                         (remove-keys clause-vars)
                         (filter-vals (partial < 0)))
            [clause-inits] (-> (butlast evalled-clauses)
                               (reduce [[] refs-map]
                                       (partial cond-clause-init cond-test result-var)))
            last-init ((= "" (.c-var last-clause))
                       (.init last-clause)
                       [(.init last-clause)
                        result-var " = " (.c-var last-clause) ";" line-sep])
            clause-inits (conj clause-inits last-init)]
        (c-init result-var
                ["Value *" result-var ";" line-sep
                 (interpose clause-inits [tail-return "} else {" line-sep
                                          "dec_and_free(" result-var ", 1);" line-sep])
                 (-> evalled-clauses
                     count
                     dec
                     (repeat (str "}" line-sep)))]
                (map evalled-clauses .decl)
                MaybeType refs-map))))

(deftype TailAnd [clauses]
  ;; (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing("
                               (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (isNothing(" "")]
      expr))

  (tail-call [ast params return-constraints]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailAnd (-> (tail-call last-clause params return-constraints)
                   (cons clauses)
                   reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr result-var (.clauses ast) "if (!isNothing("
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-cond-expr result-var (.clauses ast) "if (!isNothing(" line-sep))))

  (tail-call [ast params return-constraints]
    (let [clauses (.clauses ast)]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params return-constraints))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs)))))) 

(deftype TailEither [clause alt return-constraints]
  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))
  
  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (emit alt)
          result-var (genlocal "rslt")
          type-num (get-type-number (some return-constraints assert-return-type))
          cond-check (emit-return-constraints (c-code result-var [] [] UnknownType {})
                                              return-constraints)
          alt-val (comp (emit-tail-expr clause
                                        (ast/file-name ast)
                                        (ast/line-number ast)
                                        return-constraints
                                        alt-val)
                        (compilation-error "Could not emit code for 'either' expression at"
                                           (str (ast/file-name clause) ":")
                                           (ast/line-number clause)))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"" (ast/file-name ast) "\"," (ast/line-number ast)
                 ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map cond-check .init)
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                type-num
                refs-map)))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          ;; TODO: make sure cond-val is a Maybe type in a way that propagates out
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"" (ast/file-name ast) "\"," (ast/line-number ast)
                 ")) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map))))

  (tail-call [ast params return-constraints]
    (TailEither (.clause ast) (.alt ast) return-constraints))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs)))) 


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) "" (.params ast) [ListType] (.body ast))
          ;; _ (debug "=======")
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [params (.params prototype)
        num-args (count params)
        body (.default-body prototype)
        type-symbol (some body assert-return-type)
        return-constraints (filter body return-assertion?)
        assertions (filter body assertion?)]
    (for [curr-context (sm/get-val .fn-context)
          fn-context (reset-fn-context)
          _ (bind-params params "" "")
          _ (emit assertions)
          constraints (traverse (.fixed params)
                                (fn [sym]
                                  (for [var (map (lookup-sym sym) .c-var)
                                        cs (sm/get-in-val [.fn-context .constraints var] [])]
                                    cs)))
          _ (reset-fn-context curr-context)
          arity-fn-var (global-var fn-name "protoDisp")
          impls-sym (global-var (str fn-name "_Implementations") "protoImpls")
          return-type (get-type-number type-symbol)
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym
                                  return-type return-constraints constraints)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var return-type)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (rdr/tag (str "Default_" fn-name)) ""
                                            (.params prototype) [] default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))
          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var fn-name "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities
                                   (partial declare-proto-dispatch-arity fn-name
                                            dispatch-fn-sym))
        default-fns (traverse arities (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map)
                           (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    ;; TODO: remove the '.param-types' field
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe (rdr/tag 'anon)))
                           (.fn-sym ast))
                   (.fn-var ast) (.params ast) (.param-types ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.return-type static-arity)
                                                              (.param-constraints static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-code fn-var
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)]
              FunctionType
              (apply merge-with + (map emitted-arities .refs-map))))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                arities (emit (map (.arities ast) (fn [arity]
                                                    (-> arity
                                                        (.fn-sym fn-sym)
                                                        (.fn-var fn-var)))))
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailExpr x params return-constraints))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast new-arities)))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums (partial extend-type* ast))
                           flatten)]
              fns)
            (for [ns-path (sym-ns-path (.type ast))
                  type-num (comp (sm/get-in-val [.modules ns-path .types type-sym])
                                 (sm/get-in-val [.modules 'core .types type-sym]))
                  fn (extend-type* ast type-num)]
              fn)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(deftype sym-type-ast [sym type-num]
  ;; (assert (instance? Symbol sym))
  (assert (instance? Integer type-num))

  Stringable
  (string-list [_]
    (list "<FieldType " (str sym) " " (str type-num) ">"))

  Emitter
  (replace-syms [ast subs]
    (sm/state-maybe (sym-type-ast (either (get subs sym)
                                          sym)
                                  type-num)))

  (emit [_]
    (set-type sym type-num)))

(deftype expr-type-ast [type-sym ast]
  ;; (assert (instance? ast/call-ast ast))
  ;; (assert (instance? Symbol type-sym))

  Stringable
  (string-list [_]
    (list "<ExprType " (str type-sym) " " (str ast) ">"))

  Emitter
  (tail-call [_ params return-constraints]
    (expr-type-ast type-sym (tail-call ast params return-constraints)))

  (emit [_]
    (for [type-num (get-type-number (maybe type-sym))
          expr (emit ast)]
      (.type-num expr type-num))))

(defn constructor-expr [new-type-name type-val-sym fields assertions]
  (ast/definition new-type-name
    [(ast/reified (extract rdr/type-counter)
                  {Type-sym
                   [[type-name-sym
                     [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                        (ast/params ['_]) "" []
                                        [(str "*" new-type-name " constructor*")])]]
                    [instance?-sym
                     [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                        (ast/params ['x 'y]) "" []
                                        [(ast/call-ast =*-sym
                                                       [(ast/call-ast get-type-sym [type-val-sym])
                                                        (ast/call-ast get-type-sym ['y])])])]]]

                   Function-sym
                   [[invoke-sym
                     [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                        (ast/params (vec (cons '_ (seq fields)))) "" []
                                        (comp assertions
                                              [(expr-type-ast
                                                new-type-name
                                                (ast/call-ast new-type-value-sym
                                                              [type-val-sym
                                                               (ast/call-ast 'vector
                                                                             (vec fields))]))]))]]]

                   Stringable-sym
                   [[string-list-sym
                     [(ast/fn-arity (ast/params ['z]) ""
                                    [(ast/call-ast list-sym
                                                   ["<TypeCon " (str new-type-name) " ["
                                                    (to-str (interpose fields ", ")) "]>"])])]]]})]))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") ""
                                                      (ast/params [x*]) "" []
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/or-ast
                                       (map fields
                                            (fn [field]
                                              (ast/call-ast identical-sym
                                                            [(rdr/tag (str "." field))
                                                             field*]))))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") ""
                                     (ast/params [x* y*]) "" []
                                     [(ast/and-ast
                                       [(ast/call-ast
                                              =*-sym [(ast/call-ast get-type-sym [x*])
                                                      (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])])])]]]

                                 Associative-sym
                                 [[get-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") ""
                                     (ast/params [x* field* 'new-value '_ '_]) "" []
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         [(ast/and-ast
                                                [(ast/call-ast has-field-sym [x* field*])
                                                 (ast/call-ast
                                                  maybe-sym
                                                  [(ast/call-ast field* [x* 'new-value])])])
                                          (ast/call-ast maybe-sym [x*])])])])]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] []
                                                                 FunctionType {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1
                                                                   UnknownType [] [] {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2
                                                                   UnknownType [] [] {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 UnknownType)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 UnknownType)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn create-getters [sym fields type-assertions]
  (let [type-value (rdr/tag "#value")
        field-types (reduce type-assertions {}
                            (fn [field-types assertion]
                              (let [type-assertion (.assertion assertion)]
                                (assoc field-types
                                  (.sym type-assertion) (.type-sym type-assertion)))))]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)))
          (fn [[field field-index]]
            (let [new-value (rdr/tag (str field))
                  extract-field (ast/call-ast
                                 extract-sym
                                 [(ast/call-ast
                                   nth-sym [(ast/call-ast reified-type-args-sym
                                                          [type-value])
                                            field-index])])
                  extract-field (either (map (get field-types field)
                                             (fn [field-type]
                                               (expr-type-ast field-type extract-field)))
                                        extract-field)
                  set-field (expr-type-ast
                             sym (ast/call-ast
                                  make-value-sym
                                  [type-value
                                   (ast/call-ast extract-sym
                                                 [(ast/call-ast
                                                   store-sym
                                                   [(ast/call-ast
                                                     reified-type-args-sym
                                                     [type-value])
                                                    field-index new-value])])]))]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value new-value]) "" []
                                  (either (map (get field-types field)
                                               (fn [type-sym]
                                                 [(ast/assert-expr
                                                   (ast/assert-type type-sym new-value))
                                                  set-field]))
                                          [set-field]))
                (ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value]) "" []
                                  [extract-field])]])))}))

(defn destruct-impl-fields [sym ast assertions arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        return-constraints (filter (.body arity) return-assertion?) 
        new-body (comp return-constraints
                       [(ast/let-ast [(ast/binding (.fields ast)
                                        (ast/call-ast
                                         reified-type-args-sym
                                         [type-value-parameter]))]
                                     (comp (vec assertions) (.body arity)))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast assertions]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast assertions))]))))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            file-name ", " (ast/line-number ast)))]
              "")
            
            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym
                                              (ast/file-name sym)
                                              (ast/line-number sym))
                        type-num (extract rdr/type-counter)]
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                  _ (sm/assoc-in-val [.constants .type-names type-num] sym)
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition
                                    (constructor-expr sym type-val-sym fields
                                                      (filter (.impls ast) assertion?)))
                  const-type-num (sm/get-in-val [.modules file-name .values sym .type-num])

                  field-types (traverse (filter (.impls ast) assert-type)
                                        (fn [assertion]
                                          (let [type-assertion (.assertion assertion)]
                                            (for [type-num (-> (.type-sym type-assertion)
                                                               maybe
                                                               get-type-number)]
                                              (sym-type-ast (.sym type-assertion) type-num)))))
                  :let [impls (merge-with comp
                                          (create-getters sym fields
                                                          (filter (.impls ast) assert-type))
                                          (destructure-fields sym ast field-types))]
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))
                  constructor-arity (map (get-proto-impl invoke-sym const-arity-index
                                                         const-type-num)
                                         .c-var)
                  _ (sm/assoc-in-val [.fns constructor-arity const-arity-index .c-info .type-num]
                                     type-num)]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) UnknownType {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0
                                                         (ExpressionContext {} {})
                                                         {} empty-closures {} [])
                                   (RuntimeInit (FunctionArityContext
                                                 {} 0 (ExpressionContext {} {})
                                                 {} empty-closures {} [])
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names)
                                   0                        ;; reify-fn-index 
                                   {}                       ;; other
                                   ))

(def string-writer (agent ""))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity 'main 1)
                      (compilation-error "'main' function is missing"))
        values (sm/get-in-val [.init .exprs])]
    (write-strings ["\n#\n"
                    "\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map values .init) "\n"
                    "#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    (map values free-global) "\n"
                    "#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif\n"
                    "#\n"
                    "  return(0);\n};\n"])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args UnknownType
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {})
                    [])]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn))
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules 'core .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (sm/assoc-in-val [.modules module-name]
                                         (Module module-name {} {} {} core-types {}))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [_ (map emitted (fn [expr]
                                                     (write-strings (.decl expr))))]
                              _ (sm/update-in-val [.init .exprs] (fn [exprs]
                                                                   (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))

(def finalize-protocols*
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              emit-proto-fn)]
    (map dispatchers (fn [expr] (write-strings (.decl expr))))))

(defn finalize-protocols [context]
  (update-context context
                  (comp finalize-protocols*
                        (compilation-error "Compilation error (Could not finalize protocols.)"))))

(def fixup-native-symbols*
  (apply-to (fn [& decl]
              (write-strings decl))
            (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                 (fn [arity-sym]
                   ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                 (fn [arity-sym]
                   ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                 (fn [arity-sym]
                   ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'assoc*) 5)
                 (fn [arity-sym]
                   ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                 (fn [arity-sym]
                   ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'get*) 5)
                 (fn [arity-sym]
                   ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                 (fn [arity-sym]
                   ["Value *(*showFn)(List *, Value *) = " (.c-var arity-sym) ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                 (fn [arity-sym]
                   ["Value *(*fn_apply)(List *, Value*, Value*) = "
                    (.c-var arity-sym) ";\n"]))))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast) 
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future))) 
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq 
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (assoc modules 'core 'loaded)))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
      (let [[_ file-name] params
            waiter (promise)]
        (or (map (file-directory file-name)
                 (fn [root-dir]
                   (write-strings ["\n#define _XOPEN_SOURCE 600"
                                   "\n#include <stdlib.h>"
                                   "\n#include \"core.h\"\n"])
                   (send module-compiler compile-module file-name waiter root-dir root-dir)))
            (do
              (print-err "Could not find " (str "'" file-name "'"))
              (abort)))
        (extract waiter)
        (send ast-emitter emit-main)
        (send ast-emitter finalize-protocols)
        (send ast-emitter fixup-native-symbols)
        (send ast-emitter (fn [ctxt]
                            (print-err
                             "\n" 'static-fixed (get-in ctxt ['_ .other 'static-fixed-sites])
                             "\n" 'static-variadic (get-in ctxt ['_ .other 'static-variadic-sites])
                             "\n" 'invoke (get-in ctxt ['_ .other 'invoke-sites])
                             "\n" 'dyn-fn (get-in ctxt ['_ .other 'dyn-fn-sites])
                             "\n" 'dyn-unknown (get-in ctxt ['_ .other 'dyn-unknown-sites])
                             "\n" 'type-known (get-in ctxt ['_ .other 'type-known-sites])
                             "\n" 'type-unknown (get-in ctxt ['_ .other 'type-unknown-sites])
                             "\n")))
        ;; wait for agents to clear their queues
        (let [waiter (promise)]
          (send ast-emitter (fn [_]
                              (send string-writer (fn [_]
                                                    (deliver waiter 'x)))))
          (extract waiter))))

