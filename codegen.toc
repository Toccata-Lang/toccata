
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "2a759e2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns b (module "base.toc"))

(def lf "\n")
(def lflf "\n\n")

(def line-sep lf)

(defn line-marker [loc marker]
  (assert (instance? c/Location loc))

  (cond (or (= "" (.file loc))
            (and (= 'core (.file loc))
                 (= 0 (.line loc)))
            (= line-sep lf))
        ["\n// " loc "\n#\n"]
        ["\n" marker "\n#line "
         (str (.line loc)) " " "\""
         (cond (= 'core (.file loc))
               b/path-to-core
               (.file loc))
         "\"\n"]))

(def output (agent (maybe 'output)))

(defn code-out [& code]
  (send output (fn [out-file?]
                 (hylo (fn [x]
                         (cond (or (instance? String x)
                                   (instance? Integer x))
                               (do
                                 (print x)
                                 [])

                               x))
                       (fn [x]
                         (cond (instance? Sequence x)
                               x

                               (print x)))
                       code)
                 out-file?)))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(defn is-glbl [var]
  (= (subs var 0 b/glbl-len) b/glbl))

(deftype C-code [var decl init refs-map]
  (assert (instance? String var))
  (assert (instance? Vector decl))
  (assert (instance? Vector init))
  (assert (instance? HashMap refs-map))

  Composition
  (comp* [expr exprs]
    (let [[last-expr & exprs] (reduce exprs (list expr) conj)]
      (-> exprs
          (reduce last-expr
                  (fn [code expr-code]
                    (let [rslt-var (.var expr-code)
                          rslt-refs (cond (is-glbl rslt-var)
                                          0

                                          (dec (either (get (.refs-map code) rslt-var)
                                                       0)))
                          adjust-refs (cond (or (= rslt-var "")
                                                (= rslt-refs 0))
                                            []

                                            (< rslt-refs 0)
                                            [line-sep "dec_and_free(" rslt-var ", 1);" line-sep]

                                            [line-sep "incRef(" rslt-var ", " rslt-refs ");" line-sep])
                          refs (merge-with + (dissoc (.refs-map code) rslt-var)
                                           (.refs-map expr-code))]
                      (-> code
                          (.decl (comp (.decl expr-code) (.decl code)))
                          (.init (comp (.init expr-code)
                                       adjust-refs
                                       (.init code)))
                          (.refs-map refs)))))))))

(def empty-c-code (C-code "" [] [] {}))

(defn collapse-codes [codes]
  (comp* empty-c-code
         (map codes (fn [code]
                      (.var code "")))))

(def generic-call)
(defprotocol CodeGen
  (gen-call [tgt args mod result-var]
    (assert-result r (instance? se/StateError r))

    (generic-call tgt args mod result-var))

  (gen-code [ast mod]
    (assert-result r (instance? se/StateError r))
    )

  (gen-code [ast mod arity]
    (assert-result r (instance? se/StateError r))

    (gen-code ast mod)))

(defn generic-call [tgt args mod result-var]
    (assert-result r (instance? se/StateError r))
    ;; by providing impls for this, call sites can be optimized

    (for [tgt-code (gen-code tgt mod)
          arg-codes (se/traverse args (fn [arg]
                                        (map (gen-code arg mod)
                                             (fn [code]
                                               (either (update code .refs-map
                                                               (fn [m]
                                                                 (assoc m (.var code) 1)))
                                                       code)))))]
      (let [expr-code (collapse-codes (list* tgt-code arg-codes))
            num-args (count args)]
        (-> expr-code
            (.var result-var)
            (.init [(.init expr-code)
                    (line-marker (ast/location tgt) "// dynamic unknown type")
                    (cond (is-glbl result-var)
                          ""
                          ["Value *" result-var ";" line-sep])
                    ;; TODO: handle non-function call targets
                    ;; "if((" (.var tgt-code) ")->type != FunctionType) {" line-sep
                    ;; result-var " = " invoke-arity-sym "("
                    ;; (interpose (list* (str "(FnArity *)" (.c-var sym-location))
                    ;;                   (.c-var target) args) ", ") ");"
                    ;; line-sep "} else {" line-sep
                    "if(" (.var tgt-code) "->type == FunctionType) {" line-sep

                    ;; look for static arity and call that
                    "FnArity *arity = findFnArity(" (.var tgt-code) ", " num-args ");"
                    line-sep
                    "if(arity != (FnArity *)0 && !arity->variadic) {" line-sep
                    "FnType" num-args " *fn = (FnType" num-args " *)arity->fn;" line-sep
                    result-var " = fn(arity, " (-> arg-codes (map .var) (interpose ", "))
                    ");" line-sep

                    "} else if(arity != (FnArity *)0 && arity->variadic) {" line-sep
                    "FnType1 *fn = (FnType1 *)arity->fn;" line-sep
                    "List *args = empty_list;" line-sep
                    (map (reverse arg-codes)
                         (fn [arg]
                           (str "args = (List *)listCons("
                                (.var arg) ", args);" line-sep)))
                    result-var " = fn(arity, (Value *)args);" line-sep
                    "} else {" line-sep
                    "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                    "((Function *)" (.var tgt-code) ")->name"
                    ");" line-sep "  abort();" line-sep "}" line-sep
                    (cond (is-glbl (.var tgt-code))
                          ""
                          ["dec_and_free("(.var tgt-code) ", 1);" line-sep])
                    "}" line-sep])))))

(defn emit-code [ast mod]
  (cond (instance? ast/inline-ast ast)
        (se/state-error (code-out (.txt ast)))

        (for [code (gen-code ast mod)]
          (code-out (.decl code)))))

(defn call-vector [tgt args mod result-var]
  (for [arg-codes (se/traverse args (fn [arg]
                                      (gen-code arg mod)))]
    (-> (conj arg-codes
              (-> empty-c-code
                  (.decl (cond (is-glbl result-var)
                               ["Value *" result-var ";" line-sep]
                               []))
                  (.init [(cond (is-glbl result-var)
                                ""
                                ["Value *" result-var ";"])
                          "if (1) {Vector *v = empty_vect;" line-sep
                          (map arg-codes
                               (fn [arg-code]
                                 ["v = mutateVectConj(v, " (.var arg-code) ");"
                                  line-sep]))
                          result-var " = (Value *)v;}" line-sep])))
        collapse-codes
        (.var result-var))))

(defn call-list [tgt args mod result-var]
  (for [arg-codes (se/traverse args (fn [arg]
                                      (gen-code arg mod)))]
    (-> (conj arg-codes
              (-> empty-c-code
                  (.decl (cond (is-glbl result-var)
                               ["Value *" result-var ";" line-sep]
                               []))
                  (.init [(cond (is-glbl result-var)
                                ""
                                ["Value *" result-var ";"])
                          "if (1) {List *l = empty_list;" line-sep
                          (map (reverse arg-codes)
                               (fn [arg-code]
                                 ["l = listCons(" (.var arg-code) ", l);"
                                  line-sep]))
                          result-var " = (Value *)l;}" line-sep])))
        collapse-codes
        (.var result-var))))

(extend-type c/TaggedSymbol
  CodeGen
  (gen-call [tgt args mod result-var]
    (cond (= tgt 'vector)
          (call-vector tgt args mod result-var)

          (= tgt 'list)
          (call-list tgt args mod result-var)

          (generic-call tgt args mod result-var)))

  (gen-code [x mod]
    (se/state-error (.var empty-c-code (.var x)))))

(extend-type ast/inline-ast
  CodeGen
  (gen-code [x mod]
    (cond (= (.var x) "")
          (se/state-error (.init empty-c-code [(.txt x)]))

          (se/state-error (.decl empty-c-code ["Value *" (.var x) " = " (.txt x) ";"]))))

  (gen-code [x mod arity]
    (gen-code x mod)))

(defn destruct-seq [p]
  (assert (instance? (any-of ast/ParamType c/NoSymbol) p))
  (assert-result r (instance? Vector r))

  (cond (or (= p c/no-symbol)
            (instance? c/TaggedSymbol p))
        []

        (and (empty? (.fixed p))
             (instance? c/TaggedSymbol (.variadic p)))
        ["Value *" (.var (.variadic p)) " = " (.var p) ";" line-sep]

        (let [elem-count (inc (count (.fixed p)))
              loc (ast/location p)]
          [(map (.fixed p) (fn [inner]
                             ["Value *" (.var inner) ";" line-sep]))
           "if (1) {Value **destArgs [" elem-count "] = {"
           (map (.fixed p) (fn [inner]
                             ["&" (.var inner) ", "]))
           (cond (= c/no-symbol (.variadic p))
                 "(Value **)0"
                 ["&" (.var (.variadic p))])
           "};" line-sep "destructValue(\"" (.file loc) "\", \"" (.line loc)
           "\", (Value *)" (.var p) ", " elem-count ", destArgs);" line-sep "}" line-sep
           (map (.fixed p) destruct-seq) (destruct-seq (.variadic p))])))

(defn checking-fn [params arity-fn-var]
  (assert (instance? ast/params-ast params))
  (let [loc (ast/location params)
        checking-fn-var (b/global-var "checkerFn")]
    (cond (instance? c/TaggedSymbol (.variadic params))
          (do
            ;; (c-code checking-fn-var
            ;;         ["Value *" checking-fn-var
            ;;          "(FnArity *arity, Value *args) {\n"
            ;;          line
            ;;          "int " checked-var "= 1;"
            ;;          (-> constraints
            ;;              (c/update-var "args")
            ;;              ;; TODO: what if runtime-check is empty?
            ;;              (runtime-check c/top-type file-name line-number checked-var))
            ;;          "if(!" checked-var "){abort();}" line-sep
            ;;          "return(" arity-fn-var
            ;;          "(arity, args));\n};\n"]
            ;;         {} c/top-type)
            (.var empty-c-code arity-fn-var)
            )

          (.var empty-c-code arity-fn-var)

          ;; (c-code checking-fn-var
          ;;         ["Value *" checking-fn-var "("
          ;;          (-> param-vars
          ;;              (map (fn [param] (str "Value *" param)))
          ;;              (seq)
          ;;              (conj "FnArity *arity")
          ;;              (interpose ", "))
          ;;          ") {\n"
          ;;          line
          ;;          "int " checked-var "= 1;"
          ;;          (for [[constraint var] (zip-lists constraints-list
          ;;                                            param-vars)]
          ;;            ;; TODO: what if runtime-check is empty?
          ;;            (-> constraint
          ;;                (c/update-var var)
          ;;                (runtime-check c/top-type file-name line-number checked-var)))
          ;;          "if(!" checked-var "){abort();}" line-sep
          ;;          "return(" arity-fn-var "("
          ;;          (-> param-vars
          ;;              (seq)
          ;;              (conj "arity")
          ;;              (interpose ", "))
          ;;          "));\n};\n"]
          ;;         {} c/top-type)
          )))

(extend-type ast/do-ast
  CodeGen
  (gen-code [ast mod]
    (map (se/traverse (.body ast) (fn [expr]
                                    (gen-code expr mod ast)))
         (fn [body-exprs]
           (comp* empty-c-code body-exprs)))))

(extend-type ast/fn-arity-ast
  CodeGen
  (gen-code [ast mod]
    (map (se/traverse (.body ast) (fn [expr]
                                    (gen-code expr mod ast)))
         (fn [body-exprs]
           (let [code (comp* empty-c-code body-exprs)]
             ;; TODO: handle recursion properly
             code)))))

(extend-type b/StaticArity
  CodeGen
  (gen-code [ast mod]
    (let [arity-var (.arity-var ast)]
      (for [arity-code (gen-code (.arity ast) mod)]
        (cond (= (-> ast .arity .params .variadic)
                 c/no-symbol)
              ;; fixed arity
              (let [params (-> ast .arity .params .fixed)
                    checker (checking-fn (-> ast .arity .params) arity-var)]
                (-> empty-c-code
                    (.var arity-var)
                    (.decl [(.decl arity-code)
                            "Value *" arity-var "("
                            (-> (reduce params ["FnArity *arity"]
                                        (fn [args arg]
                                          (conj args (str "Value *" (.var arg)))))
                                (interpose ", "))
                            ") {\nwhile (1) {"
                            (map params destruct-seq)
                            (.init arity-code) line-sep
                            (either (= "" (.var arity-code))
                                    ["return " (.var arity-code) ";"])
                            "};};\n"
                            (.decl checker)
                            "FnArity " (.fn-var (.arity ast)) " = {FnArityType, REFS_STATIC, "
                            (count params)
                            ", (Vector *)0, (Value *)0, 0"
                            ", " (.var checker)
                            "};" line-sep])))

              ;; variadic arity
              (let [params (-> ast .arity .params)
                    checker (checking-fn (-> ast .arity .params) arity-var)]
                (-> empty-c-code
                    (.var arity-var)
                    (.decl [(.decl arity-code)
                            "Value *" arity-var "(FnArity *arity, Value *" (.var params)
                            ") {\nwhile (1) {"
                            (destruct-seq params)
                            (.init arity-code) line-sep
                            (either (= "" (.var arity-code))
                                    ["return " (.var arity-code) ";"])
                            "};};\n"
                            (.decl checker)
                            "FnArity " (.fn-var (.arity ast)) " = {FnArityType, REFS_STATIC, "
                            "1, (Vector *)0, (Value *)0, 1"
                            ", " (.var checker)
                            "};" line-sep]))))))))

(extend-type ast/fn-ast
  CodeGen
  (gen-code [ast mod]
    (let [fn-sym (.fn-sym ast)
          fn-var (.var ast)
          arities (.arities ast)]
      ;; TODO: what if fn-sym is c/no-symbol
      (cond (every arities (fn [arity]
                             (instance? b/StaticArity arity)))
            (for [code-vect (se/traverse arities
                                         (fn [arity]
                                           (gen-code arity mod)))]
              (let [struct-var (b/global-var "fnStruct")
                    expr (collapse-codes code-vect)]
                (-> empty-c-code
                    (.var fn-var)
                    (.decl [(.decl expr)
                            "\n// --------- " fn-sym " -------------\n"
                            ;; "Value *" fn-var ";" line-sep
                            "Function " struct-var " = {FunctionType, REFS_STATIC, \""
                            fn-sym "\", " (count arities) ", "
                            "{"   (-> arities
                                      (map (fn [static-arity]
                                             (str "&" (-> static-arity .arity .fn-var))))
                                      (interpose ", "))
                            "}};\n"
                            "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]))))

            (do
              (print-err 'finish _FILE_ _LINE_)
              (se/state-error (abort)))))))

(extend-type ast/definition-ast
  CodeGen
  (gen-code [ast mod]
    (let [[expr] (.value-exprs ast)]
      (for [code (gen-code expr mod)
            _ (se/update-val .init (fn [glbl-init]
                                     (let [add-global (either (= (.var code) "")
                                                              [(.var code) "->refs = refsConstant;"
                                                               line-sep "globals = listCons("
                                                               (.var code) ", globals);\n"])]
                                       (conj glbl-init
                                             (either (empty? (.init code))
                                                     [(map (vec (.refs-map code))
                                                           (fn [[var refs]]
                                                             (cond (is-glbl var)
                                                                   []
                                                                   [line-sep "incRef(" var ", "
                                                                    (str refs) ");" line-sep])))
                                                      (.init code)
                                                      add-global])))))]
        (-> code
            (.decl (cond (empty? (.init code))
                         ["// " (str (ast/location ast) "\n")
                          (.decl code)]
                         (cond (= (.var code) "")
                               (.decl code)
                               ["Value *" (.var code) ";" line-sep
                                (.decl code)])))
            (.init []))))))

(extend-type ast/integer-ast
  CodeGen
  (gen-code [ast mod]
    (let [num (.int ast)
          num-ptr (.var ast)]
      (comp (se/get-in-val [.constants .numbers num])
            (for [const-nums (se/get-in-val [.constants .numbers])
                  :let [num-idx (count const-nums)
                        num-sym (str "num" num-idx)]
                  _ (se/assoc-in-val [.constants .numbers num]
                                     (.var empty-c-code num-ptr))]
              (-> empty-c-code
                  (.decl ["Integer " num-sym " = {IntegerType, REFS_STATIC, " num "};\n"
                          "Value *" num-ptr " = (Value *)&" num-sym ";\n"])
                  (.var num-ptr)))))))

(extend-type ast/string-ast
  CodeGen
  (gen-code [ast mod]
    (let [str-val (.string ast)
          str-len (count str-val)
          str-ptr (.var ast)]
      (comp (se/get-in-val [.constants .strings str-val])
            (for [const-strs (se/get-in-val [.constants .strings])
                  :let [str-idx (count const-strs)
                        str-sym (str "str" str-idx)]
                  _ (se/assoc-in-val [.constants .strings str-val]
                                     (.var empty-c-code str-ptr))]
              (-> empty-c-code
                  (.decl ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        Integer *hash;
        int64_t len;
        char buffer["
                          (inc str-len)
                          "];\n} " str-sym " = {StringBufferType, REFS_STATIC, 0, "
                          str-len ", \"" (escape-chars str-val) "\"};\n"
                          "Value *" str-ptr " = (Value *)&" str-sym ";\n"])
                  (.var str-ptr)))))))

(extend-type ast/call-ast
  CodeGen
  (gen-code [ast mod]
    (gen-call (.call-target ast) (.args ast) mod (.var ast))))

(extend-type ast/binding-ast
  CodeGen
  (gen-code [ast mod]
    (for [val-code (gen-code (.val ast) mod)
          cont-codes (se/traverse (.cont ast)
                                  (fn [expr]
                                    (gen-code expr mod)))]
      (let [val-code (.init val-code [(.init val-code)
                                      (destruct-seq (.var (.binding ast) (.var val-code)))])
            code (comp* val-code (conj cont-codes
                                       (.refs-map empty-c-code {(.var val-code) 1})))]
        (either (for [_ (is-glbl (.var ast))
                      last-expr (last (.cont ast))
                      :when-not (= (.var last-expr) (.var ast))
                      new-code (update code .decl
                                       (fn [decl]
                                         (conj decl ["Value *" (.var ast) ";"])))
                      new-code (update new-code .init
                                       (fn [init]
                                         (conj init [(.var ast) " = " (.var last-expr)
                                                     ";" line-sep])))]
                  new-code)
                code)))))

(extend-type ast/block-comment-ast
  CodeGen
  (gen-code [ast mod]
    (se/state-error empty-c-code)))

(defn emit-main [code-context main-module]
  (let [main-fn (either (get-in main-module [.namespaces c/no-symbol .values 0
                                             ast/main .arities 0 .arity-var])
                        (do
                          (b/status "'main' function is missing or malformed")
                          ;; TODO: make sure to abort
                          ;; (abort)
                          ))
        ;; wait-prom (promise)
        ;; _ (send modules
        ;;         (fn [mods]
        ;;           (map (get mods core)
        ;;                (fn [ast-emitter]
        ;;                  (send ast-emitter
        ;;                        (fn [ctxt]
        ;;                          (map ctxt
        ;;                               (fn [ctxt]
        ;;                                 (.module ctxt (extract core-agent))))))
        ;;                  (send ast-emitter
        ;;                        (fn [ctxt]
        ;;                          (map ctxt
        ;;                               (fn [ctxt]
        ;;                                 (deliver wait-prom '_)
        ;;                                 ctxt))))))
        ;;           mods))
        ;; _ (extract wait-prom)
        ;; inits (map-modules (for [proto-expr gather-protocols
        ;;                          ;; syms-expr gather-symbols
        ;;                          ]
        ;;                      (comp (.init proto-expr)
        ;;                            ;; (.init syms-expr)
        ;;                            )))
        ;; decls (map-modules (sm/get-in-val [.fn-context .decl]))
        ;; values-prom (promise)
        ;; _ (send rt-exprs (partial deliver values-prom))
        ;; values (extract values-prom)
        ]
    ;; (code-out decls)
    (code-out "\n#\n"
              "\nint main (int argc, char **argv) {\n"
              "prErrSTAR = &defaultPrErrSTAR;\n"
              "#ifdef SINGLE_THREADED\n"
              "#ifdef CHECK_MEM_LEAK\n"
              "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
              "at same time.\");\n "
              "abort();\n"
              "#endif\n"
              "#endif\n"
              "maybeNothing = maybe((Vector *)0, (Value *)0, nothing);\n"
              "maybeNothing->refs = -1;\n"
              "outstream = stdout;\n"
              "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
              "futuresQueue.output = empty_list;\n"
              "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
              "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
              "pthread_mutex_init(&shutDown.access, NULL);\n"
              "startWorkers();\n"
              (.init code-context)
              ;; (map values .init)
              ;; "init_module_0();\n"
              ;; "init_module_1();\n"
              "\n#\n"
              "  Vector *argVect = empty_vect;\n"
              "  for(int i = 0; i < argc; i++) {\n"
              "    argVect = mutateVectConj(argVect, stringValue(argv[i]));\n"
              "  }\n"
              "  argVect->refs = -1;\n"

              "Value *the_final_answer = " main-fn
              "((FnArity *)0, (Value *)argVect);\n\n"

              "#ifdef CHECK_MEM_LEAK\n"
              "cleaningUp = 1;\n"
              "mainThreadDone = 1;\n"
              "waitForWorkers();\n"
              ;; (map-modules (for [expr (sm/get-in-val [.module .values 0 symbols-sym])]
              ;;                (free-global (c-init (.c-var expr) [] {} "" 0))))
              ;; (map-modules (sm/get-in-val [.setup .cleanup]))
              ;; (map values free-global)
              "\n#\n"
              ;; TODO: change to argVect
              ;; "for(List *l = argVect; l != (List *)0; l = l->tail) {\n"
              ;; "   l->refs = 1;\n"
              ;; "}\n"
              ;; TODO: casting argVect to List * is a temp hack
              "  cleanupMemory(the_final_answer, maybeNothing, (List *)argVect);\n"
              "  if (malloc_count - free_count != 0)\n"
              "    return(1);\n"
              "#endif"
              "\n#\n"
              "  return(0);\n};\n"
              "\nint typeCount = " (extract b/type-counter) ";\n")
    code-context))

(def core-dispatchers (-> [(c/tag 'type-name) 1 "type_name"
                           (c/tag 'zero) 1 "zero"
                           (c/tag 'invoke) 1 "invoke0Args"
                           (c/tag 'invoke) 2 "invoke1Arg"
                           (c/tag 'invoke) 3 "invoke2Args"
                           (c/tag '=*) 2 "equalSTAR"
                           (c/tag 'hash-seq) 2 "hashSeq"
                           (c/tag 'count) 1 "count"
                           (c/tag 'vals) 1 "vals"
                           (c/tag 'first) 1 "first"
                           (c/tag 'rest) 1 "rest"
                           (c/tag 'seq) 1 "seq"
                           (c/tag 'sha1) 1 "sha1"
                           (c/tag 'has-field) 2 "hasField"
                           (c/tag 'show) 1 "showFn"
                           (c/tag 'new-hash-set) 1 "newHashSet"
                           (c/tag 'apply) 2 "fn_apply"
                           (c/tag 'pr-value) 1 "prValue"]
                          (partition 3)))

(defn fixup-core-dispatchers [code-context core-mod]
  (map core-dispatchers
       (fn [[sym arg-count var]]
         (let [arity-sym (either (map (get-in core-mod [.namespaces c/no-symbol .values 0 sym])
                                      (fn [_]
                                        '_))
                                 ;; TODO: abort with message instead
                                 (str "noImpl" arg-count))]
           (code-out "Value *(*" var ")(FnArity *, "
                     (-> (repeat arg-count "Value *")
                         (interpose ","))
                     ") = " arity-sym ";\n"))))
  code-context)

;; Notes:

;; 2 kinds of arities static and closure with a variadic and fixed variant of each.

;; All fn's have a 'c-fn' name which is the name of C function.
;; The C function always returns a Value *.

;; The c-fn has to be pointed to by a FnArity struct, which in turn is pointed to by a Function struct.

;; Whether a fn is static or closure is only determined after it has been analyzed. Should happen in the type checker

;; Have to handle tail-exprs

;; For static fn's:

;; There is also another C function that will first check the types of all the parameters
;; and then call the other function to actually do the work.

;; Emitting static arity
;; collapse all the expressions
