
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "45e2277"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "7e0d62e"))
(add-ns b (module "base.toc"))

(defprotocol CodeGen
  (pre-gen [_])
  (gen-code [_]))

(def DefaultPreGen (any-of ast/inline-ast
                           ast/main-ast))

(extend-type DefaultPreGen
  CodeGen
  (pre-gen [x]
    x))

(extend-type ast/inline-ast
  CodeGen
  (gen-code [x]
    (b/code-out (.txt x))))

;; (extend-type ast/main-ast
;;   CodeGen
;;   (gen-code [ast]
;;     (for [
;;           ;; TODO: add param assertions
;;           fn-arity (emit-fn-arity (ast/tag main) "" (.params ast) (.body ast))
;;           fn-arity (cond (instance? StaticArity fn-arity)
;;                          (-> fn-arity
;;                              .var-info
;;                              .init
;;                              declare
;;                              (map (fn [_]
;;                                     (.var-info fn-arity (.init (.var-info fn-arity) [])))))

;;                          (sm/state-maybe fn-arity))
;;           ;; _ (debug "======= done main")
;;           _ (sm/assoc-in-val [.module .values main] fn-arity)]
;;       [empty-c-code])))

(defn emit-code [_ ast]
  (hylo pre-gen
        gen-code
        ast))

(defn emit-main [main-module]
  (let [main-fn (either (get-in main-module [.values b/main])
                        (do
                          (print-err "'main' function is missing")
                          ;; TODO: make sure to abort
                          ;; (abort)
                          ))
        ;; wait-prom (promise)
        ;; _ (send modules
        ;;         (fn [mods]
        ;;           (map (get mods core)
        ;;                (fn [ast-emitter]
        ;;                  (send ast-emitter
        ;;                        (fn [ctxt]
        ;;                          (map ctxt
        ;;                               (fn [ctxt]
        ;;                                 (.module ctxt (extract core-agent))))))
        ;;                  (send ast-emitter
        ;;                        (fn [ctxt]
        ;;                          (map ctxt
        ;;                               (fn [ctxt]
        ;;                                 (deliver wait-prom '_)
        ;;                                 ctxt))))))
        ;;           mods))
        ;; _ (extract wait-prom)
        inits []
        ;; inits (map-modules (for [proto-expr gather-protocols
        ;;                          ;; syms-expr gather-symbols
        ;;                          ]
        ;;                      (comp (.init proto-expr)
        ;;                            ;; (.init syms-expr)
        ;;                            )))
        ;; decls (map-modules (sm/get-in-val [.fn-context .decl]))
        ;; values-prom (promise)
        ;; _ (send rt-exprs (partial deliver values-prom))
        ;; values (extract values-prom)
        ]
    ;; (b/code-out decls)
    (b/code-out "\n#\n"
                "\nint main (int argc, char **argv) {\n"
                "prErrSTAR = &defaultPrErrSTAR;\n"
                "#ifdef SINGLE_THREADED\n"
                "#ifdef CHECK_MEM_LEAK\n"
                "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
                "at same time.\");\n "
                "abort();\n"
                "#endif\n"
                "#endif\n"
                "maybeNothing = maybe((Vector *)0, (Value *)0, nothing);\n"
                "maybeNothing->refs = -1;\n"
                "outstream = stdout;\n"
                "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                "futuresQueue.output = empty_list;\n"
                "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                "pthread_mutex_init(&shutDown.access, NULL);\n"
                "startWorkers();\n"
                inits
                ;; (map values .init)
                "init_module_0();\n"
                "init_module_1();\n"
                "\n#\n"
                "  List *argList = malloc_list();\n"
                "  argList->len = 0;\n"
                "  argList->head = (Value *)0;\n"
                "  argList->tail = (List *)0;\n"
                "  List *tail = argList;\n"
                "  for(int i = 0; i < argc; i++) {\n"
                "     List *newTail = malloc_list();\n"
                "     newTail->len = 0;\n"
                "     newTail->tail = (List *)0;\n"
                "     newTail->head = (Value *)0;\n"
                "     tail->head = stringValue(argv[i]);\n"
                "     tail->tail = newTail;\n"
                "     tail = newTail;\n"
                "     argList->len++;\n}\n"
                "  argList->refs = -1;\n"
                ;; "Value *the_final_answer = " (.c-fn main-fn)
                ;; "((FnArity *)0, (Value *)argList);\n\n"
                "#ifdef CHECK_MEM_LEAK\n"
                "cleaningUp = 1;\n"
                "mainThreadDone = 1;\n"
                "waitForWorkers();\n"
                ;; (map-modules (for [expr (sm/get-in-val [.module .values symbols-sym])]
                ;;                (free-global (c-init (.c-var expr) [] {} "" 0))))
                ;; (map-modules (sm/get-in-val [.setup .cleanup]))
                ;; (map values free-global)
                "\n#\n"
                "for(List *l = argList; l != (List *)0; l = l->tail) {\n"
                "   l->refs = 1;\n"
                "}\n"
                "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                "  if (malloc_count - free_count != 0)\n"
                "    return(1);\n"
                "#endif"
                "\n#\n"
                "  return(0);\n};\n"
                "\nint typeCount = " (extract b/type-counter) ";\n"))
  )
