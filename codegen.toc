
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "dc324ad"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "8b250fe"))
(add-ns b (module "base.toc"))

(def lf "\n")
(def lflf "\n\n")

(def line-sep lf)

(defn line-marker [loc marker]
  (assert (instance? c/Location loc))

  (cond (or (= "" (.file loc))
            (and (= 'core (.file loc))
                 (= 0 (.line loc)))
            (= line-sep lf))
        ["\n// " loc "\n#\n"]
        ["\n" marker "\n#line "
         (str (.line loc)) " " "\""
         (cond (= 'core (.file loc))
               b/path-to-core
               (.file loc))
         "\"\n"]))

(def output (agent (maybe 'output)))

(defn code-out [& code]
  (send output (fn [out-file?]
                 (hylo (fn [x]
                         (cond (or (instance? String x)
                                   (instance? Integer x))
                               (do
                                 (print x)
                                 [])

                               x))
                       (fn [x]
                         (cond (instance? Sequence x)
                               x

                               (print x)))
                       code)
                 out-file?)))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(defprotocol C-CodeExpr
  (make-init [code])
  (comp-code [code]
    code)
  (comp-code [code1 code2]))

(deftype C-code [var decl init refs-map]
  (assert (instance? String var))
  (assert (instance? Vector decl))
  (assert (instance? Vector init))
  (assert (instance? HashMap refs-map))

  C-CodeExpr
  (comp-code [c1 c2]
    (either (map (instance? Vector c2)
                 (fn [v]
                   (comp-code c1 (comp-code v))))
            (-> c2
                (.var (.var c2))
                (.refs-map (merge-with + (dissoc refs-map var)
                                       (.refs-map c2)))
                (.init [(.init c1) (.init c2)])
                (.decl [(.decl c1) (.decl c2)])))))

(def empty-c-code (C-code "" [] [] {}))

(deftype C-init [var decl init refs-map]
  (assert (instance? String var))
  (assert (instance? Vector decl))
  (assert (instance? Vector init))
  (assert (instance? HashMap refs-map))

  C-CodeExpr
  (make-init [code] code)

  (comp-code [c1 c2]
    (either (map (instance? Vector c2)
                 (fn [v]
                   (comp-code c1 (comp-code v))))
            (let [refs-map (merge-with + refs-map (.refs-map c2))]
              (-> c2
                  (.refs-map (dissoc refs-map (.var c1)))
                  (.init [(.init c1)
                          (either (map (get refs-map var)
                                       (fn [refs]
                                         (cond (= 1 refs)
                                               ""

                                               ["incRef(" (.var c1) ", "
                                                (dec refs) ");"])))
                                  (do
                                    ;; (b/status 'freeing _LINE_ (.var c1)
                                    ;;           lf 'c1 (.var c1)
                                    ;;           lf 'c2 (.var c2))
                                    ["dec_and_free(" (.var c1) ", 1);"]))
                          (.init c2)])
                  (.decl [(.decl c1) (.decl c2)]))))))

(def C-CodeExpr (any-of C-init
                        C-code))
;; C-CodeExpr can come from
;; fn-ast
;; integer-ast
;; string-ast
;; call-ast
;; do-ast
;; binding-ast
;; and-ast
;; or-ast

;; extend-type
;; proto-impl
;; cond-ast
;; reify-ast
;; quoted-ast
;; either-ast
;; add-ns
;; module

;; tail recursion
;; optimize call sites

(extend-type C-code
  C-CodeExpr
  (make-init [code]
    (C-init (.var code) (.decl code)
            (.init code) (.refs-map code))))

(extend-type Sequence
  C-CodeExpr
  (comp-code [v]
    (either (map (last v)
                 (fn [last-code]
                   (reduce (reverse (butlast v))
                           (either (map (instance? Vector last-code)
                                        comp-code)
                                   last-code)
                           (fn [final-code expr-code]
                             (comp-code expr-code final-code)))))
            empty-c-code))

  (comp-code [v code]
    (either (map (last v)
                 (fn [last-code]
                   (reduce (reverse v)
                           (either (map (instance? Vector code)
                                        comp-code)
                                   code)
                           (fn [final-code expr-code]
                             (comp-code expr-code final-code)))))
            (comp-code code))))

(defn collapse-codes [codes]
  (reduce codes empty-c-code
          (fn [code1 code2]
            (-> code1
                (.init (comp (.init code1) (.init code2)))
                (.decl (comp (.decl code1) (.decl code2)))))))

(def generic-call)
(defprotocol CodeGen
  (gen-call [tgt args mod result-var]
    (assert-result r (instance? se/StateError r))

    (generic-call tgt args mod result-var))

  (gen-code [ast mod]
    (assert-result r (instance? se/StateError r))
    )

  (gen-code [ast mod arity]
    (assert-result r (instance? se/StateError r))

    (gen-code ast mod)))

(defn generic-call [tgt args mod result-var]
    (assert-result r (instance? se/StateError r))
    ;; by providing impls for this, call sites can be optimized

  (for [tgt-code (gen-code tgt mod)
        arg-codes (se/traverse args (fn [arg]
                                      (map (gen-code arg mod)
                                           comp-code)))]
    (let [num-args (count args)
          code (reduce (conj arg-codes tgt-code) empty-c-code
                       (fn [final-code expr-code]
                         (let [rm (merge-with + (.refs-map final-code)
                                              (.refs-map expr-code))]
                           (-> empty-c-code
                               (.refs-map rm)
                               (.decl (conj (.decl final-code) (.decl expr-code)))
                               (.init (conj (.init final-code) (.init expr-code)))))))]
      ;; (b/status 'call _LINE_ (ast/location tgt)
      ;;           lf 'tgt (type-name tgt-code) (.var tgt-code) (.refs-map tgt-code)
      ;;           lf 'args lf (str "[" (to-str (-> arg-codes
      ;;                                            (map (fn [code]
      ;;                                                   [(type-name code)
      ;;                                                    (.var code)
      ;;                                                    (.refs-map code)]))
      ;;                                            (interpose (str lf "  ")))) "]")
      ;;           lf 'refs-map (.refs-map code))

      (C-init result-var
              (.decl code)
              [(.init code)
               (line-marker (ast/location tgt) "// dynamic unknown type")
               (cond (b/is-glbl result-var)
                     ""
                     ["Value *" result-var ";"])
               ;; TODO: handle non-function call targets
               ;; "if((" (.var tgt-code) ")->type != FunctionType) {" line-sep
               ;; result-var " = " invoke-arity-sym "("
               ;; (interpose (list* (str "(FnArity *)" (.c-var sym-location))
               ;;                   (.c-var target) args) ", ") ");"
               ;; line-sep "} else {" line-sep
               "if(" (.var tgt-code) "->type == FunctionType) {" line-sep

               ;; look for static arity and call that
               "FnArity *arity = findFnArity(" (.var tgt-code) ", " num-args ");"
               line-sep
               "if(arity != (FnArity *)0 && !arity->variadic) {" line-sep
               "FnType" num-args " *fn = (FnType" num-args " *)arity->fn;" line-sep
               result-var " = fn(arity " (map arg-codes (fn [arg]
                                                          [", " (.var arg)]))
               ");" line-sep

               "} else if(arity != (FnArity *)0 && arity->variadic) {" line-sep
               "FnType1 *fn = (FnType1 *)arity->fn;" line-sep
               "List *args = empty_list;" line-sep
               (map (reverse arg-codes)
                    (fn [arg]
                      (str "args = (List *)listCons("
                           (.var arg) ", args);" line-sep)))
               result-var " = fn(arity, (Value *)args);" line-sep
               "} else {" line-sep
               "fprintf(stderr, \"\\n*** No arity found for '%s'.\\n\", "
               "((Function *)" (.var tgt-code) ")->name"
               ");" line-sep "  abort();" line-sep "}" line-sep
               (cond (b/is-glbl (.var tgt-code))
                     ""
                     ["dec_and_free("(.var tgt-code) ", 1);" line-sep])
               "}" line-sep]
              (.refs-map code)))))

(defn emit-code [ast mod]
  (cond (instance? ast/inline-ast ast)
        (se/state-error (code-out (.txt ast)))

        (for [code (gen-code ast mod)]
          (code-out (.decl code)))))

(defn call-vector [tgt args mod result-var]
  (for [arg-codes (se/traverse args (fn [arg]
                                      (gen-code arg mod)))]
    (let [num-args (count args)
          code (reduce arg-codes empty-c-code
                       (fn [final-code expr-code]
                         (let [rm (merge-with + (.refs-map final-code)
                                              (.refs-map expr-code))]
                           (-> empty-c-code
                               (.refs-map rm)
                               (.decl (conj (.decl final-code) (.decl expr-code)))
                               (.init (conj (.init final-code) (.init expr-code)))))))]
      (C-init result-var
              [(.decl code)
               (cond (b/is-glbl result-var)
                     ["Value *" result-var ";"]
                     [])]
              [(.init code)
               (cond (b/is-glbl result-var)
                     ""
                     ["Value *" result-var ";"])
               "if (1) {Vector *v = empty_vect;"
               (map arg-codes
                    (fn [arg-code]
                      ["v = mutateVectConj(v, " (.var arg-code) ");"]))
               result-var " = (Value *)v;}"]
              (.refs-map code)))))

(defn call-list [tgt args mod result-var]
  (for [arg-codes (se/traverse args (fn [arg]
                                      (gen-code arg mod)))]
    (let [num-args (count args)
          code (reduce arg-codes empty-c-code
                       (fn [final-code expr-code]
                         (let [rm (merge-with + (.refs-map final-code)
                                              (.refs-map expr-code))]
                           (-> empty-c-code
                               (.refs-map rm)
                               (.decl (conj (.decl final-code) (.decl expr-code)))
                               (.init (conj (.init final-code) (.init expr-code)))))))]
      (C-init result-var
              [(.decl code)
               (cond (b/is-glbl result-var)
                     ["Value *" result-var ";"]
                     [])]
              [(.init code)
               (cond (b/is-glbl result-var)
                     ""
                     ["Value *" result-var ";"])
               "if (1) {List *l = empty_list;" line-sep
               (map (reverse arg-codes)
                    (fn [arg-code]
                      ["l = listCons(" (.var arg-code) ", l);"
                       line-sep]))
               result-var " = (Value *)l;}" line-sep]
              (.refs-map code)))))

(extend-type c/TaggedSymbol
  CodeGen
  (gen-call [tgt args mod result-var]
    (cond (= tgt 'vector)
          (call-vector tgt args mod result-var)

          (= tgt 'list)
          (call-list tgt args mod result-var)

          (generic-call tgt args mod result-var)))

  (gen-code [x mod]
    (-> empty-c-code
        (.refs-map (cond (b/is-glbl (.var x))
                         {}
                         {(.var x) 1}))
        (.var (.var x))
        se/state-error)))

(extend-type ast/inline-ast
  CodeGen
  (gen-code [x mod]
    (cond (= (.var x) "")
          (se/state-error (.init empty-c-code [(.txt x)]))

          (se/state-error (.decl empty-c-code ["Value *" (.var x) " = " (.txt x) ";"]))))

  (gen-code [x mod arity]
    (gen-code x mod)))

(defn destruct-seq [p]
  (assert (instance? (any-of ast/ParamType c/NoSymbol) p))
  (assert-result r (instance? Vector r))

  (cond (or (= p c/no-symbol)
            (instance? c/TaggedSymbol p))
        []

        (and (instance? ast/params-ast p)
             (empty? (.fixed p))
             (instance? c/TaggedSymbol (.variadic p)))
        [(C-init (.var (.variadic p))
                 []
                 ["Value *" (.var (.variadic p)) " = " (.var p) ";"]
                 {(.var p) 1})]

        (let [elem-count (inc (count (.fixed p)))
              loc (ast/location p)]
          (comp [(-> empty-c-code
                     (.init [(map (.fixed p) (fn [inner]
                                               ["Value *" (.var inner) ";"]))
                             (cond (= c/no-symbol (.variadic p))
                                   ""
                                   ["Value *" (.var (.variadic p)) ";"])
                             "if (1) {Value **destArgs [" elem-count "] = {"
                             (map (.fixed p) (fn [inner]
                                               ["&" (.var inner) ", "]))
                             (cond (= c/no-symbol (.variadic p))
                                   "(Value **)0"
                                   ["&" (.var (.variadic p))])
                             "};" "destructValue(\"" (.file loc) "\", \"" (.line loc)
                             "\", (Value *)" (.var p) ", " elem-count ", destArgs);}"])
                     (.refs-map {(.var p) 1}))]
                (map (.fixed p) (fn [sym]
                                  (C-init (.var sym) [] [] {})))
                (cond (= c/no-symbol (.variadic p))
                      []
                      [(C-init (.var (.variadic p)) [] [] {})])
                (flat-map (.fixed p) destruct-seq)
                (destruct-seq (.variadic p))))))

(defn checking-fn [params c-fn]
  (assert (instance? ast/params-ast params))
  (let [loc (ast/location params)
        checking-fn-var (b/global-var "checkerFn")]
    (cond (instance? c/TaggedSymbol (.variadic params))
          (do
            ;; (c-code checking-fn-var
            ;;         ["Value *" checking-fn-var
            ;;          "(FnArity *arity, Value *args) {\n"
            ;;          line
            ;;          "int " checked-var "= 1;"
            ;;          (-> constraints
            ;;              (c/update-var "args")
            ;;              ;; TODO: what if runtime-check is empty?
            ;;              (runtime-check c/top-type file-name line-number checked-var))
            ;;          "if(!" checked-var "){abort();}" line-sep
            ;;          "return(" c-fn
            ;;          "(arity, args));\n};\n"]
            ;;         {} c/top-type)
            (.var empty-c-code c-fn)
            )

          (.var empty-c-code c-fn)

          ;; (c-code checking-fn-var
          ;;         ["Value *" checking-fn-var "("
          ;;          (-> param-vars
          ;;              (map (fn [param] (str "Value *" param)))
          ;;              (seq)
          ;;              (conj "FnArity *arity")
          ;;              (interpose ", "))
          ;;          ") {\n"
          ;;          line
          ;;          "int " checked-var "= 1;"
          ;;          (for [[constraint var] (zip-lists constraints-list
          ;;                                            param-vars)]
          ;;            ;; TODO: what if runtime-check is empty?
          ;;            (-> constraint
          ;;                (c/update-var var)
          ;;                (runtime-check c/top-type file-name line-number checked-var)))
          ;;          "if(!" checked-var "){abort();}" line-sep
          ;;          "return(" c-fn "("
          ;;          (-> param-vars
          ;;              (seq)
          ;;              (conj "arity")
          ;;              (interpose ", "))
          ;;          "));\n};\n"]
          ;;         {} c/top-type)
          )))

(extend-type ast/do-ast
  CodeGen
  (gen-code [ast mod]
    (map (se/traverse (.body ast) (fn [expr]
                                    (gen-code expr mod ast)))
         comp-code)))

(extend-type ast/fn-arity-ast
  CodeGen
  (gen-code [ast mod]
    (cond (empty? (.body ast))
          (b/compilation-error "Invalid function body at:" (ast/location ast))

          (map (se/traverse (.body ast) (fn [expr]
                                          (gen-code expr mod ast)))
               (fn [body-exprs]
                 (let [params (.params ast)
                       body-exprs (comp (cond (= (.variadic params) c/no-symbol)
                                              (flat-map (.fixed params) destruct-seq)

                                              (destruct-seq params))
                                        body-exprs)
                       code (either (for [last-ast (last (.body ast))
                                          :when (instance? ast/inline-ast last-ast)
                                          last-expr (last body-exprs)]
                                      (.refs-map last-expr
                                                 (reduce (ast/all-syms params) {}
                                                         (fn [rm s]
                                                           (assoc rm (.var s) 1)))))

                                    (comp-code body-exprs))]
                   ;; (b/status 'body _LINE_ (ast/location ast) 'params (ast/all-syms params)
                   ;;           lf (str "[" (-> body-exprs
                   ;;                           (map (fn [code]
                   ;;                                  [(type-name code)
                   ;;                                   (.var code)
                   ;;                                   (.refs-map code)]))
                   ;;                           (interpose (str lf "  "))
                   ;;                           to-str) "]"))
                   ;; TODO: handle recursion properly
                   (-> code
                       (.decl [(.decl code)])
                       (.init [(.init code)
                               (either (= "" (.var code))
                                       ["return " (.var code) ";"])
                               "};};\n"]))))))))

(extend-type b/StaticArity
  CodeGen
  (gen-code [ast mod]
    (let [c-fn (.c-fn ast)
          params (-> ast .arity .params)
          checker (checking-fn (-> ast .arity .params) c-fn)]
      (for [arity-code (gen-code (.arity ast) mod)]
        (-> empty-c-code
            (.var (.fn-var (.arity ast)))
            (.decl [(.decl arity-code)
                    "Value *" c-fn "(FnArity *arity"
                    (cond (= (.variadic params) c/no-symbol)
                          (reduce (.fixed params) []
                                  (fn [args arg]
                                    (conj args (str ", Value *" (.var arg)))))

                          [", Value *" (.var params)])
                    ") {\nwhile (1) {"
                    (.init arity-code)
                    (.decl checker)
                    "FnArity " (.fn-var (.arity ast)) " = {FnArityType, REFS_STATIC, "
                    (count params)
                    ", (Vector *)0, "
                    (cond (= (-> ast .arity .params .variadic)
                             c/no-symbol)
                          ;; fixed arity
                          0

                          ;; variadic arity
                          1)
                    ", " (.var checker) "};"]))))))

(extend-type b/ClosureArity
  CodeGen
  (gen-code [ast mod]
    (let [c-fn (b/global-var b/CFn)
          arity-var (.fn-var (.arity ast))
          params (-> ast .arity .params)
          [closed-over closure-vars] (reduce (vec (.closures ast)) [[] []]
                                             (fn [[closed-over closure-vars] [k v]]
                                               [(conj closed-over k) (conj closure-vars v)]))]
      (for [arity-code (gen-code (.arity ast) mod)]
        (-> empty-c-code
            (.var arity-var)
            (.decl [(.decl arity-code)
                    "Value *" c-fn "(FnArity *arity"
                    (cond (= (.variadic params) c/no-symbol)
                          (reduce (.fixed params) []
                                  (fn [args arg]
                                    (conj args (str ", Value *" (.var arg)))))

                          [", Value *" (.var params)])
                    ") {\nwhile (1) {"

                    ;; TODO: put in when runtime checking works
                    ;; "if(1){int " checked-var " = 1;" line-sep
                    ;; check-params
                    ;; "if(!" checked-var "){abort();}}" line-sep

                    "incRef((Value *)arity->closures, 1);"
                    (-> (ast/params closure-vars)
                        (.var "arity->closures")
                        destruct-seq
                        comp-code
                        .init)

                    (.init arity-code)])
            (.init ["FnArity *" arity-var
                    " = malloc_fnArity();"
                    arity-var "->count = " (count params) ";"
                    arity-var "->variadic = "
                    (cond (= (-> ast .arity .params .variadic)
                             c/no-symbol)
                          "1"
                          "0")
                    ";"
                    arity-var "->fn = " c-fn ";"
                    arity-var "->closures = empty_vect;"
                    (map closed-over (fn [closure]
                                       [arity-var "->closures = mutateVectConj("
                                        arity-var "->closures, (Value *)" (.var closure) ");"]))])
            (.refs-map (reduce closed-over {}
                               (fn [rm closure]
                                 (assoc rm (.var closure) 1)))))))))

(def StaticOrProto (any-of b/StaticArity
                           ast/prototype-ast))

(extend-type ast/fn-ast
  CodeGen
  (gen-code [ast mod]
    (let [fn-sym (.fn-sym ast)
          fn-var (.var ast)
          arities (.arities ast)]
      ;; TODO: what if fn-sym is c/no-symbol
      (cond (every arities (fn [arity]
                             (instance? StaticOrProto arity)))
            (for [code-vect (se/traverse arities (fn [arity]
                                                   (gen-code arity mod)))]
              (let [struct-var (.struct-var ast)]
                (-> empty-c-code
                    (.var fn-var)
                    (.decl [(map code-vect .decl)
                            "\n// --------- " fn-sym " -------------\n"
                            ;; "Value *" fn-var ";" line-sep
                            "Function " struct-var " = {FunctionType, REFS_STATIC, \""
                            fn-sym "\", " (count arities) ", "
                            "{" (-> code-vect
                                    (map (fn [code]
                                           (str "&" (.var code))))
                                    (interpose ", "))
                            "}};\n"
                            "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]))))

            (for [code-vect (se/traverse arities (fn [arity]
                                                   (gen-code arity mod)))]
              (let [arity-count (count arities)]
                (-> empty-c-code
                    (.var fn-var)
                    (.decl (map code-vect .decl))
                    (.init [(map code-vect .init)
                            "Function *" (.struct-var ast) " = malloc_function(" arity-count ");"
                            "Value *" fn-var " = (Value *)" (.struct-var ast) ";"
                            (.struct-var ast) "->name = \"" fn-sym "\";"
                            (.struct-var ast) "->arityCount = " arity-count ";"
                            (map (zip-lists (map code-vect .var)
                                            (range arity-count))
                                 (fn [[sym index]]
                                   [sym "->parent = " fn-var ";"
                                    (.struct-var ast) "->arities[" index "] = " sym ";"]))])
                    (.refs-map (merge-maps + (map code-vect .refs-map))))))))))

(extend-type ast/definition-ast
  CodeGen
  (gen-code [ast mod]
    (let [[expr] (.value-exprs ast)]
      (for [code (gen-code expr mod)
            _ (se/update-val .init (fn [glbl-init]
                                     (let [add-global (either (= (.var code) "")
                                                              [(.var code) "->refs = refsConstant;"
                                                               "globals = listCons("
                                                               (.var code) ", globals);\n"])]
                                       (conj glbl-init
                                             (either (empty? (.init code))
                                                     [(map (vec (.refs-map code))
                                                           (fn [[var refs]]
                                                             (cond (or (b/is-glbl var)
                                                                       (< refs 1))
                                                                   []
                                                                   ["incRef(" var ", " refs ");"])))
                                                      (.init code)
                                                      add-global])))))]
        (-> code
            (.decl (cond (empty? (.init code))
                         ["// " (str (ast/location ast) "\n")
                          (.decl code)]
                         (cond (= (.var code) "")
                               (.decl code)
                               ["Value *" (.var code) ";"
                                (.decl code)])))
            (.init []))))))

(extend-type ast/integer-ast
  CodeGen
  (gen-code [ast mod]
    (let [num (.int ast)
          num-ptr (.var ast)]
      (comp (se/get-in-val [.constants .numbers num])
            (for [const-nums (se/get-in-val [.constants .numbers])
                  :let [num-idx (count const-nums)
                        num-sym (str "num" num-idx)]
                  _ (se/assoc-in-val [.constants .numbers num]
                                     (.var empty-c-code num-ptr))]
              (-> empty-c-code
                  (.decl ["Integer " num-sym " = {IntegerType, REFS_STATIC, " num "};\n"
                          "Value *" num-ptr " = (Value *)&" num-sym ";\n"])
                  (.var num-ptr)))))))

(extend-type ast/string-ast
  CodeGen
  (gen-code [ast mod]
    (let [str-val (.string ast)
          str-len (count str-val)
          str-ptr (.var ast)]
      (comp (se/get-in-val [.constants .strings str-val])
            (for [const-strs (se/get-in-val [.constants .strings])
                  :let [str-idx (count const-strs)
                        str-sym (str "str" str-idx)]
                  _ (se/assoc-in-val [.constants .strings str-val]
                                     (.var empty-c-code str-ptr))]
              (-> empty-c-code
                  (.decl ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        Integer *hash;
        int64_t len;
        char buffer["
                          (inc str-len)
                          "];\n} " str-sym " = {StringBufferType, REFS_STATIC, 0, "
                          str-len ", \"" (escape-chars str-val) "\"};\n"
                          "Value *" str-ptr " = (Value *)&" str-sym ";\n"])
                  (.var str-ptr)))))))

(extend-type ast/call-ast
  CodeGen
  (gen-code [ast mod]
    (gen-call (.call-target ast) (.args ast) mod (.var ast))))

(extend-type ast/binding-ast
  CodeGen
  (gen-code [ast mod]
    (for [val-code (gen-code (.val ast) mod)
          cont-codes (se/traverse (.cont ast) (fn [expr]
                                                (gen-code expr mod)))]
      (let [cont-codes (comp [val-code (C-init (.var (.binding ast))
                                               []
                                               ["Value *" (.var (.binding ast)) " = "
                                                (.var (.val ast)) ";"]
                                               {(.var (.val ast)) 1})]
                             (destruct-seq (.binding ast))
                             cont-codes)
            [last-code cont-codes] (either (map (last cont-codes)
                                                (fn [last-code]
                                                  (cond (b/is-glbl (.var ast))
                                                        [(-> last-code
                                                             (.var (.var ast))
                                                             (.decl [(.decl last-code)
                                                                     "Value *" (.var ast) ";"])
                                                             (.init [(.init last-code)
                                                                     (.var ast) " = "
                                                                     (.var last-code) ";"]))
                                                         (butlast cont-codes)]

                                                        (= (.var last-code) (.var ast))
                                                        [last-code (butlast cont-codes)]

                                                        (do
                                                          (b/status 'compiler-error
                                                                    (c/Location _FILE_ _LINE_)
                                                                    lf 'for-ast-ast (ast/location ast)
                                                                    lf (str "'" (.var last-code) "' '"
                                                                            (.var ast) "'"))
                                                          (b/wait-for-err-out)
                                                          (abort)))))
                                           [empty-c-code empty-vector])
            code (reduce (reverse cont-codes) last-code
                         (fn [final-code expr-code]
                           (cond (= final-code empty-c-code)
                                 expr-code
                                 (comp-code expr-code final-code))))]
        ;; (b/status 'binding _LINE_ 'val (ast/location ast) (.var ast)
        ;;           ;; lf 'val (type-name val-code) (.var val-code) (.refs-map val-code)
        ;;           lf 'cont lf (str "[" (to-str (-> cont-codes
        ;;                                         (map (fn [code]
        ;;                                                [(type-name code)
        ;;                                                 (.var code)
        ;;                                                 (.refs-map code)
        ;;                                                 (count (.init code))]))
        ;;                                         (interpose (str lf "  ")))) "]")
        ;;           lf 'code (type-name code) (.var code) (.refs-map code))
        (make-init code)))))

(extend-type ast/protocol-ast
  CodeGen
  (gen-code [ast mod]
    (let [unique-protos (reduce (.prototypes ast) {}
                                (fn [m proto-ast]
                                  (assoc m (.fn-name proto-ast) proto-ast)))]
      (-> empty-c-code
          (.decl [(map (.prototypes ast)
                       (fn [proto-ast]
                         ["Value *" (.var proto-ast) "(FnArity *"
                          (map (.fixed (.params proto-ast))
                               (fn [_]
                                 ", Value *"))
                          ");" line-sep]))
                  (map (keys unique-protos)
                       (fn [sym]
                         (either (map (get-in mod [.namespaces c/no-symbol .values 0 sym .var])
                                      (fn [var]
                                        ["Value *" var ";" line-sep]))
                                 "")))])
          se/state-error))))

(extend-type ast/block-comment-ast
  CodeGen
  (gen-code [ast mod]
    (se/state-error empty-c-code)))

(defn default-fn [val c-fn]
  (assert (instance? ast/prototype-ast val))

  (let [default-body (.default-body val)
        arity-var (b/global-var b/Arity)]
    (b/StaticArity (ast/fn-arity-ast
                    (.fn-name val) arity-var (.params val) (.doc val)
                    (cond (empty? default-body)
                          [(ast/inline-ast c/top-type (str "
   fprintf(stderr, \"*** Could not find implementation of '" (.fn-name val)
"' for *finish this error message*\\n\");
   abort();
   return ((Value *)0);
")
                                           (ast/location (.params val))
                                           "")]

                          default-body)
                    c/top-type)
                   c-fn)))

(defn dispatcher-fn [proto impl-codes def-c-fn]
  (assert (instance? ast/prototype-ast proto))

  (let [params (.params proto)
        disp-arg (either (map (first (.fixed params)) .var)
                         "arg0")
        arg-count (count params)
        arity (b/global-var b/Arity)]
    (-> empty-c-code
        (.var arity)
        (.decl ["Value *" (.var proto) "(FnArity *locStr"
                (map (.fixed params)
                     (fn [param]
                       (str ", Value *" (.var param))))
                ") {\nFnArity *arity;\n#\n"
                "FnType" arg-count " *_fn;\n"
                "switch (" disp-arg "->type) {\n"
                ;; (-> impl-codes
                ;;     vec
                ;;     (map (fn [[type-num code]]
                ;;            ["case " (str type-num) ": arity = "
                ;;             (.var code) ";\n_fn = (FnType"
                ;;             arg-count " *)" (.c-fn arity-info) ";\n"
                ;;             (for [[constraint var] (-> (.param-constraints arity-info)
                ;;                                        (c/extract-items-constraints arg-count)
                ;;                                        (zip-lists (map (range arg-count)
                ;;                                                        (partial str "arg")))
                ;;                                        rest)]
                ;;               (-> constraint
                ;;                   (c/update-var var)
                ;;                   (runtime-check c/top-type
                ;;                                  (str "(closures == (FnArity *)0 ? \"\" : "
                ;;                                       "((String *)closures)->buffer)")
                ;;                                  checked-var)))
                ;;             "\nclosures = arity;\nbreak;\n"])))
                "default:\n"
                "_fn = (FnType" arg-count
                " *)" def-c-fn ";\nbreak;\n"
                "}\n"
                "return(_fn(locStr" (map (.fixed params)
                                         (fn [param]
                                           (str ", " (.var param))))
                "));\n}\n"
                "FnArity " arity " = {FnArityType, REFS_STATIC, " arg-count
                ", (Vector *)0, 0, " (.var proto) "};\n"]))))

(extend-type ast/or-ast
  CodeGen
  (gen-code [ast mod]
    (let [loc (ast/location (.clause ast))]
      (for [clause-code (gen-code (.clause ast) mod)
            cont-code (gen-code (.cont ast) mod)]
        (let [cont-refs (dissoc (.refs-map cont-code) (.var cont-code))]
          (C-init (.var ast)
                  (comp (.decl clause-code) (.decl cont-code))
                  [(.init clause-code)
                   "Value *" (.var ast) "; if (!isNothing(" (.var clause-code) ")) {"
                   (map (vec cont-refs)
                        (fn [[var refs]]
                          [" dec_and_free(" var ", " refs "); "]))
                   (.var ast) " = " (.var clause-code)
                   "; } else { dec_and_free(" (.var clause-code) ", 1); " 
                   (.init cont-code) (.var ast) " = " (.var cont-code) ";}"]
                  (merge-with + (.refs-map clause-code)
                              cont-refs)))))))

(extend-type ast/and-ast
  CodeGen
  (gen-code [ast mod]
    (let [loc (ast/location (.clause ast))]
      (for [clause-code (gen-code (.clause ast) mod)
            cont-code (gen-code (.cont ast) mod)]
        (let [cont-refs (dissoc (.refs-map cont-code) (.var cont-code))
              refs-map (merge-with + (.refs-map clause-code)
                                   cont-refs)
              ;; _ (b/status 'and _LINE_ (ast/location ast) 'clause (.refs-map clause-code)
              ;;             lf 'cont (.refs-map cont-code)
              ;;             lf 'refs-map refs-map)
              ]
          (C-init (.var ast)
                  (comp (.decl clause-code) (.decl cont-code))
                  [(.init clause-code)
                   "Value *" (.var ast) "; if (isNothing(" (.var clause-code) ")) {"
                   (map (vec cont-refs)
                        (fn [[var refs]]
                          [" dec_and_free(" var ", " refs "); "]))
                   (.var ast) " = nothing; } else { dec_and_free(" (.var clause-code) ", 1); " 
                   (.init cont-code) (.var ast) " = " (.var cont-code) ";}"]
                  refs-map))))))

(extend-type ast/prototype-ast
  CodeGen
  (gen-code [ast mod]
    (let [def-c-fn (b/global-var b/CFn)]
      (for [def-code (gen-code (default-fn ast def-c-fn) mod)
            impl-codes (se/traverse (vec (.impls ast))
                                    (fn [[type-num arity]]
                                      (map (gen-code arity mod)
                                           (fn [code]
                                             [type-num (.var code (.c-fn arity))]))))]
        (let [disp-code (dispatcher-fn ast impl-codes def-c-fn)]
          (-> impl-codes
              (conj def-code)
              (conj disp-code)
              collapse-codes
              (.var (.var disp-code))))))))

(defn emit-protos [code-context]
  (let [mod-prom (promise)]
    (send b/modules (fn [mods]
                      (deliver mod-prom mods)
                      mods))
    (for [[_ mod] (vec (extract mod-prom))
          [sym val] (either (map (get-in mod [.namespaces c/no-symbol .values 0])
                                 vec)
                            [])
          :when (instance? c/ProtoImpls (.constraint val))]
      ((se/try
         (map (gen-code val mod)
              (fn [code]
                (code-out (.decl code))))
         (fn [err]
           (b/status (.val err))
           (b/wait-for-err-out)
           (abort)))
       code-context))))

(defn emit-main [code-context done-promise main-module]
  (let [main-fn (either (get-in main-module [.namespaces c/no-symbol .values 0
                                             ast/main .arities 0 .c-fn])
                        (do
                          (b/status "'main' function is missing or malformed")
                          ;; TODO: make sure to abort
                          ;; (abort)
                          ))]
    (emit-protos code-context)
    (code-out "\n#\n"
              "\nint main (int argc, char **argv) {\n"
              "prErrSTAR = &defaultPrErrSTAR;\n"
              "#ifdef SINGLE_THREADED\n"
              "#ifdef CHECK_MEM_LEAK\n"
              "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
              "at same time.\");\n "
              "abort();\n"
              "#endif\n"
              "#endif\n"
              "maybeNothing = maybe( (FnArity *)0, (Value *)0, nothing);\n"
              "maybeNothing->refs = -1;\n"
              "outstream = stdout;\n"
              "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
              "futuresQueue.output = empty_list;\n"
              "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
              "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
              "pthread_mutex_init(&shutDown.access, NULL);\n"
              "startWorkers();\n"
              (.init code-context)
              "\n#\n"
              "  Vector *argVect = empty_vect;\n"
              "  for(int i = 0; i < argc; i++) {\n"
              "    argVect = mutateVectConj(argVect, stringValue(argv[i]));\n"
              "  }\n"
              "  argVect->refs = -1;\n"

              "Value *the_final_answer = " main-fn
              "((FnArity *)0, (Value *)argVect);\n\n"

              "#ifdef CHECK_MEM_LEAK\n"
              "cleaningUp = 1;\n"
              "mainThreadDone = 1;\n"
              "waitForWorkers();\n"
              "\n#\n"
              ;; TODO: change to argVect
              ;; "for(List *l = argVect; l != (List *)0; l = l->tail) {\n"
              ;; "   l->refs = 1;\n"
              ;; "}\n"
              ;; TODO: casting argVect to List * is a temp hack
              "  cleanupMemory(the_final_answer, maybeNothing, (List *)argVect);\n"
              "  if (malloc_count - free_count != 0)\n"
              "    return(1);\n"
              "#endif"
              "\n#\n"
              "  return(0);\n};\n"
              "\nint typeCount = " (extract b/type-counter) ";\n")
    (deliver done-promise 'done)
    code-context))

(def core-dispatchers (-> [(c/tag 'type-name) 1 "type_name"
                           (c/tag 'zero) 1 "zero"
                           (c/tag 'invoke) 1 "invoke0Args"
                           (c/tag 'invoke) 2 "invoke1Arg"
                           (c/tag 'invoke) 3 "invoke2Args"
                           (c/tag '=*) 2 "equalSTAR"
                           (c/tag 'hash-seq) 2 "hashSeq"
                           (c/tag 'count) 1 "count"
                           (c/tag 'vals) 1 "vals"
                           (c/tag 'first) 1 "first"
                           (c/tag 'rest) 1 "rest"
                           (c/tag 'seq) 1 "seq"
                           (c/tag 'sha1) 1 "sha1"
                           (c/tag 'has-field) 2 "hasField"
                           (c/tag 'show) 1 "showFn"
                           (c/tag 'new-hash-set) 1 "newHashSet"
                           (c/tag 'apply) 2 "fn_apply"
                           (c/tag 'pr-value) 1 "prValue"]
                          (partition 3)))

(defn fixup-core-dispatchers [code-context core-mod]
  (map core-dispatchers
       (fn [[sym arg-count var]]
         (let [arity-var (either (get-in core-mod [.namespaces c/no-symbol .values 0
                                                   sym .arities 0 .var])
                                 ;; TODO: abort with message instead
                                 (str "noImpl" arg-count))]
           (code-out "Value *(*" var ")(FnArity *, "
                     (-> (repeat arg-count "Value *")
                         (interpose ","))
                     ") = " arity-var ";\n"))))
  code-context)
