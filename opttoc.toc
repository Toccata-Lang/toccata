
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "33cbe78"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "9750c7e"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))

(defn hylo-env [descend ascend env x]
  (let [[y new-env] (descend x env)]
    (ascend (map y (fn [inner-x]
                     (hylo-env descend ascend new-env inner-x)))
            new-env)))

(defprotocol Evaluation
  ;; Term.reduce Line 430
  (redex [expr])

  ;; Term.normal.go Line 467
  (strong-norm [expr])

  ;; Term.rule.app Line 222
  (do-app [expr app-expr]
    ;; (.call-target app-expr expr)
    )

  (do-dup [expr dup-expr]
    ;; (.expr dup-expr expr)
    )

  ;; (head [expr])

  ;; (strict [expr])

  ;; (lazy-redex [expr]
  ;;   ;; expr
  ;;   )

  ;; (pre-eval [ast env]
  ;;   [ast env])

  ;; (eval [ast env]
  ;;   ;; (print-err 'ast _LINE_ ast
  ;;   ;;            "\n\n" 'env env)
  ;;   )

  ;; (eval-bind [val binding env]
  ;;   (print-err 'binding-val _LINE_ (type-name val) val)
  ;;   (abort))

  ;; (eval-app [f call env]
  ;;   (.call-target call f))
  )

;; (defn eval-expr [expr defs]
;;   (let [new-expr (hylo-env pre-eval eval defs expr)]
;;     (either (= new-expr expr)
;;             (eval-expr new-expr defs))))

(defn lazy [expr]
  ;; (print-err 'expr _LINE_ expr)
  ;; (println "subgraph" (gensym "cluster") "{")
  ;; (println "graph [color=none, label=\"I\"]")
  ;; (println (gensym "i") "[label=\"\"]")
  ;; (println "}")
  ;; (println (gensym "sg") "[color=none, label=\"I\"]")
  (let [new-expr (strong-norm (redex expr))]
    (either (or (instance? Fn new-expr)
                (= new-expr expr))
            (lazy new-expr))))

(extend-type Symbol
  Evaluation
  (redex [s]
    (print-err 'interp-err _LINE_ s)
    (abort)))

(deftype Self []
  Stringable
  (string-list [_]
    (list "self")))

(def self (Self))

(defprotocol DotOut
  (grph-down [expr]
    (assert-result r (instance? se/StateError r))
    (se/state-error expr))

  (grph-up [expr]
    (assert-result r (instance? se/StateError r))))

(defn grph
  ([expr] (grph expr {}))
  ([expr env]
   ((hylo grph-down grph-up expr se/state-error) (list env))
   expr))

(defn get-val [k]
  (se/get-in-val [0 k]))

(defn dissoc-val [k]
  (se/update-state (fn [st]
                     (cons (either (map (first st) (fn [m]
                                                     (dissoc m k)))
                                   {})
                           (rest st)))))

(defn set-val [k v]
  (map (se/update-state (fn [st]
                          (cons (either (map (first st) (fn [m]
                                                          (assoc m k v)))
                                        {k v})
                                (rest st))))
       (fn [_]
         v)))

(defn fresh-vars [vs]
  (fn [expr]
    (reify
      Container
      (map [_ f embed]
        (f expr))

      DotOut
      (grph-down [this]
        (map (se/traverse vs
                          (fn [s]
                            (let [node-id (gensym (str s))]
                              (println node-id (str "[label=\"" s "\"]"))
                              (set-val s node-id))))
             (fn [_]
               this))))))

(defn push-env []
  (se/update-state (fn [st]
                     (cons (either (first st)
                                   {})
                           st))))

(defn pop-env []
  (se/update-state rest))

(defn nip-env [vs]
  (se/update-state (fn [[fst snd & tail]]
                     (-> (reduce vs fst dissoc)
                         (comp (select-keys snd vs))
                         (cons tail)))))

(def CoreType (any-of Integer Fn Vector))

(defn replace [expr new-exprs]
  (print-err 'replacing _LINE_ (type-name expr) expr
             "\n\n" 'env new-exprs) 
  (hylo-env (fn [v env]
              (cond (instance? ast/fn-arity-ast v)
                    [v (dissoc-all env (ast/all-syms (.params v)))]

                    (instance? ast/binding-ast v)
                    (let [new-expr (replace (.expr v) env)
                          new-env (dissoc env (.id v))]
                      (print-err 'new-expr _LINE_ new-expr
                                 "\n\n" 'new-env new-env)
                      [(.expr v new-expr) new-env])

                    ;; (instance? ast/tagged-symbol v)
                    ;; (either (get env v)
                    ;;         [v env])

                    (or (instance? ast/integer-ast v)
                        (instance? ast/fn-ast v)
                        (instance? ast/call-ast v)
                        (instance? CoreType v))
                    [v env]

                    (do
                      (print-err 'replacing _LINE_ (type-name v) v
                                 "\n\n" 'env env)
                      [v env])))
            (fn [v env]
              (cond nothing
                    (abort)
                    
                    ;; (instance? ast/call-ast v)
                    ;; (do-app (.call-target v) v)

                    ;; (instance? ast/binding-ast v)
                    ;; (do-dup (.expr v) v)

                    (or (instance? ast/integer-ast v)
                        (instance? ast/fn-ast v)
                        (instance? ast/fn-arity-ast v)
                        (instance? ast/tagged-symbol v)
                        (instance? ast/call-ast v)
                        (instance? CoreType v))
                    v

                    (do
                      (print-err 'replaced _LINE_ (type-name v) v)
                      v))
              )
            new-exprs expr))

(extend-type ast/tagged-symbol
  Evaluation
  ;; Equivalent to line 431
  ;; except we're not doing this in a monad, so a symbol will only be replaced
  ;; in calls to 'replace' or 'ast/simple-replace'
  (redex [ast]
    ast)
  
  ;; Line 468
  (strong-norm [ast]
    ast)

  ;; Line 255
  (do-app [ast app-expr]
    (.call-target app-expr ast))

  ;; (strict [s]
  ;;   s)

  ;; (do-dup [s dup-expr]
  ;;   (.expr dup-expr s))

  ;; (lazy-redex [s]
  ;;   s)

  ;; (head [expr]
  ;;   (RecurseFinal expr))

  ;; (eval-bind [s binding env]
  ;;   (.expr binding s))

  ;; (eval [s env]
  ;;   (either (get env s)
  ;;           s))

  DotOut
  (grph-up [s]
    (se/state-error s)))

(extend-type ast/integer-ast
  Evaluation
  (redex [ast]
    (.int ast))

  ;; (do-app [ast call]
  ;;   (print-err 'wth _LINE_ ast
  ;;              "\n\n" 'call call)
  ;;   (abort))

  ;; (head [n]
  ;;   (RecurseFinal (.int n)))

  ;; (lazy-redex [n]
  ;;   (.int n))

  ;; (strong-norm [n]
  ;;   (.int n))

  ;; (eval [n env]
  ;;   (.int n))

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str (.int n)) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type Fn
  Container
  (map [f _]
    f)
  (map [f _ embed]
    (embed f))

  ;; Hashable
  ;; (sha1-update [f ctxt]
  ;;   (sha1-update-type (address-of f) ctxt))

  Evaluation
  ;; Line 434
  (redex [expr]
    expr)

  ;; Line 228
  (do-app [f app-expr]
    ;; a Fn can only be applied to CoreType values, so the args
    ;; have to be completely reduced with no free variables
    ;; 'grpbh' is the exception as it can be applied to ast's as well.
    (let [new-args (map (.args app-expr) lazy)]
      (cond (or (identical f grph)
                (every new-args (partial instance? CoreType)))
            (apply f new-args)

            (ast/call-ast f new-args))))

  (strong-norm [f]
    f)

  ;; (head [f]
  ;;   (RecurseFinal f))

  ;; (lazy-redex [f]
  ;;   f)

  ;; (do-dup [f dup-expr]
  ;;   (either (last (replace (.cont dup-expr) {(.id dup-expr) f}))
  ;;           (do
  ;;             (print-err 'interp-error _LINE_ f
  ;;                        "\n\n" 'dup dup-expr)
  ;;             (abort))))

  ;; (strict [f]
  ;;   f)

  ;; (eval-app [f app-expr env]
  ;;   (let [new-args (map (.args app-expr) (fn [arg]
  ;;                                          (hylo-env pre-eval eval env arg)))]
  ;;     (cond (or (= f grph)
  ;;               (every new-args (partial instance? CoreType)))
  ;;           (apply f new-args)

  ;;           (ast/call-ast f new-args))))

  ;; (eval-bind [f binding env]
  ;;   (either (last (ast/simple-replace (.cont binding) {(.id binding) f}))
  ;;           (do
  ;;             (print-err 'compiler-error _FILE_ _LINE_)
  ;;             (abort))))

  ;; (eval [f _]
  ;;   f)

  DotOut
  (grph-up [expr]
    (let [node-id (gensym "fn")
          x-end (str node-id ":sw")
          y-end (str node-id ":se")]
      (println node-id (str "[label=\"" (fn-name expr) "\", ordering=out]"))
      (se/state-error (str node-id ":n")))))

(extend-type Integer
  Container
  (map [n _] n)
  (map [n _ embed]
    (embed n))

  Evaluation
  (redex [n]
    n)

  (strong-norm [n]
    n)
  
  ;; (do-app [ast call]
  ;;   (print-err 'wth _LINE_ ast
  ;;              "\n\n" 'call call)
  ;;   (abort))

  ;; (strong-norm [n]
  ;;   n)

  ;; (lazy-redex [n]
  ;;   n)

  ;; (head [n]
  ;;   (RecurseFinal n))

  ;; (strict [n]
  ;;   n)

  ;; (eval [n _]
  ;;   n)

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str n) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type Vector
  ;; Evaluation
  ;; (eval [ast env]
  ;;   ast)

  ;; (do-app [v call]
  ;;   (print-err 'wut _LINE_ v)
  ;;   (abort)
  ;;   call)

  ;; (head [v]
  ;;   (RecurseWith v))

  ;; (lazy-redex [v]
  ;;   (map v lazy-redex))

  DotOut
  (grph-up [v]
    (se/state-error v)))

;; (extend-type c/NoSymbol
;;   Evaluation
;;   (eval [x _]
;;     x))

(deftype Skip [expr]
  Stringable
  (string-list [_]
    (list "(Skip " (str expr) ")"))

  Container
  (map [e f]
    expr)

  (map [e f embed]
    (embed expr)))

(defn church [n]
  (let [fn-sym (ast/tag (symbol (str n)))
        param-x (ast/tag (gensym "px"))
        x (ast/tag (gensym "x"))
        y (ast/tag (gensym "y"))
        ;; dups (-> (range (.int n))
        ;;          (map (fn [n]
        ;;                 (ast/tag (symbol (str 'a (inc n))) loc)))
        ;;          vec)
        ]
    (ast/fn-ast fn-sym
                [(ast/fn-arity-ast
                  fn-sym
                  (ast/params [param-x])
                  ast/no-comment
                  [(ast/fn-ast c/no-symbol
                               [(ast/fn-arity-ast
                                 c/no-symbol
                                 (ast/params [y])
                                 ast/no-comment
                                 [(ast/binding-ast x param-x
                                                    [(reduce (range n) y
                                                             (fn [expr _]
                                                               (ast/call-ast x [expr])))])]
                                 {param-x 1})])]
                  {})])))

(defn free-vars [expr]
  (cata (fn [v]
          (cond (instance? ast/fn-arity-ast v)
                (reduce (ast/all-syms (.params v))
                        (reduce (.body v) {} (partial merge-with +))
                        dissoc)

                (instance? ast/fn-ast v)
                (reduce (.arities v) {} (partial merge-with +))

                (instance? ast/binding-ast v)
                (-> (.cont v)
                    (reduce (.expr v) (partial merge-with +))
                    (dissoc (.id v)))

                (instance? ast/call-ast v)
                (reduce (.args v) (.call-target v) (partial merge-with +))

                (instance? ast/tagged-symbol v)
                {v 1}

                {}))
        expr))

(extend-type ast/block-comment-ast
  Evaluation
  (redex [expr]
    expr))

(extend-type ast/binding-ast
  Evaluation
  ;; Line 444
  (redex [expr]
    ;; here we deviate from .kind. If there are no free vars left in (.expr expr)
    ;; it can be substituted (and possibly duped) in cont and then cont can be
    ;; reduced
    (let [new-expr (lazy (.expr expr))]
      (cond (or (= new-expr (.id expr))
                (empty? (free-vars new-expr)))
            (let [new-cont (ast/simple-replace (.cont expr)
                                               {(.id expr) new-expr})]
              (-> new-cont
                  butlast
                  (map lazy))
              (either (map (last new-cont) redex)
                      (do
                        (print-err 'interp-err _LINE_ expr
                                   "\n\n" 'new-cont new-cont)
                        (abort))))
            (.expr expr new-expr))))

  ;; Line 485
  (strong-norm [expr]
    (-> expr
        (.expr (lazy (.expr expr)))
        (.cont (map (.cont expr) lazy))))

  ;; Line 250
  (do-app [expr app-expr]
    (let [init-cont (butlast (.cont expr))
          last-cont (either (last (.cont expr))
                            (do
                              (print-err 'interp-err _LINE_ expr
                                         "\n\n" 'app-expr app-expr)
                              (abort)))
          new-cont (comp init-cont [(.call-target app-expr last-cont)])]
      (redex (.cont expr new-cont))))

  ;; (do-dup [x dup-expr]
  ;;   (.expr dup-expr x))

  ;; (strict [dup-expr]
  ;;   (-> (.expr dup-expr)
  ;;       strict
  ;;       (do-dup dup-expr)))

  ;; (head [expr]
  ;;   (-> expr
  ;;       (.cont (RecurseFinal (.cont expr)))
  ;;       RecurseWith))

  ;; (lazy-redex [expr]
  ;;   (do-dup (.expr expr) expr))

  ;; (pre-eval [ast env]
  ;;   [(.cont ast (either (instance? ast/binding-ast (.cont ast))
  ;;                       (Skip (.cont ast))))
  ;;    (dissoc-all env (ast/all-syms (.id ast)))])

  ;; (eval-bind [expr binding env]
  ;;   (.expr binding expr))

  ;; (eval [ast env]
  ;;   ;; (print-err 'eval-binding _LINE_ ast)
  ;;   (eval-bind (.expr ast) ast env))

  DotOut
  (grph-down [expr]
    (let [node-id (gensym "bnd")
          endpoint (str node-id ":n")]
      (println node-id (str "[label=\"\",")
               "height=0.4, width=0.4, fixedsize=true, shape=triangle, orientation=180]")
      (for [_ (push-env)
            _ (set-val self node-id)
            _ (se/traverse (ast/all-syms (.id expr))
                           (fn [id]
                             (set-val id endpoint)))]
        expr)))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [arg-end (str node-id ":sw")
                new-ids (reduce (ast/all-syms (.id expr)) [self]
                                (fn [new-ids id]
                                  (cond (instance? ast/tagged-symbol id)
                                        (conj new-ids id)

                                        (comp new-ids id))))]
          _ (nip-env new-ids)
          _ (cond (instance? Sequence (.expr expr))
                  ;; (se/traverse (.expr expr)
                  ;;              (fn [v]
                  ;;                (cond (instance? String v)
                  ;;                      (se/state-error (println arg-end "--" v))

                  ;;                      (comp (map (get-val v)
                  ;;                                 (fn [endp]
                  ;;                                   (println arg-end "--" endp)))
                  ;;                            (set-val v arg-end)))))
                  (do
                    (print-err 'graphing-error _LINE_ expr)
                    (abort))

                  (instance? String (.expr expr))
                  (se/state-error (println arg-end "--" (.expr expr)))

                  (comp (map (get-val (.expr expr))
                             (fn [endp]
                               (println arg-end "--" endp)))
                        (set-val (.expr expr) arg-end)))]
      (either (last (.cont expr))
              ""))))

(extend-type ast/fn-arity-ast
  Evaluation
  ;; Line 471
  (strong-norm [expr]
    (let [new-bod (map (.body expr) lazy)]
      (.body expr new-bod)))

  ;; Line 228
  (do-app [expr app-expr]
    (let [args (.args app-expr)
          new-env (reduce (zip-lists (.fixed (.params expr)) args) {}
                          (fn [m [k v]]
                            (assoc m k v)))]
      ;; fully reduce all but the last expression for any side effects
      (-> (.body expr)
          butlast
          (map lazy))
      (either (map (last (.body expr))
                   (fn [expr]
                     (redex (ast/simple-replace expr new-env))))
              app-expr)))

  ;; (strict [expr]
  ;;   (.body expr (strict (.body expr))))

  ;; (head [expr]
  ;;   (RecurseFinal expr))

  ;; (lazy-redex [expr]
  ;;   expr)

  ;; (pre-eval [ast env]
  ;;   [ast (dissoc-all env (ast/all-syms (.params ast)))])

  ;; (eval [ast env]
  ;;   ast)

  DotOut
  (grph-down [f]
    (let [node-id (gensym "fn")]
      (println node-id (str "[label=\"Î»\"]"))
      (for [_ (push-env)
            _ (set-val self node-id)
            _ (se/traverse (ast/all-syms (.params f))
                           (fn [v]
                             (set-val v (str node-id ":sw"))))]
        f)))

  (grph-up [f]
    (for [node-id (get-val self)
          :let [body (either (last (.body f))
                             (ast/tag '_))]
          _ (cond (instance? ast/tagged-symbol body)
                  (comp (for [body-node (get-val body)]
                          (println (str node-id ":s") "--" body-node))

                        ;; (set-val body (str node-id ":s"))
                        (se/state-error '_))
                  (se/state-error (println (str node-id ":s") "--" body)))
          _ (pop-env)]
      (str node-id ":n"))))

(extend-type ast/fn-ast
  Evaluation
  ;; Line 434
  (redex [expr]
    expr)
  
  (strong-norm [ast]
    ;; must apply strong-norm to each of the arities
    (.arities ast (map (.arities ast) strong-norm)))

  (do-app [tgt call]
    ;; find the correct arity and call do-app on it
    (let [args (.args call)
          arg-count (count args)]
      (either (map (some (.arities tgt)
                          (fn [arity]
                            ;; TODO: variadic will be handled here
                            (and (= (count (.params arity)) arg-count)
                                 (maybe arity))))
                   (fn [arity]
                     (do-app arity call)))
              (do
                (print-err 'no-arity-found (ast/location call) arg-count
                           "\n\n" tgt)
                (.call-target call tgt)))))

  ;; (head [ast]
  ;;   (RecurseFinal ast))

  ;; ;; Dup - Lam interaction
  ;; (do-dup [expr dup-expr]
  ;;   ;; duplicating a lambda expression
  ;;   (let [fvs (free-vars expr)]
  ;;     (cond (empty? fvs)
  ;;           (either (last (replace (.cont dup-expr) {(.id dup-expr) expr}))
  ;;                   (do
  ;;                     (print-err 'interp-error _LINE_ expr
  ;;                                "\n\n" dup-expr)
  ;;                     (abort)))

  ;;           (.expr dup-expr expr))))

  ;; (lazy-redex [ast]
  ;;   ast)

  ;; (eval [ast _]
  ;;   ast)

  ;; (eval-bind [f binding env]
  ;;   ;; todo: temporary hack. expand later
  ;;   ;; what if there are free-vars in some, all or none of the arities
  ;;   (either (last (ast/simple-replace (.cont binding) {(.id binding) f}))
  ;;           (do
  ;;             (print-err 'compiler-error _FILE_ _LINE_)
  ;;             (abort))))

  ;; (eval-app [tgt call env]
  ;;   (let [args (.args call)
  ;;         arg-count (count args)]
  ;;     (either (for [arity (or (some (.arities tgt)
  ;;                                   (fn [arity]
  ;;                                     (and (= (count (.params arity)) arg-count)
  ;;                                          (maybe arity))))
  ;;                             (do
  ;;                               (print-err 'no-arity-found (ast/location call) arg-count
  ;;                                          "\n\n" tgt)
  ;;                               nothing))]
  ;;               (let [new-env (-> arity
  ;;                                 .params
  ;;                                 .fixed
  ;;                                 (zip-lists args)
  ;;                                 (reduce {} (fn [m [k v]]
  ;;                                              (assoc m k v))))
  ;;                     new-body (ast/simple-replace (.body arity) new-env)
  ;;                     r (either (last (hylo-env pre-eval eval env new-body))
  ;;                               call)]
  ;;                 ;; (print-err 'expr _LINE_ (.call-target call)
  ;;                 ;;            "\n\n" 'args (.args call)
  ;;                 ;;            "\n\n" 'env (keys env)
  ;;                 ;;            ;; "\n\n" 'new-env new-env
  ;;                 ;;            "\n\n" 'result r)
  ;;                 ;; (abort)
  ;;                 r))
  ;;             (.call-target call tgt))))

  DotOut
  (grph-up [expr]
    (se/state-error (either (first (.arities expr))
                            ""))))

(def debugging {(ast/tag 'grph) grph})

(extend-type ast/call-ast
  Evaluation
  (redex [expr]
    ;; Line 437
    (do-app (redex (.call-target expr)) expr))

  ;; Line 475
  (strong-norm [expr]
    (let [normd-lam (redex (.call-target expr))
          args (.args expr)
          new-args (map args redex)]
      (-> expr
          (.call-target normd-lam)
          (.args new-args))))

  ;; Line 255
  (do-app [expr app-expr]
    (.call-target app-expr expr))

  ;; (head [expr]
  ;;   (RecurseWith (.args expr (Skip (.args expr)))))

  ;; (do-dup [expr dup-expr]
  ;;   (.expr dup-expr expr))

  ;; (lazy-redex [expr]
  ;;   (do-app (.call-target expr) expr))

  ;; (strict [expr]
  ;;   (cond (instance? Symbol (.call-target expr))
  ;;         expr

  ;;         (let [new-lam (strict (.call-target expr))
  ;;               new-expr (do-app new-lam expr)]
  ;;           new-expr)))

  ;; (pre-eval [ast env]
  ;;   [(.args ast (map (.args ast) Skip))
  ;;    env])

  ;; (eval-bind [ast binding env]
  ;;   (.expr binding ast))

  ;; (eval [expr env]
  ;;   (either (map (get debugging (.call-target expr))
  ;;                (fn [debug-fn]
  ;;                  (apply debug-fn (map (.args expr)
  ;;                                       (fn [x]
  ;;                                         (eval-expr x env))))))

  ;;           (eval-app (.call-target expr) expr env)))

  DotOut
  (grph-down [expr]
    (let [node-id (gensym "app")]
      (println node-id (str "[label=\"@\", ordering=out]"))
      (for [_ (push-env)
            _ (set-val self node-id)]
        expr)))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [tgt (.call-target expr)
                tgt-end (str node-id ":sw")
                arg-end (str node-id ":se")]
          _ (pop-env)
          _ (cond (instance? String tgt)
                  (se/state-error (println tgt-end "--" tgt))

                  (comp (for [endpoint (get-val tgt)]
                          (println tgt-end "--" endpoint))
                        (set-val tgt tgt-end)))
          _ (se/traverse (.args expr) (fn [arg]
                                       (cond (instance? String arg)
                                             (se/state-error (println arg-end "--" arg))

                                             (comp (for [endpoint (get-val arg)]
                                                     (println arg-end "--" endpoint))
                                                   (set-val arg arg-end)))))]
      (str node-id ":n"))))


(def core-env {(ast/tag 'church) church
               (ast/tag 'inc) inc
               (ast/tag 'grph) grph})

;; (defn weak-norm [expr]
;;   (let [new-head (head expr)]
;;     (cond (instance? RecurseFinal new-head)
;;           (.x new-head)

;;           (-> (.x new-head)
;;               (map (fn [inner]
;;                      (weak-norm inner)))
;;               lazy-redex))))

;; (defn all-strict [expr]
;;   ;; (print-err 'all-strict _LINE_)
;;   ;; (println "subgraph" (gensym "cluster") "{")
;;   ;; (println "graph [color=none, label=\"I\"]")
;;   ;; (println (gensym "i") "[label=\"\"]")
;;   ;; (println "}")
;;   (let [result (strict expr)]
;;     (cond (= result expr)
;;           (do
;;             (print-err 'final _LINE_ result)
;;             result)

;;           ;; (or (instance? Cr result)
;;           ;;     (instance? Dup result)
;;           ;;     (instance? App result)
;;           ;;     (instance? Add result)
;;           ;;     (instance? Sub result)
;;           ;;     (instance? Lam result))
;;           (all-strict result)

;;           ;; (print-err 'strict-final _LINE_ result)
;;           )))

(defn eval-exprs [exprs]
  (let [defs (-> (.value exprs)
                 (filter (partial instance? ast/definition-ast))
                 (reduce core-env
                         (fn [defs def]
                           (either (-> (.value-exprs def)
                                       (remove (partial instance? ast/NoCode))
                                       last
                                       (map (fn [val-ast]
                                              (assoc defs (.sym def)
                                                     (ast/simple-replace val-ast defs)))))
                                   defs))))
        expr (either (last (remove (.value exprs)
                                   (partial instance? ast/definition-ast)))
                     ast/no-comment)
        expr (ast/simple-replace expr defs)]
    (print-err 'final _LINE_ (lazy expr))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more rdr/top-level)))

(main [args]
  (println "graph sharing {")
  (println "node [shape=none, height=0, width=0]"
           "\nedge [arrowhead=none]")
  (let [[_ file-name] args]
    (either (map (fio/file-in file-name)
                 (fn [file-in]
                   ;; if opened, parse and evaluate
                   (let [parse-result (parse-forms {'file-name file-name
                                                    'line-number 1}
                                                   (lazy-list file-in))]
                     (either (map (instance? rd/ParserError parse-result)
                                  (fn [r]
                                    (print-err (.msg r))
                                    (abort)))
                             (eval-exprs parse-result)))))

            ;; or tell everyone it couldn't be
            (print-err str "Could not find/open " file-name)))
  (println  "}\n")
  (print-err 'done))
