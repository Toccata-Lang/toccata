
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "321aa0b"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "12ce161"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))

(def redex-count (agent 0))

(defn reduction [n line expr]
  ;; (print-err 'reduction _LINE_ line expr)
  (inc n))

(defprotocol Evaluation
  ;; Term.reduce Line 430
  (redex [expr defs])

  ;; Term.normal.go Line 467
  (strong-norm [expr defs])

  ;; Term.rule.app Line 222
  (do-app [expr app-expr defs]
    ;; (.call-target app-expr expr)
    ))

(defn lazy [expr defs]
  ;; (print-err 'expr _LINE_ expr)
  (let [new-expr (strong-norm (redex expr defs) defs)]
    (either (or (instance? Fn new-expr)
                (= new-expr expr))
            (lazy new-expr defs))))

(deftype Self []
  Stringable
  (string-list [_]
    (list "self")))

(def self (Self))

(defprotocol DotOut
  (grph-down [expr]
    (assert-result r (instance? se/StateError r))
    (se/state-error expr))

  (grph-up [expr]
    (assert-result r (instance? se/StateError r))))

(defn grph
  ([expr] (grph expr {}))
  ([expr env]
   ((hylo grph-down grph-up expr se/state-error) (list env))
   expr))

(defn get-val [k]
  (se/get-in-val [0 k]))

(defn dissoc-val [k]
  (se/update-state (fn [st]
                     (cons (either (map (first st) (fn [m]
                                                     (dissoc m k)))
                                   {})
                           (rest st)))))

(defn set-val [k v]
  (map (se/update-state (fn [st]
                          (cons (either (map (first st) (fn [m]
                                                          (assoc m k v)))
                                        {k v})
                                (rest st))))
       (fn [_]
         v)))

(defn fresh-vars [vs]
  (fn [expr]
    (reify
      Container
      (map [_ f embed]
        (f expr))

      DotOut
      (grph-down [this]
        (map (se/traverse vs
                          (fn [s]
                            (let [node-id (gensym (str s))]
                              (println node-id (str "[label=\"" s "\"]"))
                              (set-val s node-id))))
             (fn [_]
               this))))))

(defn push-env []
  (se/update-state (fn [st]
                     (cons (either (first st)
                                   {})
                           st))))

(defn pop-env []
  (se/update-state rest))

(defn nip-env [vs]
  (se/update-state (fn [[fst snd & tail]]
                     (-> (reduce vs fst dissoc)
                         (comp (select-keys snd vs))
                         (cons tail)))))

(def CoreType (any-of Integer Fn Vector List Maybe))

(extend-type CoreType
  ast/AST
  (ast/vars [_]
    {})

  Evaluation
  (redex [x defs]
    x)

  (strong-norm [x defs]
    x))

(extend-type Integer
  Container
  (map [n _] n)
  (map [n _ embed]
    (embed n))

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str n) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type ast/tagged-symbol
  Evaluation
  ;; Equivalent to line 431
  (redex [ast defs]
    (either (get defs ast)
            ast))
  
  ;; Line 468
  (strong-norm [ast defs]
    (either (get defs ast)
            ast))

  ;; Line 255
  (do-app [ast app-expr defs]
    (.call-target app-expr ast))

  DotOut
  (grph-up [s]
    (se/state-error s)))

(extend-type ast/integer-ast
  Evaluation
  (redex [ast defs]
    (.int ast))

  (strong-norm [ast defs]
    (.int ast))

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str (.int n)) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type Fn
  Container
  (map [f _]
    f)

  (map [f _ embed]
    (embed f))

  Evaluation
  (do-app [f app-expr defs]
    ;; a Fn can only be applied to CoreType values, so the args
    ;; have to be completely reduced with no free variables
    ;; 'grpbh' is the exception as it can be applied to ast's as well.
    (let [new-args (map (.args app-expr) (fn [arg]
                                           (lazy arg defs)))]
      (send redex-count reduction _LINE_ (ast/call-ast f (.args app-expr)))
      (cond (or (identical f grph)
                (identical f print-err)
                (every new-args (partial instance? CoreType)))
            (apply f new-args)

            (ast/call-ast f new-args))))

  DotOut
  (grph-up [expr]
    (let [node-id (gensym "fn")
          x-end (str node-id ":sw")
          y-end (str node-id ":se")]
      (println node-id (str "[label=\"" (fn-name expr) "\", ordering=out]"))
      (se/state-error (str node-id ":n")))))

(deftype GlobalVar [var]
  Stringable
  (string-list [_]
    (list (str "<" var ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  ast/AST
  (ast/vars [_]
    {})

  Evaluation
  (redex [ast defs]
    (either (get defs var)
            ast))

  (strong-norm [ast defs]
    (either (get defs var)
            ast))

  (do-app [ast app-expr defs]
    (.call-target app-expr ast))

  DotOut
  (grph-up [s]
    (se/state-error var)))

(defn church [n]
  (let [fn-sym (ast/tag (symbol (str n)))
        param-x (ast/tag (gensym "px"))
        x (ast/tag (gensym "x"))
        y (ast/tag (gensym "y"))]
    (ast/fn-ast fn-sym
                [(ast/fn-arity-ast
                  fn-sym
                  (ast/params [param-x])
                  ast/no-comment
                  [(ast/fn-ast c/no-symbol
                               [(cond (= 0 n)
                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [y]
                                                        {})

                                      (= 1 n)
                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [(ast/call-ast param-x [y])]
                                                        {param-x 1})

                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [
                                                         ;; (reduce (range n) y
                                                         ;;         (fn [expr _]
                                                         ;;           (ast/call-ast param-x [expr])))

                                                         (ast/binding-ast
                                                          x param-x
                                                          [(reduce (range n) y
                                                                   (fn [expr _]
                                                                     (ast/call-ast x [expr])))])
                                                         ]
                                                        {param-x 1}))])]
                  {})])))

(extend-type ast/block-comment-ast
  Evaluation
  (redex [expr defs]
    expr)

  (strong-norm [expr defs]
    expr))

(extend-type ast/binding-ast
  Evaluation
  ;; Line 444
  (redex [expr defs]
    ;; here we deviate from .kind. If there are no free vars left in (.expr expr)
    ;; it can be substituted (and possibly duped) in cont and then cont can be
    ;; reduced
    ;; TODO: instead of reducing (.expr expr) immediately, create a value that will
    ;; cache the result the first time it gets used
    (let [curr-expr (.expr expr)]
      (cond (or (instance? CoreType curr-expr)
                (instance? GlobalVar curr-expr)
                (instance? ast/fn-ast curr-expr))
            (let [id-env {(.id expr) curr-expr}
                  new-cont (map (.cont expr) (fn [cont-expr]
                                               (ast/simple-replace cont-expr id-env)))]
              (send redex-count reduction _LINE_ expr)
              (-> new-cont
                  butlast
                  (map (fn [expr]
                         (lazy expr defs))))
              (let [r (either (map (last new-cont) (fn [expr]
                                                     (redex expr defs)))
                              (do
                                (print-err 'interp-err _LINE_ expr
                                           "\n\n" 'new-cont new-cont)
                                (abort)))]
                ;; (print-err 'curr-expr _LINE_ (.id expr) curr-expr
                ;;            "\n\n" 'fvs (either (for [_ (instance? ast/fn-ast curr-expr)
                ;;                                      arity (first (.arities curr-expr))]
                ;;                                  (dissoc-all (merge-maps + (map (.body arity)
                ;;                                                                 ast/free-vars))
                ;;                                              (comp (keys defs)
                ;;                                                    (ast/all-syms (.params arity)))))
                ;;                                'nada)
                ;;            ;; "\n\n" 'cont (.cont expr)
                ;;            "\n\n" 'r r)
                r))

            (let [new-expr (redex (.expr expr) defs)]
              (.expr expr new-expr)))))

  (strong-norm [expr defs]
    (-> expr
        (.expr (lazy (.expr expr) defs))
        (.cont (map (.cont expr) (fn [expr]
                                   (lazy expr defs))))))

  (do-app [expr app-expr defs]
    (let [init-cont (butlast (.cont expr))
          last-cont (either (last (.cont expr))
                            (do
                              (print-err 'interp-err _LINE_ expr
                                         "\n\n" 'app-expr app-expr)
                              (abort)))
          new-cont (comp init-cont [(.call-target app-expr last-cont)])]
      (redex (.cont expr new-cont) defs)))

  DotOut
  (grph-down [expr]
    (let [node-id (gensym "bnd")
          endpoint (str node-id ":n")]
      (println node-id (str "[label=\"\",")
               "height=0.4, width=0.4, fixedsize=true, shape=triangle, orientation=180]")
      (for [_ (push-env)
            _ (set-val self node-id)
            _ (se/traverse (ast/all-syms (.id expr))
                           (fn [id]
                             (set-val id endpoint)))]
        expr)))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [arg-end (str node-id ":sw")
                new-ids (reduce (ast/all-syms (.id expr)) [self]
                                (fn [new-ids id]
                                  (cond (instance? ast/tagged-symbol id)
                                        (conj new-ids id)

                                        (comp new-ids id))))]
          _ (nip-env new-ids)
          _ (cond (instance? Sequence (.expr expr))
                  (do
                    (print-err 'graphing-error _LINE_ expr)
                    (abort))

                  (instance? String (.expr expr))
                  (se/state-error (println arg-end "--" (.expr expr)))

                  (comp (map (get-val (.expr expr))
                             (fn [endp]
                               (println arg-end "--" endp)))
                        (set-val (.expr expr) arg-end)))]
      (either (last (.cont expr))
              ""))))

(extend-type ast/fn-arity-ast
  Evaluation
  (strong-norm [expr defs]
    (let [new-bod (map (.body expr) (fn [expr]
                                      (lazy expr defs)))
          new-expr (.body expr new-bod)]
      new-expr))

  DotOut
  (grph-down [f]
    (let [node-id (gensym "fn")]
      (println node-id (str "[label=\"Î»\"]"))
      (for [_ (push-env)
            _ (set-val self node-id)
            _ (se/traverse (ast/all-syms (.params f))
                           (fn [v]
                             (set-val v (str node-id ":sw"))))]
        f)))

  (grph-up [f]
    (for [node-id (get-val self)
          :let [body (either (last (.body f))
                             (ast/tag '_))]
          _ (cond (instance? ast/tagged-symbol body)
                  (comp (for [body-node (get-val body)]
                          (println (str node-id ":s") "--" body-node))

                        ;; (set-val body (str node-id ":s"))
                        (se/state-error '_))
                  (se/state-error (println (str node-id ":s") "--" body)))
          _ (pop-env)]
      (str node-id ":n"))))

;; Line 228
(defn apply-arity [expr app-expr defs]
  (let [args (.args app-expr)
        new-env (reduce (zip-lists (.fixed (.params expr)) args) {}
                        (fn [m [k v]]
                          (assoc m k v)))]
    (send redex-count reduction _LINE_ expr)
    ;; (print-err 'applying _LINE_ (str "(fn " (.fn-sym expr) expr ")")
    ;;            "\n\n" 'args args)
    ;; fully reduce all but the last expression for any side effects
    ;; TODO: but what if they have free-vars
    (-> (.body expr)
        butlast
        (map (fn [expr]
               (lazy expr defs))))
    (either (map (last (.body expr))
                 (fn [body]
                   (redex (ast/simple-replace body new-env) defs)))
            app-expr)))


(extend-type ast/fn-ast
  Evaluation
  ;; Line 434
  (redex [expr defs]
    expr)

  (strong-norm [ast defs]
    ;; must apply strong-norm to each of the arities
    (.arities ast (map (.arities ast) (fn [arity]
                                        (strong-norm arity defs)))))

  (do-app [tgt call defs]
    ;; find the correct arity and call do-app on it
    (let [args (.args call)
          arg-count (count args)]
      (either (map (some (.arities tgt)
                         (fn [arity]
                           ;; TODO: variadic will be handled here
                           (and (= (count (.params arity)) arg-count)
                                (maybe arity))))
                   (fn [arity]
                     (apply-arity arity call defs)))
              (do
                (print-err 'no-arity-found (ast/location call) arg-count
                           "\n\n" tgt)
                (.call-target call tgt)))))

  DotOut
  (grph-up [expr]
    (se/state-error (either (first (.arities expr))
                            ""))))

(extend-type ast/NestedCond
  Evaluation
  (redex [ast defs]
    (let [test (redex (.test ast) defs)]
      (cond (instance? Maybe test)
            (cond test
                  (redex (.clause ast) defs)

                  (redex (.cont ast) defs))
            (.test ast test))))

  (strong-norm [ast defs]
    ;; TODO: not convinced this is right
    (redex ast defs)))

(extend-type ast/call-ast
  Evaluation
  (redex [expr defs]
    ;; Line 437
    (let [ct (redex (.call-target expr) defs)]
      (do-app ct expr defs)))

  (strong-norm [expr defs]
    (let [normd-lam (redex (.call-target expr) defs)
          args (.args expr)
          new-args (map args (fn [arg]
                               (redex arg defs)))]
      (-> expr
          (.call-target normd-lam)
          (.args new-args))))

  ;; Line 255
  (do-app [expr app-expr defs]
    (.call-target app-expr expr))

  DotOut
  (grph-down [expr]
    (let [node-id (gensym "app")]
      (println node-id (str "[label=\"@\", ordering=out]"))
      (for [_ (push-env)
            _ (set-val self node-id)]
        expr)))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [tgt (.call-target expr)
                tgt-end (str node-id ":sw")
                arg-end (str node-id ":se")]
          _ (pop-env)
          _ (cond (instance? String tgt)
                  (se/state-error (println tgt-end "--" tgt))

                  (comp (for [endpoint (get-val tgt)]
                          (println tgt-end "--" endpoint))
                        (set-val tgt tgt-end)))
          _ (se/traverse (.args expr) (fn [arg]
                                       (cond (instance? String arg)
                                             (se/state-error (println arg-end "--" arg))

                                             (comp (for [endpoint (get-val arg)]
                                                     (println arg-end "--" endpoint))
                                                   (set-val arg arg-end)))))]
      (str node-id ":n"))))


(def core-env {(ast/tag 'church) church
               (ast/tag 'print-err) print-err
               (ast/tag 'inc) inc
               (ast/tag 'dec) dec
               (ast/tag '+) +
               (ast/tag '-) -
               (ast/tag '*) *
               (ast/tag 'range) range
               (ast/tag 'cons) cons
               (ast/tag 'first) first
               (ast/tag 'rest) rest
               (ast/tag 'empty-list) empty-list
               (ast/tag 'empty?) empty?
               (ast/tag 'nil) nothing
               (ast/tag '=) =
               (ast/tag 'bit-shift-right) bit-shift-right
               (ast/tag 'bit-and) bit-and
               (ast/tag 'grph) grph})

(defn eval-exprs [exprs]
  (let [defs (-> exprs
                 (filter (partial instance? ast/definition-ast))
                 (reduce core-env
                         (fn [defs def]
                           (either (-> (.value-exprs def)
                                       (remove (partial instance? ast/NoCode))
                                       last
                                       (map (fn [val-ast]
                                              (assoc defs (.sym def)
                                                     ;; (ast/simple-replace val-ast defs)
                                                     val-ast))))
                                   defs))))
        def-syms (keys defs)
        global-syms (reduce def-syms {} (fn [m s]
                                          (assoc m s (GlobalVar s))))
        defs (map-vals defs (fn [def]
                              (either (instance? CoreType def)
                                      (let [new-def (ast/simple-replace def global-syms)]
                                        ;; (print-err 'new-def _LINE_ new-def)
                                        new-def))))
        expr (either (last (remove exprs (partial instance? ast/definition-ast)))
                     ast/no-comment)
        expr (ast/simple-replace expr global-syms)]
    (lazy expr defs)))

(def parse-forms
  (rd/parser
   (grmr/none-or-more rdr/top-level)))

(main [args]
  ;; (println "graph sharing {")
  ;; (println "node [shape=none, height=0, width=0]"
  ;;          "\nedge [arrowhead=none]")
  (let [start-time (sys/clock_gettime)
        [_ file-name & cnt-str] args
        test-cnt (either (map (first cnt-str) str-to-int)
                         3)
        p (promise)]
    (either (map (fio/file-in file-name)
                 (fn [file-in]
                   ;; if opened, parse and evaluate
                   (let [parse-result (parse-forms {'file-name file-name
                                                    'line-number 1}
                                                   (lazy-list file-in))]
                     (either (map (instance? rd/ParserError parse-result)
                                  (fn [r]
                                    (print-err (.msg r))
                                    (abort)))
                             (let [final (eval-exprs (comp [(ast/definition (ast/tag (symbol "$1"))
                                                              (list test-cnt))]
                                                           (.value parse-result)))
                                   elapsed (sys/time-delta start-time (sys/clock_gettime))
                                   _ (send redex-count (partial deliver p))
                                   redexes (extract p)]
                               (print-err 'final _LINE_ final)
                               (println 'stats (str test-cnt ", " elapsed ", " redexes)))))))

            ;; or tell everyone it couldn't be
            (print-err str "Could not find/open " file-name))
    ;; (println  "}\n")
    )
  (print-err 'done))
