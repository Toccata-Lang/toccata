
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "dc7a1e0"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "83fd876"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))

(def se-nop (se/state-error '_))

(defn se-debug [& msg]
  (map se-nop
       (fn [_]
         (apply print-err msg))))

(def lflf "\n\n")
(def redex-count (agent 0))

(defn reduction [n line expr]
  ;; (print-err 'reduction _LINE_ line expr)
  (inc n))

(deftype Copies [idx copies]
  (assert (instance? Vector copies))

  Stringable
  (string-list [x]
    (list "(Copies " ;; (str (curr-int idx))
          (str copies) ")" ))

  Container
  (map [x f embed]
    (map (map copies f embed)
         (fn [new-copies]
           (Copies (int-generator) new-copies))))

  (extract [x]
    (either (get copies (extract idx))
            (do
              (print-err 'no-more-copies _LINE_ x)
              (extract (first copies)))))

  Collection
  (empty? [x]
    (and (<= (count copies) (curr-int idx))
         (maybe x))))

(defprotocol Evaluation
  (redex [expr defs hist])

  (do-app [expr app-expr defs hist]
    (ast/call-expr (comp [expr] (.args app-expr))))

  (copy [x num-uses env hist])

  (replace-copy [x env defs hist]
    (ast/replace-sym x env)))

;; TODO: causes incRef error
;; (defn redex-f [expr prev-expr defs]
;;   (either (= expr prev-expr)
;;           (redex-f (redex expr defs identity)
;;                    expr defs)))

(defn redex-f
  ([expr defs] (redex-f expr defs identity))
  ([expr defs hist]
   (print-err 'from-the-top _LINE_ expr)
   (let [new-expr (redex expr defs hist)]
     (either (= expr new-expr)
             (redex-f new-expr defs)))))

(defprotocol DotOut
  (grph-down [expr]
    (assert-result r (instance? se/StateError r))
    (se/state-error expr))

  (grph-up [expr]
    (assert-result r (instance? se/StateError r))))

(defn grph
  ([expr] (grph expr {}))
  ([expr env]
   ((hylo grph-down grph-up expr se/state-error) (list env))
   expr))

(extend-type Copies
  DotOut
  (grph-down [x]
    (se/state-error (extract x)))

  ;; (grph-up [x]
  ;;   (se/state-error (extract x)))
  )

(deftype NoGraph [node-id]
  Container
  (map [x f embed]
    (embed x))

  DotOut
  (grph-up [_]
    (se/state-error node-id)))

(deftype Self []
  Stringable
  (string-list [_]
    (list "self")))

(extend-type String
  Container
  (map [s _ embed]
    (print-err 'blewto _LINE_ s)
    (abort))

  DotOut
  (grph-up [x]
    (se/state-error x)))

(def self (Self))

(defn get-val [k]
  (se/get-in-val [0 k]))

(defn dissoc-val [k]
  (se/update-state (fn [st]
                     (cons (either (map (first st) (fn [m]
                                                     (dissoc m k)))
                                   {})
                           (rest st)))))

(defn set-val [k v]
  (map (se/update-state (fn [st]
                          (cons (either (map (first st) (fn [m]
                                                          (assoc m k v)))
                                        {k v})
                                (rest st))))
       (fn [_]
         v)))

(defn set-all-vals [k v]
  (map (se/update-state (fn [st]
                          (map st (fn [m]
                                    (assoc m k v)))))
       (fn [_]
         v)))

(defn push-env []
  (se/update-state (fn [st]
                     (cons (either (first st)
                                   {})
                           st))))

(defn pop-env []
  (se/update-state rest))

(defn nip-env [vs]
  (se/update-state (fn [[fst snd & tail]]
                     (-> (reduce vs fst dissoc)
                         (comp (select-keys snd vs))
                         (cons tail)))))

;; (defn reduce-fn-ast [expr defs hist]
;;   (let [new-expr (redex expr defs hist)]
;;     (either (or (identical expr new-expr)
;;                 (= expr new-expr))
;;             (cond (instance? ast/fn-ast new-expr)
;;                   ;; TODO: use cata?
;;                   (.arities new-expr
;;                             (map (.arities new-expr)
;;                                  (fn [arity]
;;                                    (.body arity
;;                                           (map (.body arity)
;;                                                (fn [expr]
;;                                                  (redex expr defs
;;                                                         (comp hist
;;                                                               (fn [bod]
;;                                                                 ;; TODO: no mult. arities
;;                                                                 (.arities new-expr
;;                                                                           [(.body arity
;;                                                                                   [bod])]))))))))))

;;                   (reduce-fn-ast new-expr defs hist)))))

(extend-type ast/param-sym
  Evaluation
  (copy [x num-uses env hist]
    x)

  (redex [x defs hist]
    x)

  DotOut
  ;; (map (get-val (address-of x))
  ;;   (fn [node-id]
  ;;     (reify
  ;;       Container
  ;;       (map [this _ embed]
  ;;         (embed this))

  ;;       DotOut
  ;;       (grph-up [_]
  ;;         (se/state-error (str node-id ":n"))))))

  (grph-up [x]
    (comp (for [node-id (get-val x)]
            (cond (= 0 (.uses x))
                  ""

                  (str node-id ":n")))

          (map (set-all-vals x (gensym (str (.sym x))))
               (fn [param-id]
                 (println param-id "[label=\"" (str (.sym x)) (mod (address-of x) 1000) "\"]")
                 (str param-id ":n"))))))

;; (deftype Deferred [expr weak]
;;   Stringable
;;   (string-list [_]
;;     ;; (either (map (delivered weak) string-list))
;;     (list "|" (str (mod (address-of weak) 1000))
;;           (cond (delivered weak) "*" "")
;;           " " (str expr) "|"))

;;   Container
;;   (map [x f]
;;     (.expr x (map expr f)))

;;   (map [x f embed]
;;     (map (f expr) (partial .expr x)))

;;   Eq
;;   (=* [x y]
;;     (and (instance? Deferred y)
;;          (=* expr (.expr y))))

;;   ast/AST
;;   (ast/prep-replace [x env]
;;     (let [expr (either (delivered weak)
;;                        x)]
;;       [(cond (instance? ast/fn-ast expr)
;;              ;; TODO: also check the free-vars of expr
;;              (RecurseFinal expr)

;;              (RecurseWith expr))
;;        env]))

;;   ;; Evaluation
;;   ;; (do-app [x app-expr defs hist]
;;   ;;   (do-app (either (delivered weak)
;;   ;;                   (let [weak-form expr]
;;   ;;                     (deliver weak weak-form)
;;   ;;                     ;; (println "subgraph" (gensym "cluster") "{")
;;   ;;                     ;; (println (str "graph [color=none, label=\"" (mod (address-of weak) 1000)
;;   ;;                     ;;               " delivered " _LINE_ "\"]"))
;;   ;;                     ;; (grph (hist weak-form) defs)
;;   ;;                     ;; (println "}")
;;   ;;                     weak-form))
;;   ;;           app-expr defs hist))

;;   ;; (redex [x defs hist]
;;   ;;   (either (delivered weak)
;;   ;;           (let [weak-form (reduce-fn-ast expr defs
;;   ;;                                          (comp hist (partial .expr x)))]
;;   ;;             (deliver weak weak-form)
;;   ;;             ;; (println "subgraph" (gensym "cluster") "{")
;;   ;;             ;; (println (str "graph [color=none, label=\"" (mod (address-of weak) 1000)
;;   ;;             ;;               " delivered " _LINE_ "\"]"))
;;   ;;             ;; (grph (hist weak-form) defs)
;;   ;;             ;; (println "}")
;;   ;;             weak-form)))

;;   DotOut
;;   (grph-down [x]
;;     (either (map (delivered weak) grph-down)
;;             (comp (map (get-val (address-of weak))
;;                        (fn [node-id]
;;                          (reify
;;                            Container
;;                            (map [this _ embed]
;;                              (embed this))

;;                            DotOut
;;                            (grph-up [_]
;;                              (se/state-error (str node-id ":n"))))))
;;                   (for [node-id (set-val (address-of weak) (gensym "dup"))]
;;                     (do
;;                       (println node-id (str "[label=\"\", xlabel=\""
;;                                             (str (mod (address-of weak) 1000)) "\",")
;;                                "height=0.3, width=0.3, fixedsize=true, shape=triangle,"
;;                                " orientation=180]")
;;                       x)))))

;;   (grph-up [x]
;;     (for [node-id (get-val (address-of weak))
;;           :let [arg-end (str node-id ":sw")]
;;           _ (cond (instance? Sequence expr)
;;                   (do
;;                     (print-err 'graphing-error _LINE_ expr)
;;                     (abort))

;;                   (instance? String expr)
;;                   (se/state-error (println arg-end "--" expr))

;;                   (comp (map (get-val expr)
;;                              (fn [endp]
;;                                (println arg-end "--" endp)))
;;                         (set-val expr arg-end)))]
;;       (str node-id ":n"))))

;; (defn defer [expr]
;;   (cond (or (instance? ast/call-ast expr)
;;             (instance? ast/binding-ast expr)
;;             (instance? ast/fn-ast expr))
;;         (Deferred expr (promise))

;;         expr))

(defn fresh [x]
  (reify
    Stringable
    (string-list [_]
      (list (str x)))

    Container
    (map [this f]
      this)

    (map [this f embed]
      (embed this))

    Eq
    (=* [x y]
      (identical x y))

    ast/AST
    (ast/vars [_] {})

    Evaluation
    (redex [this defs hist]
      this)

    DotOut
    (grph-up [_]
      (let [node-id (gensym (str x))]
        (println node-id (str "[label=\"" x "\"]"))
        (se/state-error (str node-id ":n"))))))

(def CoreType (any-of Integer Fn Vector List Maybe))

(extend-type CoreType
  ast/AST
  (ast/vars [_]
    {})

  Evaluation
  (redex [x defs hist]
    x))

(extend-type Integer
  Container
  (map [n _] n)
  (map [n _ embed]
    (embed n))

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str n) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type ast/tagged-symbol
  Evaluation
  (redex [ast defs hist]
    (either (get defs ast)
            ast))

  (copy [x num-uses env hist]
    x)

  DotOut
  (grph-up [sym]
    (comp (get-val sym)
          (map se-nop (fn [_]
                        (let [node-id (gensym "sym")]
                          (println node-id (str "[label=\"" (str sym) "\"]"))
                          (str node-id)))))))

(extend-type ast/integer-ast
  Evaluation
  (copy [x num-uses env hist]
    x)

  (redex [ast defs hist]
    (.int ast))

  DotOut
  (grph-up [n]
    (let [node-id (gensym "int")]
      (println node-id (str "[label=\"" (str (.int n)) "\", ordering=out]"))
      (se/state-error (str node-id)))))

(extend-type Fn
  Container
  (map [f _]
    f)

  (map [f _ embed]
    (embed f))

  Evaluation
  (copy [x num-uses env hist]
    x)

  (do-app [f app-expr defs hist]
    ;; a Fn can only be applied to CoreType values, so the args
    ;; have to be completely reduced with no free variables
    ;; 'grpbh' is the exception as it can be applied to ast's as well.
    (let [args (.args app-expr)
          new-args (map (zip-lists args (range (count args)))
                        (fn [[arg idx]]
                          (redex-f arg defs (comp hist (fn [new-arg]
                                                         (either (map (store (vec args) idx new-arg)
                                                                      (partial .args app-expr))
                                                                 (do
                                                                   (print-err 'boom _LINE_)
                                                                   (abort))))))))]
      (cond (or (identical f grph)
                (identical f print-err)
                (identical f fresh)
                (every new-args (partial instance? CoreType)))
            (let [r (apply f new-args)]
              ;; (send redex-count reduction _LINE_ new-call)
              ;; (println "subgraph" (gensym "cluster") "{")
              ;; (println (str "graph [color=none, label=\" "
              ;;               (to-str (list* "(" (fn-name f) " " (interpose new-args " ")))
              ;;               ") " _LINE_ "\"]"))
              ;; (grph (hist r) defs)
              ;; (println "}")
              r)

            (ast/call-expr (comp [f] (.args app-expr))))))

  DotOut
  (grph-up [expr]
    (let [node-id (gensym "fn")
          x-end (str node-id ":sw")
          y-end (str node-id ":se")]
      (println node-id (str "[label=\"" (fn-name expr) "\", ordering=out]"))
      (se/state-error (str node-id ":n")))))

(deftype GlobalFn [var]
  Stringable
  (string-list [_]
    (list (str "<" var ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  ast/AST
  (ast/vars [_]
    {})

  Evaluation
  (copy [x num-uses env hist]
    x)

  (redex [ast defs hist]
    ast)

  (do-app [ast app-expr defs hist]
    (either (map (get defs var)
                 (fn [f]
                   (do-app f app-expr defs hist)))
            (ast/call-expr (comp [ast] (.args app-expr)))))

  DotOut
  (grph-up [g]
    (let [node-id (gensym "gbl")]
      (println node-id (str "[label=\"" g "\"]"))
      (se/state-error (str node-id)))))

(defn church [n]
  (let [fn-sym (ast/tag (symbol (str n)))
        x (ast/param-sym (ast/tag (gensym "x")) n)
        y (ast/param-sym (ast/tag (gensym "y")) 1)]
    (ast/fn-ast fn-sym
                [(ast/fn-arity-ast
                  fn-sym
                  (ast/params [x])
                  ast/no-comment
                  [(ast/fn-ast (ast/tag (symbol (str "inner-" n)))
                               [(cond (= 0 n)
                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [y]
                                                        {})

                                      (= 1 n)
                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [(ast/call-expr [x y])]
                                                        {})

                                      (ast/fn-arity-ast c/no-symbol
                                                        (ast/params [y])
                                                        ast/no-comment
                                                        [
                                                         (reduce (range n) y
                                                                 (fn [expr _]
                                                                   (ast/call-expr [x expr])))

                                                         ;; (ast/binding-ast
                                                         ;;  x param-x
                                                         ;;  [(reduce (range n) y
                                                         ;;           (fn [expr _]
                                                         ;;             (ast/call-expr [x expr])))])
                                                         ]
                                                        {}))])]
                  {})])))

(extend-type ast/block-comment-ast
  Evaluation
  (redex [expr defs hist]
    expr))

(def apply-arity)

(extend-type ast/binding-ast
  ;; ast/AST
  ;; (ast/prep-replace [x env]
  ;;   (let [expr (.expr x)]
  ;;     (either (for [new-expr (and (instance? ast/tagged-symbol expr)
  ;;                                 (get env expr))
  ;;                   ;; TODO: don't discard side-effecting expressions in the continuation
  ;;                   cont-result (last (.cont x))]
  ;;               (let [new-env (assoc env (.id x) (defer new-expr))]
  ;;                 (send redex-count reduction _LINE_ (.expr x new-expr))
  ;;                 [(RecurseWith cont-result) new-env]))
  ;;             [(RecurseWith x) env])))

  Evaluation
  (redex [expr defs hist]
    (print-err 'binding _LINE_ (.id expr) (.uses (.id expr))
               lflf expr)
    (let [arity (ast/fn-arity-ast c/no-symbol
                                  (ast/params [(.id expr)])
                                  ast/no-comment
                                  (.cont expr)
                                  {})]
      (apply-arity arity (ast/call-expr [arity (.expr expr)])
                   defs hist)))

  (do-app [expr app-expr defs hist]
    (let [init-cont (butlast (.cont expr))
          last-cont (either (last (.cont expr))
                            (do
                              (print-err 'interp-err _LINE_ expr
                                         lflf 'app-expr app-expr)
                              (abort)))
          new-cont (comp init-cont [(ast/call-expr (comp [last-cont] (.args app-expr)))])]
      ;; TODO: don't know about plain 'hist' here
      (redex (.cont expr new-cont) defs hist)))

  DotOut
  (grph-down [expr]
    (let [node-id (gensym "bnd")
          endpoint (str node-id ":n")]
      (println node-id (str "[label=\"b\",")
               "height=0.3, width=0.3, fixedsize=true, shape=triangle, orientation=180]")
      (for [_ (push-env)
            _ (set-val self node-id)
            _ (se/traverse (ast/all-syms (.id expr))
                           (fn [id]
                             (set-val id endpoint)))]
        expr)))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [arg-end (str node-id ":sw")
                new-ids (reduce (ast/all-syms (.id expr)) [self]
                                (fn [new-ids id]
                                  (cond (instance? ast/param-sym id)
                                        (conj new-ids id)

                                        (comp new-ids id))))]
          _ (nip-env new-ids)
          _ (cond (instance? Sequence (.expr expr))
                  (do
                    (print-err 'graphing-error _LINE_ expr)
                    (abort))

                  (instance? String (.expr expr))
                  (se/state-error (println arg-end "--" (.expr expr)))

                  (comp (map (get-val (.expr expr))
                             (fn [endp]
                               (println arg-end "--" endp)))
                        (set-val (.expr expr) arg-end)))]
      (either (last (.cont expr))
              ""))))

(deftype Sup [poss]
  Stringable
  (string-list [x]
    (list "(Sup " (str (address-of x)) "\n" (str poss) ")"))

  Container
  (map [x f]
    (.poss x (map-vals poss f)))

  (map [x f embed]
    (map (contextual-map-vals poss f embed)
         (partial .poss x)))

  Evaluation
  (copy [x num-uses env hist]
    ;; TODO: finish
    (print-err 'finish _LINE_)

    (println "}")
    (exit 0)
    x)

  (do-app [s app-expr defs hist]
    ;; TODO: hist is wrong here, skips levels because of the cata (or hylo, etc)
    ;; (let [new-s (map s (fn [new-tgt]
    ;;                      (ast/call-expr (comp [new-tgt] (.args app-expr)))))]
    ;;   ;; (println "subgraph" (gensym "cluster") "{")
    ;;   ;; (println (str "graph [color=none, label=\"Call - Sup " _LINE_ "\"]"))
    ;;   ;; (grph new-s defs)
    ;;   ;; (println "}")
    ;;   new-s)
    (cond (identical s (.call-target app-expr))
          app-expr
          (.call-target app-expr s)))

  (redex [x defs hist]
    x)

  DotOut
  (grph-down [x]
    (comp (map (get-val (address-of x))
               (fn [node-id]
                 (NoGraph (str node-id ":n"))))
          (for [node-id (set-all-vals (address-of x) (gensym "sup"))
                _ (push-env)
                _ (set-val self x)]
            (do
              (println node-id "[label=\"\","
                       ;; (str " xlabel=\"" (mod (address-of x) 1000) "\",")
                       " height=0.3, width=0.3, fixedsize=true,"
                       " shape=triangle, orientation=0]")
              x))))

  (grph-up [x]
    (for [old-x (get-val self)
          _ (pop-env)
          node-id (get-val (address-of old-x))]
      (do
        (map (vals poss) (fn [x]
                           (println (str node-id ":s") "--" x)))
        (str node-id ":n")))))

(defn copy-arity [arity num-uses defs hist]
  (let [sups (reduce (ast/all-syms (.params arity)) {}
                     (fn [m param-sym]
                       (assert (instance? ast/param-sym param-sym))
                       (assoc m param-sym (map (range num-uses)
                                               (fn [_]
                                                 (ast/param-sym (.sym param-sym)
                                                                (.uses param-sym)))))))
        new-params (map (vec (range num-uses))
                        (fn [idx]
                          (cata (fn [x]
                                  (either (and (instance? ast/param-sym x)
                                               (get-in sups [x idx]))
                                          x))
                                (.params arity))))
        p-map (reduce new-params {}
                      (fn [m params]
                        (reduce (ast/all-syms params) m
                                (fn [m param]
                                  (assoc m param params)))))
        supers (map-vals sups (fn [alts]
                                (Sup (reduce alts {}
                                             (fn [m alt]
                                               (either (map (get p-map alt)
                                                            (fn [params]
                                                              (assoc m params alt)))
                                                       m))))))
        grph-body (map (.body arity)
                       (fn [expr]
                         ;; TODO: fine for now, but replace if you
                         ;; keep this code
                         (ast/simple-replace expr supers)))
        ;; _ (do
        ;;     (println "subgraph" (gensym "cluster") "{")
        ;;     (println (str "graph [color=none, label=\"copying " _LINE_ "\"]"))
        ;;     (-> (map new-params (fn [params]
        ;;                           (-> arity
        ;;                               (.params params)
        ;;                               (.body grph-body))))
        ;;         (hist)
        ;;         (grph defs))
        ;;     (println "}"))
        new-body (map (.body arity)
                      (fn [body-expr]
                        (print-err 'body-expr _LINE_ body-expr
                                   lflf 'copy (copy body-expr num-uses defs hist))
                        (ast/elgot-env (fn [x env]
                                         (cond (empty? env)
                                               [(RecurseFinal x) env]

                                               (ast/prep-replace x env)))
                                       (fn [x env]
                                         (replace-copy x env defs
                                                       (fn [x]
                                                         (hist (map new-params (fn [params]
                                                                                 (-> arity
                                                                                     (.params params)
                                                                                     (.body x))))))))
                                       body-expr
                                       supers)))]

    (print-err 'new-body _LINE_ new-body)

    ;; (println "subgraph" (gensym "cluster") "{")
    ;; (println (str "graph [color=none, label=\"copying " _LINE_ "\"]"))
    ;; (grph (hist (map new-params (fn [params]
    ;;                               (-> arity
    ;;                                   (.params params)
    ;;                                   (.body new-body)))))
    ;;       defs)
    ;; (println "}")

    (let [new-body (map new-body (fn [expr]
                                   (redex expr defs
                                          (comp hist
                                                (fn [x]
                                                  (map new-params (fn [params]
                                                                    (-> arity
                                                                        (.params params)
                                                                        (.body [x])))))))))]
      (map new-params (partial .params (.body arity new-body))))))

(extend-type ast/fn-arity-ast
  Evaluation
  (copy [x num-uses env hist]
    ;; TODO: finish
    (print-err 'finish _LINE_)

    (println "}")
    (exit 0)
    x)

  (redex [expr defs hist]
    expr)

  DotOut
  (grph-down [f]
    (comp (for [node-id (get-val (address-of f))]
            (NoGraph (str node-id ":n")))
          (for [node-id (set-all-vals (address-of f) (gensym "fn"))
                _ (push-env)
                _ (set-val self f)
                _ (se/traverse (ast/all-syms (.params f))
                               (fn [x]
                                 (assert (instance? ast/param-sym x))

                                 (for [param-id (comp (get-val x)
                                                      (set-all-vals x (gensym (str (.sym x)))))]
                                   (do
                                     (cond (= 0 (.uses x))
                                           (do
                                             (println param-id "[label=\"" (str (.sym x)) "\""
                                                      ;; ", xlabel=\"" x "\""
                                                      "]")
                                             (println (str node-id ":sw") "--" (str param-id ":ne")))

                                           (do
                                             (println param-id "[label=\"\","
                                                      " height=0.3, width=0.3, fixedsize=true,"
                                                      " shape=triangle, orientation=180]")
                                             (println (str node-id ":sw") "--" (str param-id ":sw"))))
                                     x))))]
            (do
              (println node-id (str "[label=\"λ " (cond (= c/no-symbol (.fn-sym f))
                                                        (mod (address-of f) 1000)
                                                        (.fn-sym f))
                                    "\"]"))
              f))))

  (grph-up [f]
    (for [old-f (get-val self)
          node-id (get-val (address-of old-f))
          :let [body (either (last (.body f))
                                  ast/no-comment)]
          _ (pop-env)]
      (do
        (println (str node-id ":s") "--" body)
        (str node-id ":n")))))

(defn rscheme [co-algebra algebra x embed]
  (flat-map (co-algebra x)
            (fn [new-x]
              (cond (instance? RecurseFinal new-x)
                    (embed (.x new-x))

                    (flat-map (map (.x new-x) (fn [y]
                                                (rscheme co-algebra algebra y embed))
                                   embed)
                              (fn [new-x]
                                (algebra new-x x)))))))

(defn graph-title [tgt]
  (either (or (map (instance? GlobalFn tgt)
                   (comp str .var))
              (map (instance? ast/fn-ast tgt)
                   (fn [f]
                     (let [fn-sym (.fn-sym f)]
                       (cond (instance? ast/tagged-symbol fn-sym)
                             (str fn-sym)
                             "")))))
          (type-name tgt)))

(deftype param-arg [param arg]
  Stringable
  (string-list [_]
    (list "(param-arg " (type-name param) " " (str arg) ")"))

  Container
  (map [x f embed]
    (for [new-param (f param)
          new-arg (f arg)]
      (param-arg new-param new-arg)))

  DotOut
  (grph-down [x]
    (comp (get-val (address-of x))
          (for [_ (push-env)
                _ (cond (< (.uses param) 2)
                        (do
                          (print-err 'graphing-error _LINE_ param
                                     lflf arg)
                          (abort))

                        (cond (instance? Sup arg)
                              se-nop

                              (for [param-id (comp (get-val param)
                                                   (set-all-vals param (gensym (str (.sym param)))))]
                                (println param-id "[label=\"\","
                                         " height=0.3, width=0.3, fixedsize=true,"
                                         " shape=triangle, orientation=180]"))))
                _ (set-val self x)]
            x)))

  (grph-up [x]
    (flat-map (get-val self)
              (fn [old-x]
                (cond (instance? Sup (.arg old-x))
                      (for [_ (pop-env)
                            ;; _ (set-all-vals (address-of old-x) arg)
                            ]
                        arg)

                      (for [param-id (get-val (.param old-x))
                            _ (pop-env)
                            _ (set-all-vals (address-of old-x) (.param old-x))]
                        (do
                          (println (str param-id ":s") "--" arg)
                          param)))))))

(defn reduce-body [params app-expr body defs hist]
  ;; TODO: totally needs to be refactored
  (let [args (.args app-expr)
        idxs (int-generator)
        new-env (reduce (zip-lists (.fixed params) args) {}
                        (fn [m [param arg]]
                          (cond (< 0 (.uses param))
                                (let [p-arg (param-arg param arg)
                                      ;; _ (do
                                      ;;     (println "subgraph" (gensym "cluster") "{")
                                      ;;     (println (str "graph [color=none, label=\"apply-arity "
                                      ;;                   (graph-title (.call-target app-expr))
                                      ;;                   " " _LINE_ "\"]"))
                                      ;;     (-> (cata (fn [x]
                                      ;;                 (cond (= x param)
                                      ;;                       (cond (< (.uses param) 2)
                                      ;;                             arg
                                      ;;                             p-arg)
                                      ;;                       x))
                                      ;;               body)
                                      ;;         (hist)
                                      ;;         (grph defs))
                                      ;;     (println "}"))
                                      dupes (copy arg (.uses param) defs
                                                  (fn [new-arg]
                                                    (hist (cata (fn [x]
                                                                  (cond (= x param)
                                                                        new-arg
                                                                        x))
                                                                body))))]
                                  (assoc m param dupes))

                                m)))
        [new-bod] ((rscheme (fn this-fn [x]
                              (cond (instance? Sup x)
                                    (comp (for [v (se/get-val (address-of x))]
                                            (RecurseFinal v))
                                          (either (map (get-in x [.poss params])
                                                       (fn [v]
                                                         (for [_ (se/set-val (address-of x) v)]
                                                           (RecurseWith v))))
                                                  (se/state-error (RecurseWith x))))

                                    (instance? ast/call-ast x)
                                    (comp (map (se/get-val (address-of x))
                                               RecurseFinal)
                                          (either (map (delivered (.reduced x))
                                                       (fn [d]
                                                         ;; TODO: ever get called?
                                                         (print-err 'delivered _LINE_ d)
                                                         (this-fn d)))
                                                  (se/state-error (RecurseWith x))))

                                    (comp (map (se/get-val (address-of x))
                                               RecurseFinal)
                                          (se/state-error (RecurseWith x)))))
                            (fn [p old-p]
                              (cond (instance? ast/param-sym p)
                                    (comp (flat-map (se/get-val p)
                                                    (fn [v]
                                                      (either (map (instance? Copies v)
                                                                   (fn [v]
                                                                     (se/state-error (extract v))))
                                                              (se/set-val (address-of old-p) v))))
                                          (se/set-val (address-of old-p) p))
                                    (se/set-val (address-of old-p) p)))
                            body
                            se/state-error)
                   new-env)]
    new-bod))

(defn apply-arity [expr app-expr defs hist]
  (let [args (.args app-expr)
        params (.params expr)]
    ;; fully reduce all but the last expression for any side effects
    ;; TODO: but what if they have free-vars
    ;; (-> (.body expr)
    ;;     butlast
    ;;     (map (fn [expr]
    ;;            (lazy expr defs))))
    (either (map (last (.body expr))
                 (fn [body]
                   (send redex-count reduction _LINE_ (ast/call-expr [expr args]))
                   (let [new-bod (reduce-body params app-expr
                                              body defs hist)]
                     (println "subgraph" (gensym "cluster") "{")
                     (println (str "graph [color=none, label=\"apply-arity "
                                   (graph-title (.call-target app-expr))
                                   " " _LINE_ "\"]"))
                     (grph (hist new-bod) defs)
                     (println "}")
                     new-bod)))
            app-expr)))

(extend-type ast/fn-ast
  Evaluation
  (redex [expr defs hist]
    expr)

  (copy [f num-uses env hist]
    ;; TODO: finish
    (print-err 'finish _LINE_)

    (println "}")
    (exit 0)
    f
    ;; (cond (< num-uses 2)
    ;;       f

    ;;       (let [arity-vects (apply zip-lists
    ;;                                (map (.arities f)
    ;;                                     (fn [arity]
    ;;                                       (copy-arity arity num-uses defs
    ;;                                                   (comp hist
    ;;                                                         (fn [arities]
    ;;                                                           (assert (instance? Vector arities))

    ;;                                                           (Copies (int-generator)
    ;;                                                                   (map arities
    ;;                                                                        (fn [x]
    ;;                                                                          (.arities f [x]))))))))))
    ;;             dupes (vec (map arity-vects (fn [arities]
    ;;                                           (.arities f (vec arities)))))]
    ;;         (Copies (int-generator) dupes)))
    )

  (do-app [tgt call defs hist]
    (let [args (.args call)
          arg-count (count args)]
      (either (some (.arities tgt)
                    (fn [arity]
                      ;; TODO: variadic will be handled here
                      (and (= (count (.params arity)) arg-count)
                           (maybe (apply-arity arity call defs hist)))))
              (do
                (print-err 'no-arity-found (ast/location call) arg-count
                           lflf tgt)
                (ast/call-expr (comp [tgt] args))))))

  DotOut
  (grph-up [expr]
    (se/state-error (either (first (.arities expr))
                            ""))))

;; (extend-type ast/NestedCond
;;   Evaluation
;;   (redex [ast defs hist]
;;     (let [test (redex (.test ast) defs (comp hist (partial .test ast)))]
;;       (cond (instance? Maybe test)
;;             (cond test
;;                   (redex (.clause ast) defs (comp hist (partial .clause ast)))

;;                   (redex (.cont ast) defs (comp hist (partial .cont ast))))
;;             (.test ast test)))))

(extend-type ast/call-ast
  ;; ast/AST
  ;; (ast/prep-replace [x env]
  ;;   (let [tgt (.call-target x)
  ;;         args (.args x)
  ;;         arg-count (count args)]
  ;;     (either (for [new-tgt (and (instance? ast/tagged-symbol tgt)
  ;;                                (get env tgt))
  ;;                   :when (instance? ast/fn-ast new-tgt)
  ;;                   arity (some (.arities new-tgt)
  ;;                               (fn [arity]
  ;;                                 ;; TODO: variadic will be handled here
  ;;                                 (and (= (count (.params arity)) arg-count)
  ;;                                      (maybe arity))))
  ;;                   ;; TODO: don't discard side-effecting expressions in the body
  ;;                   arity-result (last (.body arity))]
  ;;               (let [new-env (reduce (zip-lists (.fixed (.params arity)) args)
  ;;                                     env
  ;;                                     (fn [m [k v]]
  ;;                                       (assoc m k (defer v))))]
  ;;                 (send redex-count reduction _LINE_ (ast/call-ast new-tgt args))
  ;;                 [(RecurseWith arity-result) new-env]))
  ;;             [(RecurseWith x) env])))

  Evaluation
  (copy [x num-uses env hist]
    ;; TODO: finish
    (print-err 'finish _LINE_)

    (println "}")
    (exit 0)
    ;; (redex x defs hist)
    x
    )

  (redex [expr defs hist]
    (either (delivered (.reduced expr))
            (let [new-tgt (redex (.call-target expr) defs
                                 (comp hist (partial .call-target expr)))
                  reduced (do-app new-tgt expr defs hist)]
              (or (identical expr reduced)
                  (maybe (deliver (.reduced expr) reduced)))
              reduced)))

  (replace-copy [expr env defs hist]
    (cond (instance? Sup (.call-target expr))
          (do-app (.call-target expr) expr defs hist)

          expr))

  DotOut
  (grph-down [expr]
    (either (map (delivered (.reduced expr)) grph-down)
            (comp (for [node-id (get-val (address-of expr))]
                    (NoGraph (str node-id ":n")))
                  (for [_ se-nop
                        :let [node-id (gensym "app")]
                        _ (set-all-vals (address-of expr) node-id)
                        _ (push-env)
                        _ (set-val self node-id)]
                    (do
                      (println node-id (str "[label=\"@" ;; " " (mod (address-of expr) 1000)
                                            "\", ordering=out]"))
                      expr)))))

  (grph-up [expr]
    (for [node-id (get-val self)
          :let [tgt (.call-target expr)
                tgt-end (str node-id ":sw")
                arg-end (str node-id ":se")]
          _ (pop-env)]
      (do
        (println tgt-end "--" tgt)
        (map (.args expr) (fn [arg]
                            (println arg-end "--" arg)))
        (str node-id ":n")))))


(def core-env {(ast/tag 'church) church
               (ast/tag 'fresh) fresh
               (ast/tag 'print-err) print-err
               (ast/tag 'inc) inc
               (ast/tag 'dec) dec
               (ast/tag '+) +
               (ast/tag '-) -
               (ast/tag '*) *
               (ast/tag 'range) range
               (ast/tag 'cons) cons
               (ast/tag 'first) first
               (ast/tag 'rest) rest
               (ast/tag 'empty-list) empty-list
               (ast/tag 'list) list
               (ast/tag 'empty?) empty?
               (ast/tag 'nil) nothing
               (ast/tag '=) =
               (ast/tag 'bit-shift-right) bit-shift-right
               (ast/tag 'bit-and) bit-and
               (ast/tag 'grph) grph})

(defn eval-exprs [exprs]
  (let [defs (-> exprs
                 (filter (partial instance? ast/definition-ast))
                 (reduce core-env
                         (fn [defs def]
                           (either (-> (.value-exprs def)
                                       (remove (partial instance? ast/NoCode))
                                       last
                                       (map (fn [val-ast]
                                              (assoc defs (.sym def) val-ast))))
                                   defs))))
        global-fns (reduce (vec defs) {} (fn [m [s v]]
                                           (cond (or (instance? Fn v)
                                                     (instance? ast/fn-ast v))
                                                 (assoc m s (GlobalFn s))

                                                 m)))
        defs (map-vals defs (fn [def]
                              (either (instance? CoreType def)
                                      (cata (fn [s]
                                              (either (and (instance? ast/tagged-symbol s)
                                                           (get global-fns s))
                                                      s))
                                            def))))
        exprs (-> exprs
                  (remove (partial instance? ast/definition-ast))
                  (map (fn [expr]
                         (let [expr (cata (fn [s]
                                            (either (and (instance? ast/tagged-symbol s)
                                                         (get global-fns s))
                                                    s))
                                          expr)
                               fvs (-> (ast/free-syms expr)
                                       (dissoc (ast/tag (symbol "$1"))))]
                           (cata (fn [s]
                                   (either (and (instance? ast/tagged-symbol s)
                                                (get global-fns s)
                                                (maybe (fresh s)))
                                           s))
                                 expr)))))]
    (map exprs (fn [expr]
                 (let [start-time (sys/clock_gettime)
                       p (promise)]
                   (send redex-count (fn [_] 0))
                   (println "subgraph" (gensym "cluster") "{")
                   (println (str "graph [color=none, label=\"initial " _LINE_ "\"]"))
                   (grph expr defs)
                   (println "}")

                   (let [final (cata (fn [x]
                                       (copy x 2 {} identity))
                                     expr)
                         _ (do
                             (println "subgraph" (gensym "cluster") "{")
                             (println (str "graph [color=none, label=\"final " _LINE_ "\"]"))
                             (grph final defs)
                             (println "}"))
                         elapsed (sys/time-delta start-time (sys/clock_gettime))
                         _ (send redex-count (partial deliver p))
                         redexes (extract p)]
                     (print-err 'final _LINE_ final
                                "\n" (str elapsed ", " redexes))
                     (either (map (get defs (ast/tag (symbol "$1")))
                                  (fn [test-cnt]
                                    (println (str "comment=\"stats " test-cnt ", "
                                                  elapsed ", " redexes "\""))
                                    ;; (println (str "stats " test-cnt ", "
                                    ;;               elapsed ", " redexes))
                                    ))
                             '_)))))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more rdr/top-level)))

(main [args]
  (println "graph sharing {")
  (println "node [shape=none, height=0, width=0]"
           "\nedge [arrowhead=none]")
  (let [[_ file-name & cnt-str] args
        test-cnt (either (map (first cnt-str) str-to-int)
                         3)]
    (either (map (fio/file-in file-name)
                 (fn [file-in]
                   ;; if opened, parse and evaluate
                   (let [parse-result (parse-forms {'file-name file-name
                                                    'line-number 1}
                                                   (lazy-list file-in))]
                     (either (map (instance? rd/ParserError parse-result)
                                  (fn [r]
                                    (print-err (.msg r))
                                    (abort)))
                             (let [final (eval-exprs (comp [(ast/definition (ast/tag (symbol "$1"))
                                                              (list test-cnt))]
                                                           (.value parse-result)))
                                   ;; elapsed (sys/time-delta start-time (sys/clock_gettime))
                                   ;; _ (send redex-count (partial deliver p))
                                   ;; redexes (extract p)
                                   ]
                               ;; (print-err 'final _LINE_ final
                               ;;            "\n" (str test-cnt ", " elapsed ", " redexes))
                               ;; (println 'stats (str test-cnt ", " elapsed ", " redexes))
                               (print-err 'done)
                               )))))

            ;; or tell everyone it couldn't be
            (print-err str "Could not find/open " file-name))
    (println  "}\n")
    )
  (print-err 'done))
