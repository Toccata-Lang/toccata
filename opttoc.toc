
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "332c97a"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "03830a1"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))

(defn hylo-env [descend ascend env x]
  (let [[y new-env] (descend x env)]
    (ascend (map y (fn [inner-x]
                     (hylo-env descend ascend new-env inner-x)))
            new-env)))

(defprotocol Evaluation
  (pre-eval [ast env]
    [ast env])

  (eval [ast env]
    ;; (print-err 'ast _LINE_ ast
    ;;            "\n\n" 'env env)
    )

  (eval-bind [val binding env]
    (print-err 'binding-val _LINE_ (type-name val) val)
    (abort))

  (eval-app [f call env]
    (.call-target call f)))

(def CoreType (any-of Integer))

(extend-type Fn
  Container
  (map [f _] f)
  (map [f _ embed] (embed f))

  Evaluation
  (eval-app [f app-expr env]
    (let [new-args (map (.args app-expr) (fn [arg]
                                           (hylo-env pre-eval eval env arg)))]
      (cond (every new-args (partial instance? CoreType))
            (apply f new-args)

            (ast/call-ast f new-args))))

  (eval-bind [f binding env]
    (either (last (ast/simple-replace (.cont binding) {(.id binding) f}))
            (do
              (print-err 'compiler-error _FILE_ _LINE_)
              (abort))))

  (eval [f _]
    f))

(extend-type Integer
  Container
  (map [n _] n)
  (map [n _ embed]
    (embed n))

  Evaluation
  (eval [n _]
    n))

(extend-type Vector
  Evaluation
  (eval [ast env]
    ast))

(extend-type c/NoSymbol
  Evaluation
  (eval [x _]
    x))

(deftype Skip [expr]
  Stringable
  (string-list [_]
    (list "(Skip " (str expr) ")"))

  Container
  (map [e f]
    expr)

  (map [e f embed]
    (embed expr)))

(defn church [n]
  (let [fn-sym (ast/tag (symbol (str n)))
        param-x (ast/tag (gensym "px"))
        x (ast/tag (gensym "x"))
        y (ast/tag (gensym "y"))
        ;; dups (-> (range (.int n))
        ;;          (map (fn [n]
        ;;                 (ast/tag (symbol (str 'a (inc n))) loc)))
        ;;          vec)
        ]
    (ast/fn-ast fn-sym
                [(ast/fn-arity-ast
                  fn-sym
                  (ast/params [param-x])
                  ast/no-comment
                  [(ast/fn-ast c/no-symbol
                               [(ast/fn-arity-ast
                                 c/no-symbol
                                 (ast/params [y])
                                 ast/no-comment
                                 [(ast/binding-ast x param-x
                                                    [(reduce (range n) y
                                                             (fn [expr _]
                                                               (ast/call-ast x [expr])))])]
                                 {param-x 1})])]
                  {})])))

(extend-type ast/integer-ast
  Evaluation
  (eval [n env]
    (.int n)))

(extend-type ast/binding-ast
  Evaluation
  (pre-eval [ast env]
    [(.cont ast (either (instance? ast/binding-ast (.cont ast))
                        (Skip (.cont ast))))
     (dissoc-all env (ast/all-syms (.id ast)))])

  (eval-bind [expr binding env]
    (.expr binding expr))

  (eval [ast env]
    ;; (print-err 'eval-binding _LINE_ ast)
    (eval-bind (.expr ast) ast env)))

(extend-type ast/fn-arity-ast
  Evaluation
  (pre-eval [ast env]
    [ast (dissoc-all env (ast/all-syms (.params ast)))])

  (eval [ast env]
    ast))

(extend-type ast/fn-ast
  Evaluation
  (eval [ast _]
    ast)

  (eval-bind [f binding env]
    ;; todo: temporary hack. expand later
    ;; what if there are free-vars in some, all or none of the arities
    (either (last (ast/simple-replace (.cont binding) {(.id binding) f}))
            (do
              (print-err 'compiler-error _FILE_ _LINE_)
              (abort))))

  (eval-app [tgt call env]
    (let [args (.args call)
          arg-count (count args)]
      (either (for [arity (or (some (.arities tgt)
                                    (fn [arity]
                                      (and (= (count (.params arity)) arg-count)
                                           (maybe arity))))
                              (do
                                (print-err 'no-arity-found (ast/location call) arg-count
                                           "\n\n" tgt)
                                nothing))]
                (let [new-env (-> arity
                                  .params
                                  .fixed
                                  (zip-lists args)
                                  (reduce {} (fn [m [k v]]
                                               (assoc m k v))))
                      new-body (ast/simple-replace (.body arity) new-env)
                      r (either (last (hylo-env pre-eval eval env new-body))
                                call)]
                  ;; (print-err 'expr _LINE_ (.call-target call)
                  ;;            "\n\n" 'args (.args call)
                  ;;            "\n\n" 'env (keys env)
                  ;;            ;; "\n\n" 'new-env new-env
                  ;;            "\n\n" 'result r)
                  ;; (abort)
                  r))
              (.call-target call tgt)))))

(extend-type ast/call-ast
  Evaluation
  (pre-eval [ast env]
    [(.args ast (map (.args ast) Skip))
     env])

  (eval-bind [ast binding env]
    (.expr binding ast))

  (eval [expr env]
    (eval-app (.call-target expr) expr env)))

(extend-type ast/tagged-symbol
  Evaluation
  (eval-bind [s binding env]
    (.expr binding s))

  (eval [s env]
    (either (get env s)
             s)))

(def parse-forms
  (rd/parser
   (grmr/none-or-more rdr/top-level)))

(defn eval-expr [expr defs]
  (print-err 'expr _LINE_ expr)
  (let [new-expr (hylo-env pre-eval eval defs expr)]
    (either (= new-expr expr)
            (eval-expr new-expr defs))))

(def core-env {(ast/tag 'church) church
               (ast/tag 'inc) inc})

(defn eval-exprs [exprs]
  (let [defs (-> (.value exprs)
                 (filter (partial instance? ast/definition-ast))
                 (reduce core-env
                         (fn [defs def]
                           (either (-> (.value-exprs def)
                                       (remove (partial instance? ast/NoCode))
                                       last
                                       (map (fn [val-ast]
                                              (let [val (eval-expr val-ast defs)]
                                                (assoc defs (.sym def)
                                                       val)))))
                                   defs))))
        expr (either (last (remove (.value exprs)
                                   (partial instance? ast/definition-ast)))
                      ast/no-comment)]
    (eval-expr expr defs)))

(main [args]
  (let [[_ file-name] args]
    (either (map (fio/file-in file-name)
                 (fn [file-in]
                   ;; if opened, parse and evaluate
                   (let [parse-result (parse-forms {'file-name file-name
                                                    'line-number 1}
                                                   (lazy-list file-in))]
                     (either (map (instance? rd/ParserError parse-result)
                                  (fn [r]
                                    (print-err (.msg r))
                                    (abort)))
                             (eval-exprs parse-result)))))

            ;; or tell everyone it couldn't be
            (print-err str "Could not find/open " file-name)))
  (print-err 'done))
