
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "a09fe35"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "b5adb93"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))

(defprotocol Evaluation
  (eval [ast]
    (print-err 'ast _LINE_ ast)))

(extend-type ast/integer-ast
  Evaluation
  (eval [n]
    (let [loc (ast/location n)
          fn-sym (ast/tag (symbol (str n)) loc)
          x (ast/tag 'x loc)
          y (ast/tag 'y loc)
          ;; dups (-> (range (.int n))
          ;;          (map (fn [n]
          ;;                 (ast/tag (symbol (str 'a (inc n))) loc)))
          ;;          vec)
          ]
      (ast/fn-ast fn-sym
                  [(ast/fn-arity fn-sym
                                 (ast/params [x y])
                                 ast/no-comment
                                 [(reduce (range (.int n)) y
                                          (fn [expr _]
                                            (ast/call-ast x [expr])))])]))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (apply-to eval
              (grmr/any rdr/read-integer-literal
                        rdr/top-level)))))

(main [args]
  (let [[_ file-name] args]
    (either (map (fio/file-in file-name)
                 (fn [file-in]
                   ;; if opened, parse and evaluate
                   (let [parse-result (parse-forms {'file-name file-name
                                                    'line-number 1}
                                                   (lazy-list file-in))]
                     (map (instance? rd/ParserError parse-result)
                          (fn [_]
                            (print-err (.msg parse-result))
                            (abort))))))

            ;; or tell everyone it couldn't be
            (print-err str "Could not find/open " file-name)))
  (print-err 'done))
