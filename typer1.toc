
(add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
                           "free.toc"
                           :sha "5c353f2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "bf9b8c3"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "98e9c2e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "022bfa3"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4983c77"))
(add-ns b (module "base.toc"))

(def Tagged (any-of Symbol
                    ast/tagged-symbol))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(def output (agent 0))

(defn status [& msg]
  (send output (fn [_]
                 (apply print-err msg))))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply print-err args)
               ['_ s])))

(def invoke-sym (ast/tag 'invoke 'core 0))
(def get-field-sym (ast/tag 'get-field 'core 0))
(def Type-sym (ast/tag 'Type 'core 0))
(def Function-sym (ast/tag 'Function 'core 0))
(def Container-sym (ast/tag 'Container 'core 0))
(def Stringable-sym (ast/tag 'Stringable 'core 0))
(def type-name-sym (ast/tag 'type-name 'core 0))
(def type-mapping-sym (ast/tag 'type-mapping 'core 0))
(def =*-sym (ast/tag '=* 'core 0))
(def apply-sym (ast/tag 'apply 'core 0))
(def get-type-sym (ast/tag 'default-get-type 'core 0))
(def extract-sym (ast/tag 'extract 'core 0))
(def instance?-sym (ast/tag 'instance? 'core 0))
(def string-list-sym (ast/tag 'string-list 'core 0))
(def list-sym (ast/tag 'list 'core 0))
(def has-field-sym (ast/tag 'has-field 'core 0))
(def identical-sym (ast/tag 'identical 'core 0))
(def Eq-sym (ast/tag 'Eq 'core 0))
(def Associative-sym (ast/tag 'Associative 'core 0))
(def get-symb (ast/tag 'get 'core 0))
(def maybe-sym (ast/tag 'maybe 'core 0))
(def HashMapNode-sym (ast/tag 'HashMapNode 'core 0))
(def Hashable-sym (ast/tag 'Hashable 'core 0))
(def sha1-sym (ast/tag 'sha1 'core 0))
(def sha1-update-sym (ast/tag 'sha1-update 'core 0))
(def sha1-init-sym (ast/tag 'sha1-init 'core 0))
(def sha1-finalize-sym (ast/tag 'sha1-finalize 'core 0))
(def sha1-update-type-sym (ast/tag 'sha1-update-type 'core 0))
(def assoc-sym (ast/tag 'assoc 'core 0))
(def update-field-sym (ast/tag 'update-field 'core 0))
(def store-sym (ast/tag 'store 'core 0))
(def default-type-args-sym (ast/tag 'default-type-args 'core 0))
(def nth-sym (ast/tag 'nth 'core 0))
(def partial-sym (ast/tag 'partial 'core 0))
(def some-sym (ast/tag 'some 'core 0))
(def nothing-sym (ast/tag 'nothing 'core 0))

(deftype Closures [closures refs-map]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map)))

(def empty-closures (Closures [] {}))

(deftype FunctionArityContext [sym-count syms context-syms closed-over field-constrs]
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; constraints for fields in type-ast implementations
  (assert (instance? (maybe-of c/ListConstraint) field-constrs))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(def type-names {c/IntegerType "Integer"
                 c/StringBufferType "String"
                 c/SubStringType "String"
                 c/FnArityType "FnArity"
                 c/FunctionType "Fn"
                 c/ListType "List"
                 c/MaybeType "Maybe"
                 c/VectorType "Vector"
                 c/VectorNodeType "VectorNode"
                 c/SymbolType "Symbol"
                 c/BitmapIndexedType "BitmapIndexNode"
                 c/ArrayNodeType "ArrayNode"
                 c/HashCollisionNodeType "HashCollisionNode"
                 c/HashSetType "Set"
                 c/PromiseType "Promise"
                 c/FutureType "Future"
                 c/AgentType "Agent"
                 c/OpaqueType "Opaque"
                 c/UnknownType "UnknownType"})

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  (assert (instance? (map-of Integer String) numbers))
  ;; strings                static strings
  (assert (instance? (map-of String String) strings))
  ;; symbols                static symbols
  (assert (instance? (map-of Symbol String) symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? (map-of Integer String) type-names)))

;; There's a bunch of information to keep track of while checking a module
(deftype ModuleContext [fn-context module constants]
  ;; fn-context             context for the fn currently being checked
  (assert (instance? FunctionArityContext fn-context))
  ;; module                info for each module compiled
  (assert (instance? Module module))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))

  Stringable
  (string-list [_] (list "<ModuleContext "
                         (str module) ">")))

(def module-context (ModuleContext (FunctionArityContext 0 {} {} empty-closures nothing)
                                   (Module 'core 0 {} {} c/core-type-constraints empty-list)
                                   (ConstantValues {} {} {} type-names)))

;; Agent holds map of module file name to Module value
(def modules (agent {}))

;; Agent holds map of module file name to promise that will be delivered when module is loaded
(def loaders (agent {}))

(def type-counter (int-generator c/TypeCount))

(deftype PrototypeImpls [fn-sym impls]
  (assert (instance? Symbol fn-sym))
  (assert (instance? (map-of Integer HashMap) impls))

  Stringable
  (string-list [_]
    (list "(PrototypeImpls " (str fn-sym) "\n" (str impls) ")"))

  Container
  (map [x f]
    (PrototypeImpls fn-sym
                    (map-vals impls (fn [impl-fns]
                                      (map-vals impl-fns (fn [arities]
                                                           (map arities f)))))))

  (map [x f embed]
    (map (contextual-map-vals impls (fn [impl-fns]
                                      (contextual-map-vals impl-fns f embed))
                              embed)
         (partial PrototypeImpls fn-sym))))

(deftype CheckedCondVal [ast types]
  Stringable
  (string-list [_]
    (list "(CheckedCondVal " (str ast) "\n<types>)"))

  Container
  (map [_ f]
    (CheckedCondVal (f ast) (f types)))

  ;; (map [_ f embed]
  ;;   (map (f clause) OrClause))

  ast/FileLoc
  (ast/location [_]
    (ast/location ast)))

(deftype AndClause [clause]
  Stringable
  (string-list [_]
    (list "(AndClause " (str clause) ")"))

  Container
  (map [_ f]
    (AndClause (f clause)))

  (map [_ f embed]
    (map (f clause) AndClause))

  ast/FileLoc
  (ast/location [_]
    (ast/location clause)))

(deftype OrClause [clause]
  Stringable
  (string-list [_]
    (list "(OrClause " (str clause) ")"))

  Container
  (map [_ f]
    (OrClause (f clause)))

  (map [_ f embed]
    (map (f clause) OrClause))

  ast/FileLoc
  (ast/location [_]
    (ast/location clause)))

(deftype ParamConstraintPair [param constraint]
  (assert (instance? (any-of ast/BindingTarget
                             Symbol)
                     param))
  (assert (instance? c/ValueConstraint constraint))

  Stringable
  (string-list [_]
    (list "(ParamConstraintPair " (str param) " " (str constraint) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

;; TODO: use 'either' here
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(defn get-types []
  (se/get-in-val [.module .value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.module .value-types])
             (fn [types-list]
               (se/assoc-in-val [.module .value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.module .value-types])
             (fn [types-list]
               (se/assoc-in-val [.module .value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.module .value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.module .value-types])
            (fn [types-list]
              (se/assoc-in-val [.module .value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn set-type-constraint [sym constraint]
  (assert (instance? Tagged sym))
  (assert (instance? b/ConstrainedAST constraint))

  (se/update-in-val [.module .value-types]
                    (fn [types-list]
                      (let [sym (ast/untag sym)]
                        (either (map (first types-list)
                                     (fn [value-types]
                                       (cons (assoc value-types sym constraint)
                                             (rest types-list))))
                                (list {sym constraint}))))))

(defn get-core-type-constraint [sym]
  (assert (instance? Symbol sym))
  (se/new-se (fn [s]
               (either (or (map (get-in (extract modules) ['core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           (and (= 0 (.index (.module s)))
                                (get-in s [.module .value-types 0 sym]))
                           ;; last ditch effort
                           (let [core-prom (promise)]
                             ;; (status 'sending sym _LINE_)
                             (send modules (fn [mods]
                                             (deliver core-prom
                                                      (get-in mods ['core .value-types 0 sym]))
                                             mods))
                             (map (extract core-prom)
                                  (fn [expr]
                                    [expr s]))))
                       se/Failure))))

(defn add-getter [sym new-type-constraint types-list]
  (assert (instance? c/ReifiedConstraint new-type-constraint))
  (assert (instance? List types-list))

  ;; 'sym' already has ".' at front
  (let [loc (ast/location sym)
        sym (ast/untag sym)
        field-sym (c/Field sym)
        value-c (either (get-in new-type-constraint [.fields field-sym])
                        (do
                          (print-err "Compiler error at:" _FILE_ _LINE_
                                     "\n\n" 'sym sym
                                     "\n\n" 'new-type-constraint new-type-constraint)
                          (abort)))
        getter-field-c (c/ReifiedConstraint c/UnknownType {(c/Field sym) c/top-type}
                                            (symbol (str "field '" sym "' required"))
                                            (select-keys (.arities c/fn-constraint) [1 2])
                                            empty-list c/no-symbol "")
        getter-id (str "Default_" (rest (str sym)) "_getter")
        getter-ast (ast/fn-arity-ast (ast/tag sym)
                                     getter-id
                                     (ast/params [(ast/tag "#x")])
                                     ""
                                     []
                                     (-> c/empty-list-constraint
                                         (c/set-items [getter-field-c])
                                         (c/update-path loc))
                                     (c/ParamConstraint getter-id 0 [(c/get-field (c/Field sym))]
                                                        empty-list c/no-symbol ""))
        setter-id (str "Default_" (rest (str sym)) "_setter")
        setter-ast (ast/fn-arity-ast (ast/tag sym)
                                     setter-id
                                     (ast/params [(ast/tag "#x") (ast/tag "#y")])
                                     ""
                                     []
                                     (-> c/empty-list-constraint
                                         (c/set-items [getter-field-c value-c])
                                         (c/update-path loc))
                                     (-> (c/ParamConstraint setter-id 0 [] empty-list c/no-symbol "")
                                         (c/intersect new-type-constraint)
                                         (c/intersect (c/set-field field-sym
                                                                   (-> (c/ParamConstraint setter-id 1 []
                                                                                          empty-list c/no-symbol "")
                                                                       (c/intersect value-c))))))
        getter (b/ConstrainedAST (PrototypeImpls sym {c/UnknownType {1 getter-ast
                                                                     2 setter-ast}})
                                 (-> c/fn-constraint
                                     (.arities (.invoke-arities getter-field-c))
                                     (c/update-path loc)))
        Type-protocol (either (map (get-in types-list [0 'Type]) .ast)
                              (ast/protocol-ast Type-sym []))
        Type-protocol (-> Type-protocol
                          (.prototypes (comp (.prototypes Type-protocol)
                                             [(ast/prototype (ast/tag sym)
                                                             (ast/params [(ast/tag "#x")])
                                                             (ast/block-comment "" 0 []) [])
                                              (ast/prototype (ast/tag sym)
                                                             (ast/params [(ast/tag "#x") (ast/tag "#y")])
                                                             (ast/block-comment "" 0 []) [])]))
                          (b/ConstrainedAST c/top-type))]
    (either (map (first types-list)
                 (fn [value-types]
                   (-> value-types
                       (assoc sym getter)
                       (assoc 'Type Type-protocol)
                       (cons (rest types-list)))))
            (list {sym getter
                   'Type Type-protocol}))))

(defn create-new-getter [sym type-num new-type-constraint]
  ;; 'sym' already has ".' at front
  (let [loc (ast/location sym)]
    (for [mod-index (se/get-in-val [.module .index])
          _ (cond (= 0 mod-index)
                  (comp (se/get-in-val [.module .value-types 0 sym])
                        (for [_ (se/update-in-val [.module .value-types]
                                                  (partial add-getter sym new-type-constraint))
                              Type-protocol (se/get-in-val [.module .value-types 0 'Type])
                              getter (se/get-in-val [.module .value-types 0 (ast/untag sym)])
                              _ (se/update-in-val [.module .value-types]
                                                  (fn [types-list]
                                                    (map types-list
                                                         (fn [value-types]
                                                           (-> value-types
                                                               (assoc (ast/untag sym) getter)
                                                               (assoc 'Type Type-protocol))))))]
                          '_))

                  (do
                    (send modules
                          (fn [mods]
                            (either (or (and (get-in mods ['core .value-types 0 sym])
                                             (maybe mods))
                                        (map (get-in mods ['core .value-types])
                                             (fn [val-types]
                                               (assoc-in mods ['core .value-types]
                                                         (add-getter sym new-type-constraint val-types)))))
                                    mods)))
                    se-nop))]
      (b/ConstrainedAST sym (-> c/fn-constraint
                                (.arities (select-keys (.arities c/fn-constraint) [1 2]))
                                (c/update-path loc))))))

(defn get-type-constraint [sym]
  ;; TODO: make this work
  ;; (assert-result r (instance? (all-of se/new-se
  ;;                                     (contains b/ConstrainedAST))
  ;;                             r))
  (assert (instance? Tagged sym))

  (let [loc (ast/location sym)
        sym (ast/untag sym)]
    ;; TODO: this does not look up namespaced symbols
    (map (comp (se/get-in-val [.module .value-types 0 sym])
               (get-core-type-constraint sym)
               (cond (flat-map (first (str sym))
                               (partial = "."))
                     (create-new-getter (ast/tag sym loc) 0
                                        (c/ReifiedConstraint c/UnknownType {(c/Field sym) c/top-type}
                                                             (symbol (str "field " sym " required"))
                                                             {} empty-list c/no-symbol ""))

                     (compilation-error "Could not find type constraint for '" sym "' at " loc)))
         (fn [ast]
           (cond (instance? Tagged (.ast ast))
                 (.ast ast (ast/tag (.ast ast) loc))

                 ast)))))

(defn conflicting-assertions [failing-constraint loc]
  (to-str (list* "Conflicting assertions"
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(defn constrain-all-syms [tup]
  (assert (instance? ParamConstraintPair tup))

  (let [[param param-c] (type-args tup)
        loc (ast/location param)]
    (cond (instance? Tagged param)
          (-> param
              (set-type-constraint (b/ConstrainedAST param param-c))
              (map (fn [_]
                     tup)))

          (let [new-param-cs (-> param
                                 (.variadic (or (.variadic param)
                                                (maybe '_)))
                                 ast/new-param-constraints
                                 (c/intersect param-c))
                new-param-cs (either (or (= c/bottom-type new-param-cs)
                                         (and (instance? c/ReifiedConstraint param-c)
                                              (do
                                                ;; TODO: ?
                                                (print-err 'kablooie _FILE_ _LINE_)
                                                (abort)
                                                (maybe (ast/new-param-constraints param)))))
                                     new-param-cs)]
            (cond (= c/bottom-type new-param-cs)
                  (compilation-error (conflicting-assertions new-param-cs loc))

                  (let [curr-tail (c/extract-tail-constraint new-param-cs)
                        new-tail (cond (= curr-tail c/bottom-type)
                                       c/list-constraint
                                       (c/intersect c/list-constraint curr-tail))]
                    (-> (zip-lists (.fixed param) (c/extract-items-constraints new-param-cs
                                                                               (count (.fixed param))))
                        (map (fn [[x y]]
                               (ParamConstraintPair x y)))
                        vec
                        (comp (either (map (.variadic param)
                                           (fn [variadic]
                                             [(ParamConstraintPair variadic new-tail)]))
                                      []))
                        se/state-error)))))))

(defn remove-type-constraint [sym]
  (assert (instance? Tagged sym))
  (se/update-in-val [.module .value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types (ast/untag sym))
                                           (rest types-list))))
                              types-list))))

(defn append-type-constraint [sym constraint loc]
  (assert (instance? Tagged sym))
  (assert (instance? c/Constraints constraint))

  (cond (= constraint c/top-type)
        (map (se/try
               (get-type-constraint sym)
               (fn [_]
                 (se/state-error (b/ConstrainedAST sym c/top-type))))
             .constraint)

        (for [curr-const (se/try
                           (get-type-constraint sym)
                           (fn [_]
                             (se/state-error (b/ConstrainedAST sym c/top-type))))
              ;; TODO: this should get the full-param-constraint for 'constraint'
              ;; but that requires work to clean up fn-arity-ast 'pre-check' impl
              :let [new-const (c/trim (c/intersect (.constraint curr-const) constraint))
                    ;; _ (let [loc (ast/location sym)]
                    ;;     (or (= (.file loc) 'core)
                    ;;         (= (.line loc) 0)
                    ;;         (do
                    ;;           (print-err 'appending loc sym
                    ;;                      "\n" 'constraint constraint
                    ;;                      "\n\n" 'curr curr-const
                    ;;                      "\n\n" 'new-const new-const)
                    ;;           nothing)))
                    ]
              _ (cond (= new-const c/bottom-type)
                      (compilation-error (conflicting-assertions new-const loc))
                      (set-type-constraint sym (.constraint curr-const new-const)))]
          new-const)))

(defn impl-arities [impls]
  (for [[proto-sym impls] (vec impls)
        [fn-sym arities] (vec impls)
        arity arities]
    [proto-sym fn-sym (.fn-sym arity fn-sym)]))

(defn get-type-sym-info [type-symbol]
  (let [file-name (ast/file-name type-symbol)
        line-number (ast/line-number type-symbol)
        type-symbol (ast/untag type-symbol)]
    (comp (se/new-se (fn [s]
                       (either (map (or (get-in s [.module .types type-symbol])
                                        (get-in (extract modules) ['core .types type-symbol])
                                        ;; last ditch effort
                                        (let [core-prom (promise)]
                                          (status 'sending type-symbol _LINE_)
                                          (send modules (fn [mods]
                                                          (deliver core-prom
                                                                   (get-in mods ['core .types type-symbol]))
                                                          mods))
                                          (extract core-prom)))
                                        (fn [expr]
                                          [expr s]))
                               se/Failure)))
          (compilation-error "Invalid type" (str "'" type-symbol "'") "at"
                             (ast/location type-symbol)))))

(defn find-prototype [proto-sym fn-sym arg-count]
  (assert (instance? ast/tagged-symbol proto-sym))
  (assert (instance? ast/tagged-symbol fn-sym))

  (let [proto-sym (ast/untag proto-sym)
        fn-sym (ast/untag fn-sym)]
    ;; TODO: should make this all one big new-se
    ;; and use (get-in s [.module .value-types 0 fn-sym .ast .impls 0 arg-count])
    (comp (flat-map (comp (se/get-in-val [.module .value-types 0 proto-sym .ast .prototypes])
                          (se/new-se (fn [s]
                                       (either (or (map (get-in (extract modules)
                                                                ['core .value-types 0 proto-sym .ast .prototypes])
                                                        (fn [expr]
                                                          [expr s]))
                                                   ;; last ditch effort
                                                   (let [core-prom (promise)]
                                                     (status 'sending _LINE_)
                                                     (send modules
                                                           (fn [mods]
                                                             (deliver core-prom
                                                                      (get-in mods ['core .value-types 0 proto-sym
                                                                                    .ast .prototypes]))
                                                             mods))
                                                     (map (extract core-prom)
                                                          (fn [expr]
                                                            [expr s]))))
                                               se/Failure))))
                    (fn [prototypes]
                      (either (some prototypes
                                    (fn [prototype]
                                      (and (= (.fn-name prototype) fn-sym)
                                           (-> prototype
                                               .params
                                               .fixed
                                               count
                                               (= arg-count))
                                           (maybe (se/state-error prototype)))))
                              se/zero-se)))

          (compilation-error "Could not find prototype '" proto-sym "/" fn-sym "' " arg-count " "
                             _FILE_ " " _LINE_))))

(defn add-prototype-assertions [dispatch-type [proto-sym fn-sym arity]]
  (assert (instance? c/ListConstraint dispatch-type))

  (for [prototype (find-prototype proto-sym fn-sym (count (.fixed (.params arity))))
        :let [param-cs (c/intersect (.param-consts prototype)
                                    dispatch-type)
              param-cs (c/intersect param-cs
                                    (.param-consts arity))
              result-c (c/intersect (.result-const prototype)
                                    (.result-const arity))]
        _ (either (map (or (= c/bottom-type param-cs)
                           (= c/bottom-type result-c))
                       (fn [failure-c]
                         (do
                           (print-err 'throwing _LINE_)
                           (se/throw (conflicting-assertions failure-c (ast/location arity))))))
                  se-nop)]
    [proto-sym fn-sym (-> arity
                          (.param-consts (c/clear-sym param-cs))
                          (.result-const (c/clear-sym result-c)))]))

(defn update-constraint
  ([constrained constraint]
   (update-constraint constrained constraint
                      (c/Location "type checker testing" _LINE_)))

  ([constrained constraint loc]
   (assert (instance? b/ConstrainedAST constrained))
   (assert (instance? c/Constraints constraint))
   (assert (instance? c/Location loc))

   ;; TODO: need to check if 'sym' satisfies 'c'
   ;; and add runtime-check notation if not
   ;; (or (= (.line loc) 0)
   ;;     (= (.file loc) 'core)
   ;;     (do
   ;;       (print-err 'update-constraint loc
   ;;                  "\n\n" 'arg-ast (.ast constrained)
   ;;                  "\n\n" 'arg-c (.constraint constrained)
   ;;                  "\n\n" 'param constraint)
   ;;       nothing))
   (let [old-c (.constraint constrained)
         new-c (c/intersect old-c constraint)]
     ;; (or (= (.line loc) 0)
     ;;     (= (.file loc) 'core)
     ;;     (do
     ;;       (print-err 'update-constraint loc "\n"
     ;;                  'new new-c)
     ;;       nothing))
     (cond (= new-c c/bottom-type)
           (do
             ;; (print-err 'update-constraint loc
             ;;            "\n" 'old-c old-c
             ;;            "\n\n" 'constraint constraint
             ;;            "\n\n" 'new-c new-c)
             (compilation-error (conflicting-assertions new-c loc)))

           (let [new-c (c/update-path new-c loc)]
             (either (or (map (instance? Tagged (.ast constrained))
                              (fn [sym]
                                (map (append-type-constraint sym (c/update-path constraint loc) loc)
                                     (fn [orig-c]
                                       ;; (or (= (.line loc) 0)
                                       ;;     (= (.file loc) 'core)
                                       ;;     (do
                                       ;;       (print-err 'update-constraint 'sym sym loc
                                       ;;                  "\n" 'arg (.constraint constrained)
                                       ;;                  "\n\n" 'param constraint
                                       ;;                  "\n\n" 'orig-c orig-c
                                       ;;                  "\n\n" 'appended (c/trim (c/intersect orig-c constraint))
                                       ;;                  "\n\n" 'new new-c)
                                       ;;       nothing))
                                       (.constraint constrained new-c)))))

                         (for [dyn-c (instance? c/ParamConstraint old-c)
                               param-sym (c/extract-sym dyn-c)]
                           (let [param-c (c/full-param-constraint new-c)]
                             (cond (= c/bottom-type param-c)
                                   (do
                                     ;; (print-err 'update-constraint 'param-sym param-sym loc
                                     ;;            "\n" 'old-c old-c
                                     ;;            "\n\n" 'constraint constraint
                                     ;;            "\n\n" 'new-c new-c
                                     ;;            "\n\n" 'param-c param-c)
                                     (compilation-error (conflicting-assertions param-c loc)))

                                   (map (append-type-constraint param-sym param-c loc)
                                        (fn [orig-c]
                                          ;; (or (= (.line loc) 0)
                                          ;;     (= (.file loc) 'core)
                                          ;;     (do
                                          ;;       (print-err 'update-constraint 'param-sym param-sym loc
                                          ;;                  "\n" 'arg old-c
                                          ;;                  "\n\n" 'param constraint
                                          ;;                  "\n\n" 'new new-c
                                          ;;                  "\n\n" 'orig-c orig-c)
                                          ;;       nothing))
                                          (.constraint constrained new-c))))))

                         (for [call-ast (instance? ast/call-ast (.ast constrained))
                               :when (and (instance? Tagged (.call-target call-ast))
                                          (get #{'list 'vector 'maybe}
                                               (ast/untag (.call-target call-ast))))]
                           (let [loc (ast/location (.call-target call-ast))]
                             (-> (.args call-ast)
                                 (zip-lists (c/extract-items-constraints constraint
                                                                         (count (.args call-ast))))
                                 (se/traverse (fn [[arg c]]
                                                (update-constraint arg c loc)))
                                 (map (fn [_]
                                        (.constraint constrained new-c)))))))

                     (se/state-error (.constraint constrained new-c))))))))

(defprotocol TypeChecker
  ;; Mark this AST node as the final (or tail) expression in a function body
  (wrap-tail [ast params]
    (assert-result r (instance? Either r))

    ;; (Right ast)
    )

  (to-constraint [c]
    (se/state-error c))

  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (check-call-site [ast args target]
    (assert (instance? (vector-of b/ConstrainedAST) args))
    (assert-result x (instance? se/StateError x)))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (recover-type-constraint [x]
    (assert-result x (instance? se/StateError x))
    ;; (se/state-error x)
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (find-arity [ast type-num args-count]
    (assert-result r (instance? Maybe r)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast))

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    ;; (se/state-error ast)
    ))

(defn tail-call [ast params]
  (apo (fn [ast]
         (wrap-tail ast params))
       ast))

(defn all-syms [params]
  (assert (instance? ast/BindingTarget params))

  (cata all-symbols params))

(defn lookup-constraint [c]
  (hylo to-constraint (fn [x]
                        (se/state-error (c/trim x)))
        c se/state-error))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (ana recover-type-constraint params se/state-error))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (map (cata param-types params se/state-error)
       (fn [c]
         (let [c (c/trim c)]
           (-> c/list-constraint
               (c/set-items (c/extract-items-constraints c))
               (c/set-tail (c/extract-tail-constraint c)))))))

(def flag (agent nothing))

(defn type-check-ast [ast]
  (cond (= c/bottom-type ast)
        (do
          (se/throw (conflicting-assertions ast (ast/location ast))))

        (for [new-ast (pre-check ast)
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (extract flag)
              ;;              (maybe (print-err 'type-checking _LINE_ loc
              ;;                                "\n" 'ast ast
              ;;                                "\n\n" 'new-ast new-ast
              ;;                                "\n\n" 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and (extract flag)
            ;;        (maybe (print-err 'final-ast _LINE_ loc
            ;;                          "\n" final-ast))))
            final-ast))))

(defn add-prototype [type-num [proto-sym fn-sym arity]]
  (assert (instance? ast/tagged-symbol proto-sym))
  (assert (instance? ast/tagged-symbol fn-sym))

  (let [arg-count (count (.fixed (.ast (.params arity))))]
    ;; TODO: Finding the prototype and getting the assertions is probably redundant,
    ;; at least for actual 'extend-type' ast's
    (for [prototype (find-prototype proto-sym fn-sym arg-count)
          :let [proto-sym (ast/untag proto-sym)
                fn-sym (ast/untag fn-sym)
                param-cs (-> (.param-consts prototype)
                             (c/intersect (.param-consts arity))
                             (c/update-path (ast/location (.params arity))))
                result-c (c/intersect (.result-const prototype)
                                      (.result-const arity))
                new-arity (-> arity
                              (.param-consts param-cs)
                              (.result-const result-c))]
          _ (either (map (or (= c/bottom-type param-cs)
                             (= c/bottom-type result-c))
                         (fn [failure-c]
                           (do
                             (print-err 'throwing _LINE_)
                             (se/throw (conflicting-assertions failure-c (ast/location (.params arity)))))))

                    se-nop)
                
          _ (comp (for [_ (se/get-in-val [.module .value-types 0 proto-sym .ast .prototypes])
                        _ (se/update-in-val [.module .value-types]
                                            (fn [types-list]
                                              (map types-list
                                                   (fn [types]
                                                     (assoc-in types [fn-sym .ast .impls type-num arg-count]
                                                               new-arity)))))]
                    '_)
                  (map se-nop
                       (fn [_]
                         (send modules
                               (fn [mods]
                                 (either (and (get-in mods ['core .value-types 0 fn-sym .ast .impls])
                                              (update-in mods ['core .value-types]
                                                         (fn [val-types-list]
                                                           (map val-types-list
                                                                (fn [val-types]
                                                                  (assoc-in val-types [fn-sym .ast .impls
                                                                                       type-num arg-count]
                                                                            new-arity))))))
                                         mods)))
                         '_)))]
      [proto-sym fn-sym new-arity])))

(defn extend-prototypes [type-num impls]
  (se/traverse (impl-arities impls) (partial add-prototype type-num)))

(extend-type Integer
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (type-check [n _]
    (se/state-error (b/ConstrainedAST n (-> c/int-constraint
                                            (.static-value n))))))

(extend-type String
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (type-check [s _]
    (se/state-error (b/ConstrainedAST s (cata (fn [c]
                                              (cond (or (instance? c/StrBuffConstraint c)
                                                        (instance? c/SubStrConstraint c))
                                                    (.static-value c s)

                                                    c))
                                            c/string-constraint)))))

(extend-type Vector
  TypeChecker
  (wrap-tail [asts params]
    (Left (either (flat-map (last asts)
                            (fn [tail]
                              (store asts (dec (count asts))
                                     (tail-call tail params))))
                  asts)))

  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type HashMap
  TypeChecker
  (wrap-tail [m params]
    (Left (b/TailHashMap m)))

  (recover-type-constraint [x]
    (se/state-error x)))

;; TODO: these all need to return args with updated constraints to be put into
;; the call site
(def special-call-targets
  {})

(extend-type PrototypeImpls
  TypeChecker
  (check-call-site [proto-impls args target]
    (let [num-args (count args)
          arg-consts (b/remove-asts args)
          loc (ast/location target)]
      (either (map (first args)
                   (fn [disp-arg]
                     (let [type-num (c/get-type-num (.constraint disp-arg))
                           ;; TODO: if finite set of type-nums, build SumConstraint
]
                       (either (map (find-arity proto-impls type-num num-args)
                                    (fn [arity]
                                      ;; (or ;; (= (.line loc) 0)
                                      ;;     ;; (= (.file loc) 'core)
                                      ;;  (do
                                      ;;    (print-err 'call-proto _LINE_ loc (.fn-sym proto-impls)
                                      ;;               'type-num type-num 'arity-id (str "'" (.fn-var arity) "'")
                                      ;;               "\n" 'arity arity
                                      ;;               "\n\n" 'arity-result (.result-const arity)
                                      ;;               "\n\n" 'param-consts "\n" (str "[" (-> (.param-consts arity)
                                      ;;                                                      (c/extract-items-constraints num-args)
                                      ;;                                                      (interpose "\n")
                                      ;;                                                      to-str) "]")
                                      ;;               "\n\n" 'arg-consts "\n" (str "[" (to-str (interpose arg-consts "\n")) "]")
                                      ;;               "\n\n" 'arity-list (map (get-in proto-impls [.impls])
                                      ;;                                       keys))
                                      ;;    nothing))
                                      (-> (.param-consts arity)
                                          (c/reify-type-constraint (.fn-var arity) arg-consts loc)
                                          (c/extract-items-constraints num-args)
                                          (zip-lists args)
                                          vec
                                          (se/traverse (fn [[c arg]]
                                                         (for [
                                                               ;; _ (se/when
                                                               ;;       (or ;; (= (.line loc) 0)
                                                               ;;        ;; (= (.file loc) 'core)
                                                               ;;        (maybe (print-err 'call-proto _LINE_ loc target
                                                               ;;                          "\n\n" 'c c
                                                               ;;                          "\n\n" 'arg (.ast arg)
                                                               ;;                          "\n\n" 'arg-c
                                                               ;;                          (.constraint arg)))
                                                               ;;        (maybe '_)))
                                                               r (update-constraint arg c loc)]
                                                           r)))
                                          (flat-map (fn [args]
                                                      (either (map (get special-call-targets target)
                                                                   (fn [f]
                                                                     (f target arity args)))
                                                              (-> (.result-const arity)
                                                                  (c/update-path loc)
                                                                  se/state-error))))
                                          (map (fn [result-c]
                                                 (Left (let [r (c/reify-type-constraint result-c (.fn-var arity)
                                                                                        arg-consts loc)]
                                                         ;; (or ;; (= (.line loc) 0)
                                                         ;;  ;; (= (.file loc) 'core)
                                                         ;;  (print-err 'call-proto _LINE_ loc (.fn-sym proto-impls)
                                                         ;;             (str "'" (.fn-var arity))
                                                         ;;             "\n" 'arity-result (.result-const arity)
                                                         ;;             "\n\n" 'result-c result-c
                                                         ;;             "\n\n" 'arg-consts "\n" (str "[" (to-str (interpose arg-consts "\n")) "]")
                                                         ;;             "\n\n" 'final-c r))
                                                         r)))))))
                               (compilation-error "Could not find arity for" (str "'" (.fn-sym proto-impls) "'")
                                                  "with" num-args "arguments at" loc)))))
              (flat-map se-nop
                        (fn [_]
                          (print-err 'throwing _LINE_)
                          (print-err 'call-proto _LINE_ loc target
                                     "\n" 'proto-impls proto-impls
                                     "\n\n" 'args args)
                          (-> [(str "'" (.fn-sym proto-impls) "'") "requires at least one argument at" loc]
                              (interpose " ")
                              to-str
                              se/throw))))))

  (find-arity [proto-impls type-num arg-count]
    (or (get-in proto-impls [.impls type-num arg-count])
        (get-in proto-impls [.impls c/UnknownType arg-count])))

  (type-check [ast old-ast]
    ;; TODO: limit arities for fn-contraint
    (print-err 'arities _LINE_)
    (set-type-constraint (.fn-sym ast) (b/ConstrainedAST ast c/fn-constraint))))

(extend-type AndClause
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: when "(.clause ast)" is replaced by "clause", it blows up. Because 'update-constraint'
    ;; requires 'clause' be b/ConstrainedAST always, but that's only true when 'type-check' is called.
    ;; Need better error message.
    (let [loc (ast/location old-ast)]
      (for [new-clause (cond (instance? Tagged (.clause old-ast))
                             (update-constraint (b/ConstrainedAST (.clause old-ast) c/top-type)
                                                (c/update-path c/maybe-constraint loc)
                                                loc)

                             (update-constraint (.clause ast)
                                                (c/update-path c/maybe-constraint loc)
                                                loc))
            types (get-types)]
        (CheckedCondVal new-clause types)))))

(extend-type OrClause
  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (let [loc (ast/location old-ast)]
      (for [new-clause (cond (instance? Tagged (.clause old-ast))
                             (update-constraint (b/ConstrainedAST (.clause old-ast) c/top-type)
                                                (c/update-path c/maybe-constraint loc)
                                                loc)

                             (update-constraint (.clause ast)
                                                (c/update-path c/maybe-constraint loc)
                                                loc))
            types (pop-types)]
        (CheckedCondVal new-clause types)))))

(extend-type b/TypeExtension
  TypeChecker
  (type-check [ast old-ast]
    (for [_ (extend-prototypes (c/get-type-num (.type-constraint ast)) (.impls ast))]
      ast)))

(extend-type b/TailCond
  TypeChecker
  (type-check [ast old-ast]
    (let [conditionals (map (.conditionals ast) .ast)]
      (either (map (first conditionals)
                   (fn [first-cond]
                     (for [_ (pop-types)
                           _ (push-types (.types (.conditional first-cond)))
                           result-c (se/try
                                      (map (get-type-constraint (symbol "#result")) .constraint)
                                      (fn [_]
                                        (se/state-error c/top-type)))
                           _ (se/traverse conditionals
                                          (fn [cond-val]
                                            (for [_ (update-constraint (.ast (.conditional cond-val))
                                                                       (-> c/maybe-constraint
                                                                           (c/update-path (ast/location cond-val)))
                                                                       (ast/location cond-val))
                                                  _ (update-constraint (.value cond-val) result-c
                                                                       (ast/location cond-val))]
                                              '_)))
                           _ (update-constraint (.default ast) result-c (ast/location (.default ast)))]
                       (b/ConstrainedAST ast
                                         (-> (.conditionals ast)
                                             (map .constraint)
                                             (conj (.constraint (.default ast)))
                                             c/sum-type
                                             (c/intersect result-c))))))
              (se/state-error (b/ConstrainedAST ast (.constraint (.default ast))))))))

(extend-type b/TailEither
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clause (OrClause (.clause ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          _ (push-types (.types (.clause ast)))
          :let [new-clause (.ast (.clause ast))]
          result-c (se/try
                     (map (get-type-constraint (symbol "#result")) .constraint)
                     (fn [_]
                       (se/state-error c/top-type)))
          new-clause (update-constraint new-clause
                                        (c/intersect (c/InferredInner result-c empty-list c/no-symbol "")
                                                     (-> c/maybe-constraint
                                                         (c/update-path (ast/location new-clause))))
                                        (ast/location new-clause))
          new-alt (update-constraint (.alt ast) result-c (ast/location (.alt ast)))]
      (-> ast
          (.clause new-clause)
          (.alt new-alt)
          (b/ConstrainedAST (-> (c/sum-type [(c/extract-contents-constraint (.constraint new-clause))
                                           (.constraint (.alt ast))])
                              (c/update-path (ast/location old-ast))))))))

(extend-type b/TailAnd
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)]
      (flat-map (append-type-constraint (ast/tag (symbol "#result") loc)
                                        (c/update-path c/maybe-constraint loc)
                                        loc)
                (fn [_]
                  (pre-check (ast/and-ast (.clauses ast))))))))

(extend-type b/TailOr
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clauses (map (.clauses ast) OrClause))
        se/state-error))

  (type-check [ast old-ast]
    (let [loc (either (map (first (.clauses old-ast))
                           ast/location)
                      (ast/location old-ast))]
      (either (map (first (.clauses ast))
                   (fn [first-clause ]
                     (for [_ (pop-types)
                           _ (push-types (.types first-clause))
                           ;; TODO: when the ast of the first clause is a call to instance?,
                           ;; recover the type of the symbol in the second arg
                           _ (append-type-constraint (symbol "#result")
                                                     (c/update-path c/maybe-constraint loc)
                                                     loc)
                           result-c (se/try
                                      (map (get-type-constraint (symbol "#result")) .constraint)
                                      (fn [_]
                                        (se/state-error (c/update-path c/maybe-constraint loc))))
                           new-clauses (se/traverse (.clauses ast)
                                                    (fn [checked-clause]
                                                      (let [clause (.ast checked-clause)]
                                                        (update-constraint clause result-c (ast/location clause)))))]
                       (b/ConstrainedAST (ast/or-ast new-clauses)
                                       (-> new-clauses
                                           (map .constraint)
                                           c/sum-type
                                           (c/intersect result-c)
                                           (c/update-path (cata ast/location old-ast)))))))
              (do
                (print-err "Compiler error at" _FILE_ _LINE_)
                (abort)
                se-nop)))))

(extend-type b/TailHashMap
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: finish when we can extract a constraint describing a literal hash-map
    (se/state-error (b/ConstrainedAST ast c/top-type))))

(extend-type b/TailExpr
  TypeChecker
  (type-check [ast old-ast]
    (for [result-c (se/try
                     (map (get-type-constraint (symbol "#result")) .constraint)
                     (fn [_]
                       (se/state-error c/top-type)))
          new-inner (update-constraint (.ast ast) result-c (ast/location old-ast))]
      (b/ConstrainedAST (.ast ast new-inner)
                      (.constraint new-inner)))))

(extend-type b/TailCall
  TypeChecker
  (type-check [ast old-ast]
    (let [loc (ast/location old-ast)]
      (for [result-c (se/try
                       (map (get-type-constraint (symbol "#result")) .constraint)
                       (fn [_]
                         (se/state-error c/top-type)))
            new (update-constraint (.ast ast) result-c loc)]
        new))))

(extend-type b/ConstrainedAST
  TypeChecker
  (find-arity [ast type-num n]
    (or (find-arity (.constraint ast) type-num n)
        (find-arity (.ast ast) type-num n)))

  (check-call-site [ast args target]
    (flat-map se-nop (fn [_]
                       (comp (check-call-site (.constraint ast) args target)
                             ;; TODO: would really like to remove this clause
                             (check-call-site (.ast ast) args target))))))

(extend-type b/ConstrainedSum
  TypeChecker
  (type-check [c old-c]
    (let [new-c (-> (map (.alts c) .constraint)
                    c/sum-type
                    (.path (.path c))
                    (.sym (.sym c))
                    (.var (.var c)))]
      (map (either (map (c/extract-sym old-c)
                        (fn [sym]
                          (append-type-constraint sym new-c (ast/location old-c))))
                   se-nop)
           (fn [_]
             (b/ConstrainedAST new-c new-c))))))

(extend-type b/CondValCond
  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (for [new-clause (update-constraint (.clause ast) (-> c/maybe-constraint
                                                          (c/update-path (ast/location ast)))
                                        (ast/location ast))
          types (get-types)]
      (CheckedCondVal new-clause types))))

(extend-type b/CondValVal
  TypeChecker
  (type-check [ast old-ast]
    (for [_ (pop-types)]
      (.clause ast))))

(extend-type b/ImplFnArity
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (gensym "fn-arity")
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            result-c (se/try
                       (map (get-type-constraint (.fn-sym ast))
                            (fn [got]
                              (let [arity (find-arity got 0 arg-count)
                                    result-c (either (map arity .result-const)
                                                     c/top-type)]
                                result-c)))
                       (fn [_]
                         (se/state-error c/top-type)))

            _ (set-type-constraint (symbol "#result") (b/ConstrainedAST (symbol "#result") result-c))
            _ (ana constrain-all-syms (ParamConstraintPair (.params ast)
                                                           (.param-consts ast))
                   se/state-error)
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   ;; TODO: have to deal with this as well
                                   se-nop

                                   (append-type-constraint sym
                                                           (-> (c/ParamConstraint arity-id index []
                                                                                  empty-list (ast/untag sym) "")
                                                               (c/update-path loc))
                                                           loc))))]
        (let [body (comp (map (.fields ast)
                              (fn [field]
                                (-> (c/ParamConstraint arity-id 0
                                                       [(c/get-field (c/Field (symbol (str "." field))))]
                                                       empty-list field "")
                                    (c/update-path loc))))
                         (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast))
                             (tail-call [])))]
          (ast/fn-arity-ast (.fn-sym ast) arity-id (.params ast) (.doc ast) body
                            (.param-consts ast) result-c)
          ;; (-> ast
          ;;     (.fn-var arity-id)
          ;;     (.body body))
          ))))

  ;; TODO: remove when sure not needed
  ;; (type-check [ast old-ast]
  ;;   (for [orig-pts (get-param-types (.params old-ast))
  ;;         _ (recover-type-constraint (symbol "#result"))
  ;;         _ (recover-types (.params old-ast))
  ;;         _ (recover-types (ast/params-ast (.fields ast) nothing))
  ;;         _ (nip-types)]
  ;;     (let [loc (ast/location old-ast)
  ;;           result-c (-> (either (map (last (.body ast)) .constraint)
  ;;                                c/top-type)
  ;;                        (c/intersect (.result-const ast)))
  ;;           _ (and (= "test.toc" (.file loc))
  ;;                  (do
  ;;                    (print-err 'result-c _LINE_ result-c)
  ;;                    (print-err 'last-body _LINE_ (map (last (.body ast)) .constraint))
  ;;                    (print-err 'result-const _LINE_ (.result-const ast))
  ;;                    nothing))
  ;;           _ (cond (= c/bottom-type result-c)
  ;;                   (do
  ;;                     (print-err 'crapola result-c)
  ;;                     (print-err 'at _LINE_)
  ;;                     (abort))
  ;;                   '_)
  ;;           pts (-> orig-pts
  ;;                   (c/intersect (.param-consts ast))
  ;;                   (c/update-path loc))]
  ;;       (either (map (= c/bottom-type pts)
  ;;                    (fn [failure-c]
  ;;                      (c/conflicting-assertions failure-c (.file loc) (.line loc))
  ;;                      (print-err 'at _LINE_)
  ;;                      (abort)))
  ;;               (ast/fn-arity-ast (.fn-sym ast) (.fn-var ast) (.params ast) (.doc ast) (.body ast)
  ;;                                 pts result-c)))))
  )

(extend-type c/Constraints
  TypeChecker
  (pre-check [c]
    (lookup-constraint c))

  (check-call-site [ast args target]
    ;; (print-err 'not-checking (type-name ast))
    se/zero-se))

(extend-type c/GetField
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error (b/ConstrainedAST ast ast))))

(extend-type c/Field
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error (b/ConstrainedAST ast ast))))

(extend-type c/GetField
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error (b/ConstrainedAST ast ast))))

(extend-type c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (let [c (b/remove-asts c)]
      (map (either (map (c/extract-sym old-c)
                        (fn [sym]
                          (flat-map (get-type-constraint sym)
                                    (fn [_]
                                      (append-type-constraint sym c (ast/location old-c))))))
                   se-nop)
           (fn [_]
             (b/ConstrainedAST c c))))))

(extend-type c/InferredInner
  TypeChecker
  (promote-inferred [c]
    (c/extract-coll-constraint c)))

(extend-type c/AllValues
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error (b/ConstrainedAST ast ast))))

(extend-type c/ModSeqType
  TypeChecker
  (type-check [c old-c]
    (for [base-c (map (get-type-constraint (.base-sym old-c)) .constraint)
          :let [new-c (c/intersect c base-c)]
          _ (cond (= c/bottom-type new-c)
                  (do
                    (print-err 'throwing _LINE_)
                    (se/throw (conflicting-assertions new-c (ast/location old-c))))

                  se-nop)]

      (b/ConstrainedAST new-c new-c))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    (get-type-constraint (.param-sym old-c))))

(extend-type c/InnerTypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    (map (get-type-constraint (.param-sym old-c))
         (fn [const-c]
           ;; (let [loc (ast/location (.param-sym old-c))]
           ;;   (or (= (.line loc) 0)
           ;;       (do
           ;;         (print-err 'getting-inner (.constraint const-c))
           ;;         (print-err 'inner (c/extract-contents-constraint (.constraint const-c)))
           ;;         nothing)))
           (let [inner-c (c/extract-contents-constraint (.constraint const-c))]
             (b/ConstrainedAST inner-c inner-c))))))

(extend-type c/ArgOf
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location (.fn-sym old-c))]
      (for [fn-c (get-type-constraint (.fn-sym old-c))]
        (let [r (c/intersect (.constraint fn-c) c)]
          (b/ConstrainedAST r r))))))

(extend-type c/ResultOf
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location (.fn-sym old-c))]
      (for [fn-c (get-type-constraint (.fn-sym old-c))]
        (let [r (c/intersect (.constraint fn-c)
                             (c/CallValue c/no-args (.path c) (.sym c) (.var c)))]
          (b/ConstrainedAST r r))))))

(extend-type c/ParamConstraint
  TypeChecker
  (pre-check [ast]
    (append-type-constraint (.sym ast) ast (ast/location ast))))

(extend-type c/SumConstraint
  TypeChecker
  (type-check [c old-c]
    (let [new-c (-> (map (.alts c) .constraint)
                    c/sum-type
                    (.path (.path c))
                    (.sym (.sym c))
                    (.var (.var c)))]
      (map (either (map (c/extract-sym old-c)
                        (fn [sym]
                          (append-type-constraint sym new-c (ast/location old-c))))
                   se-nop)
           (fn [_]
             (b/ConstrainedAST new-c new-c))))))

(extend-type c/ResultConstraint
  TypeChecker
  (pre-check [c]
    (se/state-error (c/update-sym c (symbol "#result"))))

  (type-check [c old-c]
    (let [rc (.constraint (.assertion c))]
      (for [_ (append-type-constraint (symbol "#result") rc (ast/location old-c))]
        (b/ConstrainedAST (c/ResultConstraint rc) rc)))))

(extend-type c/fn-arity
  TypeChecker
  (check-call-site [arity args target]
    ;; (or (= (.line loc) 0)
    ;;     (= (.file loc) 'core)
    ;;     (maybe (print-err 'checking-fn-constraint _LINE_ target loc
    ;;                       "\n" 'ast ast
    ;;                       "\n\n" 'arity arity
    ;;                       "\n\n" 'result-c (.result-const arity)
    ;;                       "\n\n" 'args args
    ;;                       "\n\n" 'arg-count arg-count))
    ;;     (maybe '_))
    (let [loc (ast/location target)
          arg-consts (b/remove-asts args)
          arg-count (count args)
          required-args (-> (.param-consts arity)
                            c/extract-items-constraints
                            count)]
      (cond (< arg-count required-args)
            (compilation-error "Insufficient number of arguments to function called at" loc)

            (let [[fixed-args var-args] (split arg-consts required-args)
                  var-args (-> c/list-constraint
                               (.items var-args)
                               (.tail-c c/bottom-type))
                  fixed-params (-> (.param-consts arity)
                                   c/extract-items-constraints
                                   (map (fn [c]
                                          (c/reify-type-constraint c (.arity-id arity)
                                                                   (conj fixed-args var-args)
                                                                   loc))))
                  var-params (either (= (.tail-c (.param-consts arity)) c/bottom-type)
                                     (-> (.tail-c (.param-consts arity))
                                         (c/reify-type-constraint (.arity-id arity)
                                                                  (conj fixed-args var-args)
                                                                  loc)))
                  arg-cs (-> c/list-constraint
                             (.items fixed-args)
                             (.tail-c var-args))
                  param-cs (-> c/list-constraint
                               (.items fixed-params)
                               (.tail-c var-params))
                  checked-args (c/intersect arg-cs param-cs)]
              (for [new-arg-cs (cond (= c/bottom-type checked-args)
                                     (compilation-error (conflicting-assertions checked-args loc))

                                     (se/state-error (c/extract-items-constraints checked-args
                                                                                  arg-count)))
                    _ (se/traverse (zip-lists new-arg-cs args)
                                   (fn [[c arg]]
                                     (update-constraint arg
                                                        (c/reify-type-constraint c (.arity-id arity)
                                                                                 new-arg-cs loc)
                                                        loc)))]
                (let [[fixed-args variadic-args] (split new-arg-cs required-args)
                      param-cs (conj fixed-args
                                     (-> c/list-constraint
                                         (.items variadic-args)
                                         (.tail-c c/bottom-type)))
                      r (either (map (and (= target 'show-type)
                                          (first new-arg-cs))
                                     (fn [c]
                                       (apply print-err (map (cata c/show-full (c/update-path c loc))
                                                             (partial str  "\n  ")))
                                       c))
                                (-> (.result-const arity)
                                    (c/update-path loc)
                                    (c/reify-type-constraint (.arity-id arity) param-cs loc)))]
                  ;; (or ;; (= (.line loc) 0)
                  ;;     ;; (= (.file loc) 'core)
                  ;;     (do
                  ;;       (print-err 'call-fn target (.arity-id arity) loc
                  ;;                  "\n" 'args (-> args
                  ;;                                 b/remove-asts
                  ;;                                 (interpose  "\n")
                  ;;                                 vec)
                  ;;                  "\n\n" 'result-const (.result-const arity)
                  ;;                  "\n\n" 'fn-result r)
                  ;;       nothing))
                  (Left r))))))))

(extend-type c/FnConstraint
  TypeChecker
  (find-arity [c type-num args-count]
    (or (get-in c [.arities args-count])
        (get-in c [.arities c/variadic])))

  (check-call-site [ast args target]
    (either (map (find-arity ast 0 (count args))
                 (fn [arity]
                   (check-call-site arity args target)))

            (cond (empty? (.arities ast))
                  se/zero-se

                  (flat-map se-nop
                            (fn [_]
                              ;; (print-err 'target _LINE_ target
                              ;;            "\n" 'ast ast
                              ;;            "\n\n" 'arity arity
                              ;;            "\n\n" 'result-c (either (map arity .result-const)
                              ;;                                     'not-found)
                              ;;            "\n\n" 'args args
                              ;;            "\n\n" 'arg-count arg-count)
                              (compilation-error "Could not find arity for function call at"
                                                 (ast/location target))))))))

(extend-type c/ReifiedConstraint
  TypeChecker
  (find-arity [c type-num args-count]
    (or (get (.invoke-arities c) args-count)
        (get (.invoke-arities c) c/variadic)))

  (check-call-site [ast args target]
    (let [args (comp [(b/ConstrainedAST ast ast)] args)]
      (either (map (find-arity ast 0 (count args))
                   (fn [arity]
                     (check-call-site arity args target)))

              (flat-map se-nop
                        (fn [_]
                          ;; (print-err 'target _LINE_ target
                          ;;            "\n" 'ast ast
                          ;;            "\n\n" 'arity arity
                          ;;            "\n\n" 'result-c (either (map arity .result-const)
                          ;;                                     'not-found)
                          ;;            "\n\n" 'args args
                          ;;            "\n\n" 'arg-count arg-count)
                          (compilation-error "Could not find arity for function call at"
                                             (ast/location target))))))))

(extend-type Tagged
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (param-types [sym]
    (flat-map (map (get-type-constraint sym) .constraint)
              (fn [c]
                (either (map (instance? c/ParamConstraint c)
                             (fn [c]
                               (let [param-c (c/full-param-constraint c)]
                                 (cond (= c/bottom-type param-c)
                                       (compilation-error (conflicting-assertions param-c (ast/location sym)))

                                       (se/state-error c)))))
                        (se/state-error c)))))

  (find-arity [_ type-num n]
    (maybe (ast/fn-arity-ast (ast/tag 'anon)
                             ""
                             (ast/params-ast (vec (repeat n '_)) nothing)
                             (ast/block-comment "" 0 [])
                             []
                             (-> c/empty-list-constraint
                                 (c/set-items (vec (repeat n c/top-type))))
                             c/top-type)))

  (check-call-site [ast args target]
    (map (get-type-constraint ast)
         (fn [c-ast]
           (assert (instance? b/ConstrainedAST c-ast))

           ;; (let [loc (ast/location ast)]
           ;;   (or (= (.line loc) 0)
           ;;       (= (.file loc) 'core)
           ;;       (do
           ;;         (print-err 'called ast loc)
           ;;         (print-err  c-ast)
           ;;         (print-err 'args args)
           ;;         (print-err 'target target)
           ;;         nothing)))
           (cond (instance? c/ParamConstraint (.constraint c-ast))
                 (Left (c/intersect (.constraint c-ast)
                                    (-> (c/CallValue (map args b/remove-asts) empty-list (ast/untag target) "")
                                        (c/update-path (ast/location target)))))

                 ;; TODO: seems to be called on recursive calls.
                 ;; return the #result constraint
                 (let [loc (ast/location ast)]
                   ;; (or (= (.file loc) 'core)
                   ;;     (= (.line loc) 0)
                   ;;     (do
                   ;;       (print-err 'called ast loc)
                   ;;       (print-err  c-ast)
                   ;;       (print-err 'args args)
                   ;;       (print-err 'target target)
                   ;;       nothing))
                   (Right c/top-type))))))

  (recover-type-constraint [sym]
    (flat-map (se/get-in-val [.module .value-types])
              (fn [types-list]
                (assert (instance? List types-list))
                (either (for [value-types (nth types-list 1)
                              prev-constraint (get value-types (ast/untag sym))]
                          (set-type-constraint sym prev-constraint))
                        (remove-type-constraint sym)))))

  (type-check [s old-s]
    (get-type-constraint s)))

(extend-type ast/tagged-symbol
  TypeChecker
  (all-symbols [ast]
    [ast]))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (set-type-constraint (symbol "#result") (b/ConstrainedAST (symbol "#result") c/top-type))
          _ (se/traverse (all-syms (.params ast))
                         (fn [sym]
                           (set-type-constraint sym (b/ConstrainedAST sym c/top-type))))]
      ast))

  (type-check [ast old-ast]
    (for [pts (get-param-types (.params old-ast))
          result-c (se/try
                     (get-type-constraint (symbol "#result"))
                     (fn [_]
                       (se/state-error (b/ConstrainedAST (symbol "#result") c/top-type))))
          _ (remove-type-constraint (symbol "#result"))
          _ (recover-types (.params old-ast))
          _ (nip-types)]
      (-> ast
          (.result-const (.constraint result-c))
          (.param-consts pts)))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/params-ast
  TypeChecker
  (all-symbols [params]
    (comp* (either (.variadic params)
                   [])
           (seq (.fixed params))))

  (recover-type-constraint [x]
    (se/state-error x))

  (param-types [params]
    (-> c/seq-constraint
        (c/set-tail (either (.variadic params)
                            c/bottom-type))
        (c/set-items (.fixed params))
        se/state-error))

  (type-check [ast old-ast]
    (either (map (.variadic old-ast)
                 (fn [var-sym]
                   (for [_ (append-type-constraint var-sym c/list-constraint (ast/location var-sym))]
                     (b/ConstrainedAST old-ast c/top-type))))
            (se/state-error (b/ConstrainedAST old-ast c/top-type)))))

(extend-type ast/inline-ast
  TypeChecker
  (wrap-tail [ast params]
    (Left (b/TailExpr ast)))

  (type-check [ast old-ast]
    (for [c (lookup-constraint (.result-type ast))]
      (b/ConstrainedAST (.result-type ast c) c))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or (= (.line loc) 0)
    ;;       ;; (= (.file loc) 'core)
    ;;       (do
    ;;         (print-err 'checking ast)
    ;;         nothing)))
    (for [_ (push-types)]
      (.value-exprs ast (-> (.value-exprs ast)
                            (remove (partial instance? ast/block-comment-ast))
                            (map (fn [inner-ast]
                                   (cond (instance? ast/fn-ast inner-ast)
                                         (.fn-sym inner-ast (maybe (.sym ast)))

                                         (instance? c/SumConstraint inner-ast)
                                         (b/ConstrainedSum (.alts inner-ast) (.path inner-ast)
                                                           (ast/untag (.sym ast)) (.var inner-ast))

                                         inner-ast)))))))

  (type-check [ast old-ast]
    (let [constrained (either (last (.value-exprs ast))
                              (b/ConstrainedAST c/top-type c/top-type))
          loc (ast/location (.sym old-ast))]
      (for [_ (pop-types)
            _ (either (map (instance? c/Constraints (.ast constrained))
                           (fn [constraint]
                             (for [;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                   ;; the updated version. Possibly a bug in assoc-in*
                                   _ (se/assoc-in-val [.module .types (ast/untag (.sym old-ast))]
                                                      constraint)
                                   _ (set-type-constraint (.sym old-ast)
                                                          (b/ConstrainedAST constraint constraint))]
                               '_)))
                      (set-type-constraint (.sym old-ast) constrained))]
        constrained))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (gensym "fn-arity")
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (or (= (.line loc) 0)
            ;;             (= (.file loc) 'core)
            ;;             (do
            ;;               (print-err 'pre-fn-arity (.fn-sym ast) loc
            ;;                          "\n" 'params (.params ast)
            ;;                          "\n\n" 'old-param-cs (.param-consts ast)
            ;;                          "\n\n" 'body (.body ast)
            ;;                          "\n\n" 'result-const (.result-const ast))
            ;;               nothing))]
            result-c (se/try
                       (map (get-type-constraint (.fn-sym ast))
                            (fn [got]
                              (assert (instance? b/ConstrainedAST got))
                              (let [arity (find-arity (.ast got) 0 arg-count)
                                    result-c (either (map arity .result-const)
                                                     c/top-type)]
                                result-c)))
                       (fn [_]
                         (se/state-error c/top-type)))

            _ (set-type-constraint (symbol "#result") (b/ConstrainedAST (symbol "#result") result-c))
            _ (ana constrain-all-syms (ParamConstraintPair (.params ast)
                                                           (.param-consts ast))
                   se/state-error)
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   ;; TODO: have to deal with this as well
                                   se-nop

                                   (append-type-constraint sym
                                                           (-> (c/ParamConstraint arity-id index []
                                                                                  empty-list (ast/untag sym) "")
                                                               (c/update-path loc))
                                                           loc))))
            _ (either (map (.variadic (.params ast))
                           (fn [variadic-sym]
                             (append-type-constraint variadic-sym
                                                     (-> (c/ParamConstraint arity-id arg-count []
                                                                            empty-list
                                                                            (ast/untag variadic-sym) "")
                                                         (c/update-path loc))
                                                     loc)))
                      se-nop)]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast))
                             (tail-call []))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))
    
    (let [loc (ast/location old-ast)]
      (for [orig-pts (get-param-types (.params old-ast))
            _ (recover-type-constraint (symbol "#result"))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            ;; :let [_ (or (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;             (and (or (= "vector" (str (.fn-sym ast)))
            ;;                      (= "vec" (str (.fn-sym ast))))
            ;;                  (do
            ;;                    (print-err 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                               "\n" 'orig-pts orig-pts)
            ;;                    nothing)))]
            :let [pts (-> orig-pts
                          (c/intersect (.param-consts ast))
                          (c/update-path loc)
                          (map (fn [param-c]
                                 (either (map (instance? c/DebugConstraint param-c)
                                              (fn [c]
                                                (apply print-err (show c))
                                                (.constraint c)))
                                         param-c))))
                  result-c (-> (either (map (last (.body ast)) .constraint)
                                       c/top-type)
                               (c/intersect (.result-const ast)))
                  result-c (either (map (instance? c/DebugConstraint result-c)
                                        (fn [c]
                                          (apply print-err (cons "Result type" (drop (show c) 2)))
                                          (.constraint c)))
                                   result-c)]
            r (either (map (or (= c/bottom-type pts)
                               (= c/bottom-type result-c))
                           (fn [failure-c]
                             (compilation-error (conflicting-assertions failure-c loc))))
                      (-> ast
                          (.result-const result-c)
                          (.param-consts pts)
                          se/state-error))]
        r))))

(extend-type ast/fn-ast
  TypeChecker
  (wrap-tail [x params]
    (Left (b/TailCall x params)))

  (check-call-site [ast args target]
    (map se-nop (fn [_]
                  (status 'fn-ast 'check-call-site target (ast/location target)
                          "\n" ast)
                  c/top-type)))

  (pre-check [ast]
    (let [loc (ast/location ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) 'core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  "\n" ast)
      ;;       nothing))
      (either (map (.fn-sym ast)
                   (fn [sym]
                     (for [_ (se/try
                               (get-type-constraint sym)
                               (fn [_]
                                 (set-type-constraint sym (b/ConstrainedAST sym (c/update-sym c/fn-constraint
                                                                                              (ast/untag sym))))))]
                       (.arities ast (map (.arities ast)
                                          (fn [arity]
                                            (.fn-sym arity sym)))))))
              (se/state-error ast))))

  (type-check [ast old-ast]
    (let [fn-c (either (map (.fn-sym ast)
                            (fn [sym]
                              (-> c/fn-constraint
                                  (c/update-sym (ast/untag sym)))))
                       c/fn-constraint)
          fn-c (c/update-path fn-c (ast/location old-ast))
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (either (for [variadic (get-in arity [.param-consts .tail-c])
                                       :when (= c/bottom-type variadic)
                                       fixed-params (get-in arity [.param-consts .items])]
                                   (assoc-in c [.arities (count fixed-params)]
                                             (c/fn-arity (.fn-var arity)
                                                         (.param-consts arity)
                                                         (.result-const arity))))
                                 (assoc-in c [.arities c/variadic]
                                           (c/fn-arity (.fn-var arity)
                                                       (.param-consts arity)
                                                       (.result-const arity))))))]
      ;; (let [loc (ast/location ast)]
      ;;   (or (= (.file loc) 'core)
      ;;       (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c (ast/location old-ast) "\n" fn-c)
      ;;         nothing)))
      (se/state-error (b/ConstrainedAST ast fn-c)))))

(deftype ProtocolWithImpls [protocol default-impls]
  Stringable
  (string-list [_]
    (list "(ProtocolWithImpls " (str protocol) "\n\n" (str default-impls) ")"))

  Container
  (map [_ f]
    (ProtocolWithImpls (f protocol) (map default-impls f)))

  (map [_ f embed]
    (for [new-impls (-> default-impls
                        vec
                        (map (fn [[k v]]
                               (map (f v) (partial vector k)))
                             embed)
                        (map (fn [kv-pairs]
                               (reduce kv-pairs {}
                                       (fn [m [k v]]
                                         (assoc m k v))))))
          new-proto (f protocol)]
      (ProtocolWithImpls new-proto new-impls)))

  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (let [arities (impl-arities (.impls ast))
          loc (ast/location ast)]
      (for [constraint (comp (get-type-sym-info (.type ast))
                             (compilation-error "Could not find type" (str "'" (.type ast) "' at") loc))
            r (cond (instance? c/SumConstraint constraint)
                    (se/traverse (.alts constraint)
                                 (fn [c]
                                   ;; TODO: much ugly duplicated code
                                   ;; TODO: also, disable re-defining a proto impl in this case
                                   (for [new-arities (se/traverse arities (partial add-prototype-assertions
                                                                                   (-> c/list-constraint
                                                                                       (c/set-items [c])
                                                                                       (c/set-tail c/top-type)
                                                                                       (c/update-path loc))))]
                                     (let [impls (reduce new-arities {}
                                                         (fn [impls [proto-sym fn-sym arity]]
                                                           (either (update-in impls [proto-sym fn-sym]
                                                                              (fn [arities]
                                                                                (conj arities arity)))
                                                                   (assoc-in impls [proto-sym fn-sym] [arity]))))]
                                       (b/TypeExtension c impls)))))

                    (for [new-arities (se/traverse arities (partial add-prototype-assertions
                                                                    (-> c/list-constraint
                                                                        (c/set-items [constraint])
                                                                        (c/set-tail c/top-type)
                                                                        (c/update-path loc))))]
                      (let [impls (reduce new-arities {}
                                          (fn [impls [proto-sym fn-sym arity]]
                                            (either (update-in impls [proto-sym fn-sym]
                                                               (fn [arities]
                                                                 (conj arities arity)))
                                                    (assoc-in impls [proto-sym fn-sym] [arity]))))]
                        (b/TypeExtension constraint impls))))]
        r))))

(extend-type ast/protocol-ast
  TypeChecker
  (pre-check [ast]
    (let [prototypes (reduce (.prototypes ast) nothing
                             (fn [protos proto]
                               (or (for [_ (-> (.default-body proto)
                                               (filter ast/generates-code?)
                                               first)
                                         :let [arg-count (count (.fixed (.params proto)))
                                               proto-arity (ast/fn-arity (.fn-name proto)
                                                                         (.params proto)
                                                                         (.doc proto)
                                                                         (.default-body proto))]
                                         protos (or protos
                                                    (maybe {}))
                                         new-protos (or (update-in protos [(.fn-name proto) .impls 0]
                                                                   (fn [arities]
                                                                     (assoc arities arg-count proto-arity)))
                                                        (maybe (assoc-in protos [(.fn-name proto)]
                                                                         (PrototypeImpls
                                                                          (ast/untag (.fn-name proto))
                                                                          {c/UnknownType
                                                                           {arg-count proto-arity}}))))]
                                     new-protos)
                                   protos)))
          new-protocol (.prototypes ast
                                    (map (.prototypes ast)
                                         (fn [proto]
                                           (.default-body proto (filter (.default-body proto)
                                                                        (partial instance? c/Constraints))))))]
      (se/try
        (flat-map (get-type-constraint (.protocol-sym ast))
                  (fn [_]

                    (-> (str "Duplicate protocol '" (.protocol-sym ast) "' at "
                             (ast/location (.protocol-sym ast)))
                        (status "at" (str _FILE_ ":") _LINE_)
                        se/throw)))
        (fn [_]
          (se/state-error (either (map prototypes
                                       (partial ProtocolWithImpls new-protocol))
                                  new-protocol))))))

  (type-check [ast old-ast]
    (let [proto-sym (ast/untag (.protocol-sym ast))
          proto-impls (reduce (.prototypes ast) {}
                              (fn [impls proto]
                                (let [arg-count (count (.fixed (.params proto)))
                                      proto-arity (ast/fn-arity-ast (.fn-name proto)
                                                                    ""
                                                                    (.params proto)
                                                                    (.doc proto)
                                                                    []
                                                                    (.param-consts proto)
                                                                    (.result-const proto))]
                                  (either (and (get impls (.fn-name proto))
                                               (map (get-in c/fn-constraint [.arities arg-count])
                                                    (fn [arity-c]
                                                      (-> impls
                                                          (assoc-in [(.fn-name proto) .ast .impls
                                                                     c/UnknownType arg-count]
                                                                    proto-arity)
                                                          (assoc-in [(.fn-name proto) .constraint .arities arg-count]
                                                                    arity-c)))))

                                        (assoc impls (ast/untag (.fn-name proto))
                                               (b/ConstrainedAST
                                                (PrototypeImpls (ast/untag (.fn-name proto))
                                                                {c/UnknownType {arg-count proto-arity}})
                                                (-> c/fn-constraint
                                                    (c/update-sym (ast/untag (.fn-name proto)))
                                                    (c/update-path (ast/location ast))
                                                    (.arities (select-keys (.arities c/fn-constraint)
                                                                           [arg-count])))))))))]
      (for [_ (se/traverse (vec proto-impls)
                           (fn [[proto-name proto-impls]]
                             (set-type-constraint proto-name proto-impls)))
            _ (comp (for [_ (se/get-in-val [.module .value-types 0 proto-sym .ast .prototypes])
                          _ (se/update-in-val [.module .value-types]
                                              (fn [types-list]
                                                (either (for [value-types (first types-list)
                                                              new-types (update-in value-types
                                                                                   [proto-sym .ast .prototypes]
                                                                                   (partial comp (.prototypes ast)))]
                                                          (cons new-types (rest types-list)))
                                                        types-list)))]
                      '_)
                    (set-type-constraint proto-sym (b/ConstrainedAST ast c/top-type)))]
        '_))))

(extend-type ast/call-ast
  TypeChecker
  (wrap-tail [ast params]
    (Left (b/TailCall ast params)))

  (check-call-site [ast args target]
    ;; TODO: may need to be expanded
    (se/state-error (Left c/top-type)))

  (find-arity [_ type-num n]
    ;; TODO: make 'find-arity' return se/state-error so I can look up the result of the call-ast
    (maybe (ast/fn-arity-ast (ast/tag 'anon)
                             ""
                             (ast/params-ast (vec (repeat n '_)) nothing)
                             (ast/block-comment "" 0 [])
                             []
                             (-> c/empty-list-constraint
                                 (c/set-items (vec (repeat n c/top-type))))
                             c/top-type)))

  (type-check [ast old-ast]
    (let [loc (ast/location (.call-target old-ast))]
      (for [
            ;; _ (se/when (or (= (.line loc) 0)
            ;;                (= (.file loc) 'core)
            ;;                (maybe (status 'calling-top _LINE_ loc
            ;;                               "\n" 'target (.call-target ast)
            ;;                               "\n\n" 'args (-> (.args ast)
            ;;                                                (map .constraint)
            ;;                                                (interpose  "\n")
            ;;                                                vec)))
            ;;                (maybe nothing)))
            result-type (apo (fn [inner-ast]
                               ;; (or (= (.line loc) 0)
                               ;;     (= (.file loc) 'core)
                               ;;     (do
                               ;;       (status 'calling _LINE_ loc "\n" (type-name inner-ast) inner-ast
                               ;;               "\n\n" 'args (-> (.args ast)
                               ;;                                (map .constraint)
                               ;;                                (interpose  "\n")
                               ;;                                vec)
                               ;;               "\n\n" 'old-args (.args old-ast))
                               ;;       nothing))
                               (check-call-site inner-ast (.args ast) (.call-target old-ast)))
                             (.call-target ast) se/state-error)
            ;; _ (se/when (or (= (.line loc) 0)
            ;;                (= (.file loc) 'core)
            ;;                (maybe (status 'calling-result _LINE_ loc
            ;;                               "\n" 'result-type result-type))
            ;;                (maybe nothing)))
            _ (either (map (and (= c/bottom-type result-type)
                                (first (.constraints result-type)))
                           (fn [_]
                             (compilation-error (conflicting-assertions result-type loc))))
                      se-nop)]
        (b/ConstrainedAST (.args old-ast (.args ast))
                          result-type)))))

(extend-type ast/reify-ast
  TypeChecker
  (wrap-tail [ast params]
    (Left (b/TailCall ast params)))

  (check-call-site [ast args target]
    (let [loc (ast/location target)
          arg-consts (b/remove-asts args)
          num-args (inc (count args))]
      (either (for [invoke-arities (get-in ast [.impls Function-sym invoke-sym])
                    ;; :let [_ (or (= (.line loc) 0)
                    ;;             (= (.file loc) 'core)
                    ;;             (do
                    ;;               (print-err 'call-reify _LINE_ target loc
                    ;;                          "\n" 'num-args num-args
                    ;;                          "\n\n" 'invoke-arities invoke-arities
                    ;;                          "\n\n" 'args (-> arg-consts
                    ;;                                           (interpose  "\n")
                    ;;                                           vec))
                    ;;               nothing))]
                    arity (some invoke-arities (fn [arity]
                                                 ;; (or (= (.line loc) 0)
                                                 ;;     (= (.file loc) 'core)
                                                 ;;     (do
                                                 ;;       (print-err 'call-reify _LINE_ target loc
                                                 ;;                  "\n" 'num-args num-args
                                                 ;;                  "\n" 'arity (-> arity
                                                 ;;                                  .params
                                                 ;;                                  .ast
                                                 ;;                                  .fixed))
                                                 ;;       nothing))
                                                 (and (-> arity
                                                          .params
                                                          .ast
                                                          .fixed
                                                          count
                                                          (=* num-args))
                                                      (maybe arity))))]
                (let [param-cs (c/reify-type-constraint (.param-consts arity) (.fn-var arity)
                                                        (comp [c/top-type] arg-consts) loc)
                      ;; _ (or (= (.line loc) 0)
                      ;;       (= (.file loc) 'core)
                      ;;       (do
                      ;;         (print-err 'call-reify _LINE_ target loc
                      ;;                    "\n\n" 'param-consts (.param-consts arity)
                      ;;                    "\n\n" 'args (-> arg-consts
                      ;;                                     (interpose  "\n")
                      ;;                                     vec)
                      ;;                    "\n\n" 'param-cs param-cs)
                      ;;         nothing))
                      result-c (.result-const arity)]
                  (map (se/traverse (zip-lists args (rest (c/extract-items-constraints param-cs num-args)))
                                    (fn [[arg c]]
                                      (either (map (= c/bottom-type c)
                                                   (fn [_]
                                                     (compilation-error (conflicting-assertions c loc))))
                                              (flat-map se-nop
                                                        (fn [_]
                                                          ;; (or (= (.line loc) 0)
                                                          ;;     (= (.file loc) 'core)
                                                          ;;     (maybe (print-err 'call-reify-ast _LINE_ loc target
                                                          ;;                       "\n\n" 'c c
                                                          ;;                       "\n\n" 'arg arg
                                                          ;;                       "\n\n" 'arg-c (b/remove-asts arg)
                                                          ;;                       ))
                                                          ;;     (maybe '_))
                                                          (update-constraint arg c loc))))))
                       (fn [arg-consts]
                         (let [arg-consts (comp [c/top-type] (b/remove-asts arg-consts))]
                           ;; (or (= (.line loc) 0)
                           ;;     (= (.file loc) 'core)
                           ;;     (maybe (print-err 'call-reify target loc
                           ;;                       "\n" 'ast ast
                           ;;                       "\n\n" 'num-args num-args
                           ;;                       "\n\n" 'param-cs param-cs
                           ;;                       "\n\n" 'result-c result-c
                           ;;                       "\n\n" 'args (-> arg-consts
                           ;;                                        (interpose  "\n")
                           ;;                                        vec)))
                           ;;     (maybe '_))
                           (Left (c/reify-type-constraint result-c (.fn-var arity) arg-consts loc)))))))
              (compilation-error "No 'invoke' implementation found for"
                                 (cond (instance? Tagged target)
                                       (str "'" target "'")
                                       "value")
                                 "at\n" loc))))

  (type-check [ast old-ast]
    (let [reified-type-num (either (.type-num ast)
                                   (extract type-counter))]
      (map (extend-prototypes reified-type-num (.impls ast))
                (fn [arities]
                  (let [arities (reduce arities {}
                                        (fn [m [proto-name fn-sym arity]]
                                          (either (and (get-in m [proto-name fn-sym])
                                                       (update-in m [proto-name fn-sym]
                                                                  (fn [arities]
                                                                    (conj arities arity))))
                                                  (assoc-in m [proto-name fn-sym] [arity]))))
                        invoke-arities (either
                                        (map (get-in arities [Function-sym invoke-sym])
                                             (fn [invoke-arities]
                                               (reduce invoke-arities {}
                                                       (fn [m arity]
                                                         (assert (instance? ast/fn-arity-ast arity))
                                                         (either
                                                          (for [fixed-params (get-in arity [.param-consts .items])]
                                                            (assoc m (count fixed-params)
                                                                   (c/fn-arity (.fn-var arity)
                                                                               (.param-consts arity)
                                                                               (.result-const arity))))
                                                          m)))))
                                        {})
                        loc (ast/location old-ast)]
                    ;; (or (= (.line loc) 0)
                    ;;     (= (.file loc) 'core)
                    ;;     (maybe (print-err 'invoke-arities _LINE_ loc reified-type-num
                    ;;                       "\n" invoke-arities)))
                    (b/ConstrainedAST (ast/reify-ast (maybe reified-type-num) arities)
                                      (c/ReifiedConstraint reified-type-num {}
                                                           (symbol "reified value at")
                                                           invoke-arities empty-list
                                                           ;; TODO: add location
                                                           c/no-symbol ""))))))))

(extend-type ast/either-ast
  TypeChecker
  (wrap-tail [ast params]
    (Left (b/TailEither (.clause ast)
                        (tail-call (.alt ast) params))))

  (pre-check [ast]
    (-> ast
        (.clause (OrClause (.clause ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          _ (push-types (.types (.clause ast)))
          new-clause (update-constraint (.ast (.clause ast))
                                        (-> c/maybe-constraint
                                            (c/update-path (ast/location (.ast (.clause ast)))))
                                        (ast/location (.ast (.clause ast))))]
      (-> ast
          (.clause new-clause)
          (b/ConstrainedAST (-> (c/sum-type [(c/extract-contents-constraint (.constraint new-clause))
                                           (.constraint (.alt ast))])
                              (c/update-path (ast/location old-ast))))))))

(extend-type ast/let-ast
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: move this filtering of the body to the Vector implementation of wrap-tail
    (-> ast
        (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                     (-> ast
                         .body
                         (filter ast/generates-code?)
                         (tail-call params))))
        Left))

  (check-call-site [ast args target]
    (either (map (last (.body ast)) (fn [last-ast]
                                      (check-call-site last-ast args target)))
            (se/state-error (Left c/top-type))))

  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or (= (.line loc) 0)
    ;;       (= (.file loc) 'core)
    ;;       (do
    ;;         (print-err 'let loc
    ;;                    "\n" ast)
    ;;         nothing)))
    (-> ast
        (.body (remove (.body ast)
                       (partial instance? ast/block-comment-ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (se/traverse (reverse (.bindings ast))
                         (fn [binding-ast]
                           (let [binding (.binding binding-ast)
                                 val (.val binding-ast)]
                             (for [val-c (either (or (map (instance? Tagged binding)
                                                          (partial get-type-constraint))
                                                     (map (instance? ast/params-ast binding)
                                                          (fn [_]
                                                            (map (get-param-types binding)
                                                                 (fn [binding-c]
                                                                   (assert (instance? c/ListConstraint binding-c))
                                                                   (-> c/seq-constraint
                                                                       (c/set-items (.items binding-c))
                                                                       (c/set-tail (.tail-c binding-c))))))))
                                                 (se/state-error c/top-type))
                                   _ (se/traverse (all-syms binding)
                                                  recover-type-constraint)
                                   _ (update-constraint val (b/remove-asts val-c) (ast/location binding))
                                   ;; :let [loc (ast/location old-ast)
                                   ;;       _ (or (= (.line loc) 0)
                                   ;;             (= (.file loc) 'core)
                                   ;;             (do
                                   ;;               (print-err 'let loc
                                   ;;                          "\n" 'binding (type-name binding) binding
                                   ;;                          "\n\n" 'val val
                                   ;;                          "\n\n" 'val-c val-c)
                                   ;;               nothing))]
                                   _ (nip-types)]
                               '_))))]
      (let [result-c (either (map (last (.body ast)) .constraint)
                             c/top-type)]
        (b/ConstrainedAST ast (c/clear-sym result-c))))))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.binding ast (reify
                                    Type
                                    (type-name [_]
                                      (str "reified at " _FILE_ ": " _LINE_))

                                    Stringable
                                    (string-list [_]
                                      (string-list ast))

                                    Container
                                    (map [y f embed]
                                      (embed y))

                                    TypeChecker
                                    (pre-check [ast]
                                      ;; TODO: remove
                                      (se/state-error ast))

                                    (type-check [_ _]
                                      (se/state-error (.binding ast)))))))

  (type-check [ast old-ast]
    (let [loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (or (= (.line loc) 0)
            ;;             (= (.file loc) 'core)
            ;;             (do
            ;;               (print-err 'binding-type-check loc
            ;;                          "\n\n" 'ast ast)
            ;;               nothing))]
            _ (ana constrain-all-syms (ParamConstraintPair (.binding ast)
                                                           (.constraint (.val ast)))
                   se/state-error)]
        ast))))

(extend-type ast/and-ast
  TypeChecker
  (wrap-tail [ast params]
    (-> (.clauses ast)
        ;; TODO: move this filtering to the Vector wrap-tail
        (filter ast/generates-code?)
        (tail-call params)
        b/TailAnd
        Left))

  (pre-check [ast]
    (-> ast
        (.clauses (-> (.clauses ast)
                      (remove (partial instance? ast/NoCode))
                      (map AndClause)))
        se/state-error))

  (type-check [ast old-ast]
    (either (for [first-clause (first (.clauses ast))
                  last-clause (last (.clauses ast))]
              (for [_ (pop-types)
                    _ (push-types (.types first-clause))
                    ;; TODO: when the ast of the first clause is a call to instance?,
                    ;; recover the type of the symbol in the second arg
                    _ (se/traverse (.clauses ast)
                                   (fn [checked-clause]
                                     (let [clause (.ast checked-clause)]
                                       (update-constraint clause (.constraint clause)
                                                          (ast/location (.ast clause))))))]
                (-> ast
                    (.clauses (map (.clauses ast) .ast))
                    (b/ConstrainedAST (.constraint (.ast last-clause))))))
            (se/state-error (b/ConstrainedAST ast (-> c/maybe-constraint
                                                    (c/update-path (ast/location old-ast))))))))

(extend-type ast/integer-ast
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (type-check [ast old-ast]
    (se/state-error (b/ConstrainedAST (.int old-ast)
                                    (-> c/int-constraint
                                        (.static-value (.int old-ast))
                                        (c/update-path (ast/location old-ast)))))))

(extend-type ast/string-ast
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (se/state-error (b/ConstrainedAST str-val
                                      (.static-value c/strbuff-constraint str-val))))))

(extend-type ast/cond-val-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (ast/cond-val-ast (b/CondValCond (.conditional ast))
                                      (b/CondValVal (.value ast)))))

  (type-check [ast old-ast]
    (se/state-error (b/ConstrainedAST ast (.constraint (.value ast))))))

(extend-type ast/cond-ast
  TypeChecker
  (wrap-tail [ast params]
    (Left (b/TailCond (.conditionals ast)
                      (tail-call (.default ast) params))))

  (type-check [ast old-ast]
    (let [conditionals (vec (map (.conditionals ast) .ast))]
      (either (map (first conditionals)
                   (fn [first-cond]
                     (for [_ (pop-types)
                           _ (push-types (.types (.conditional first-cond)))
                           _ (se/traverse conditionals
                                          (fn [cond-val]
                                            (update-constraint (.ast (.conditional cond-val))
                                                               (-> c/maybe-constraint
                                                                   (c/update-path (ast/location cond-val)))
                                                               (ast/location cond-val))))]
                       (b/ConstrainedAST (.conditionals ast conditionals)
                                       (-> (.conditionals ast)
                                           (map .constraint)
                                           (conj (.constraint (.default ast)))
                                           c/sum-type)))))
              (se/state-error (b/ConstrainedAST ast (.constraint (.default ast))))))))

(extend-type ast/or-ast
  TypeChecker
  (wrap-tail [ast params]
    (-> (.clauses ast)
        ;; TODO: move this filtering to the Vector wrap-tail
        (filter ast/generates-code?)
        (tail-call params)
        b/TailOr
        Left))

  (pre-check [ast]
    (-> ast
        (.clauses (-> (.clauses ast)
                      (remove (partial instance? ast/NoCode))
                      (map OrClause)))
        se/state-error))

  (type-check [ast old-ast]
    (either (map (first (.clauses ast))
                 (fn [first-clause ]
                   (for [_ (pop-types)
                         _ (push-types (.types first-clause))
                         ;; TODO: when the ast of the first clause is a call to instance?,
                         ;; recover the type of the symbol in the second arg
                         new-clauses (se/traverse (.clauses ast)
                                                  (fn [checked-clause]
                                                    (let [clause (.ast checked-clause)]
                                                      (update-constraint clause
                                                                         (c/update-path c/maybe-constraint
                                                                                        (ast/location clause))
                                                                         (ast/location clause)))))]
                     (-> ast
                         (.clauses (map (.clauses ast) .ast))
                         (b/ConstrainedAST (-> (.clauses ast)
                                             (map (comp .constraint .ast))
                                             c/sum-type
                                             (c/update-path (cata ast/location old-ast))))))))

            (se/state-error (b/ConstrainedAST ast (-> c/maybe-constraint
                                                    (c/update-path (cata ast/location old-ast))))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      'ResultConstraint c/ResultConstraintType
                      'InferredInner c/InferredInnerType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract type-counter)))

(deftype TypeCheckOnly [x]
  Stringable
  (string-list [_]
    (list "(TypeCheckOnly " (str x) ")"))

  Container
  (map [ast f]
    (TypeCheckOnly (f x)))

  (map [ast f embed]
    (map (f x) TypeCheckOnly))

  TypeChecker
  (type-check [ast old-ast]
    (se/state-error (b/ConstrainedAST (ast/block-comment "" 0 [])
                                      c/top-type))))

(deftype DestructFields [fields]
  (assert (instance? (vector-of Symbol) fields))

  Stringable
  (string-list [_]
    (list "(DestructFields " (to-str fields) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(def x* (ast/tag "#x"))
(def y* (ast/tag "#y"))
(def field* (ast/tag "#field"))
(def ctxt* (ast/tag "#ctxt"))

(defn default-type-impls [type-sym fields]
  (let [loc (ast/location type-sym)]
    {Type-sym
     {type-name-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_type_name") loc)
        (ast/params [x*]) ""
        [(ast/string-ast (str type-sym) (.file loc) (.line loc))])]

      has-field-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_has_field") loc)
        (ast/params [x* field*]) ""
        [(ast/or-ast
          (conj (map fields
                     (fn [field]
                       (ast/call-ast identical-sym
                                     [(ast/tag (str "." field) loc)
                                      field*])))
                nothing-sym))])]}

     Eq-sym
     {=*-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_EQ_STAR_") loc)
        (ast/params [x* y*]) ""
        [(ast/and-ast
          [(ast/call-ast
            =*-sym [(ast/call-ast get-type-sym [x*])
                    (ast/call-ast get-type-sym [y*])])
           (ast/call-ast
            =*-sym [(ast/call-ast default-type-args-sym [x*])
                    (ast/call-ast default-type-args-sym [y*])])
           (ast/call-ast maybe-sym [x*])])])]}

     Associative-sym
     {get-symb
      [(ast/fn-arity
        (ast/tag (str type-sym "_get") loc)
        (ast/params [x* field*]) ""
        [ ;; (c-code "" ["// TODO: this seems to do runtime checks for 'has-field' result\n// and the result returned\n"]
         ;;         {} c/top-type)
         (ast/and-ast
          [(ast/call-ast has-field-sym [x* field*])
           (ast/call-ast maybe-sym
                         [(ast/call-ast field* [x*])])])])]

      assoc-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_assoc_") loc)
        (ast/params [x* field* (ast/tag 'new-value)]) ""
        [(ast/cond-ast
          [(ast/cond-val-ast (ast/call-ast has-field-sym [x* field*])
                             (ast/call-ast field* [x* 'new-value]))]
          x*)])]}

     Hashable-sym
     {sha1-update-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_sha1_update") loc)
        (ast/params [x* ctxt*]) ""
        [(ast/call-ast sha1-update-type-sym [x* ctxt*])
         (ast/call-ast
          sha1-update-sym
          [(ast/call-ast default-type-args-sym [x*]) ctxt*])])]

      sha1-sym
      [(ast/fn-arity
        (ast/tag (str type-sym "_sha1") loc)
        (ast/params [x*]) ""
        [(ast/call-ast
          sha1-finalize-sym
          [(ast/call-ast
            sha1-update-sym
            [x* (ast/call-ast sha1-init-sym [])])])])]}}))

(defn create-getters [sym type-num new-type-constraint fields field-constraints]
  (let [type-value (ast/tag "#value")
        field-arg (ast/tag "#field")
        file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [field-sym (-> (str "." field) symbol c/Field)]
              [(ast/tag (str "." field) file-name line-number)
               [;; setter arity
                (let [arity-id (symbol (str sym "-" field "-setter"))
                      field-constraint (c/update-path field-constraint file-name line-number)]
                  (ast/fn-arity-ast
                   (ast/tag (str sym "_" field) file-name line-number)
                   arity-id (ast/params [type-value field-arg]) ""
                   [(c/update-sym field-constraint (ast/untag field-arg))
                    (ast/inline-ast (ast/tag 'C)
                                    (-> (c/ReifiedConstraint c/UnknownType {} sym {} empty-list c/no-symbol "")
                                        (c/update-path (ast/location sym)))
                                    (str "return(updateField(value_0, field_1, "
                                         field-index "));\n")
                                    "" 0)]
                   (-> c/list-constraint
                       (c/set-items [new-type-constraint field-constraint]))
                   (-> (c/ParamConstraint arity-id 0 [] empty-list c/no-symbol "")
                       (c/intersect (c/set-field field-sym
                                                 (c/ParamConstraint arity-id 1 [] empty-list c/no-symbol ""))))))

                ;; getter arity
                (let [arity-id (symbol (str sym "-" field "-getter"))
                      field-constraint (-> (c/ParamConstraint arity-id 0 [] empty-list c/no-symbol "")
                                           (c/intersect (c/get-field field-sym))
                                           (c/intersect field-constraint)
                                           c/clear-sym)]
                  (ast/fn-arity-ast
                   (ast/tag (str sym "_" field) file-name line-number)
                   arity-id (ast/params [type-value]) ""
                   [(ast/inline-ast (ast/tag 'C) field-constraint
                                    (str "
  Value *result = incRef(((ReifiedVal *)value_0)->impls[" field-index "], 1);
  dec_and_free(value_0, 1);
  return(result);
")
                                    "" 0)]
                   (-> c/empty-list-constraint
                       (c/set-items [new-type-constraint]))
                   field-constraint))]])))}))

(deftype CreateGetters [sym type-num new-type-constraint fields loc]
  Stringable
  (string-list [_]
    (list "(CreateGetters " (str sym) " " (to-str fields) " " (str loc) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (map (se/traverse fields (fn [field]
                               (for [_ (create-new-getter (ast/tag (str "." field) loc)
                                                          type-num new-type-constraint)
                                     field-c (map (get-type-constraint field)
                                                  (fn [field-info]
                                                    (cata promote-inferred (.constraint field-info))))
                                     _ (set-type-constraint field (b/ConstrainedAST field field-c))]
                                 field-c)))
         (fn [field-cs]
           (b/TypeExtension new-type-constraint
                            (create-getters (ast/untag sym) type-num new-type-constraint fields field-cs))))))

(defn create-constructor [new-type-name type-num new-type-constraint field-constraints fields]
  (assert (instance? ast/tagged-symbol new-type-name))
  (assert (instance? c/ReifiedConstraint new-type-constraint))
  (assert (instance? c/ListConstraint field-constraints))
  (assert (instance? (vector-of Symbol) fields))

  (let [file-name (ast/file-name new-type-name)
        line-number (ast/line-number new-type-name)
        x* (ast/tag "#x" file-name line-number)
        y* (ast/tag "#y" file-name line-number)
        field-count (count fields)
        reified-type-num (extract type-counter)
        field-params (-> (comp ['_]
                               (map (range field-count)
                                    (fn [n]
                                      (ast/tag (str "arg" n)))))
                         (map (fn [arg]
                                (ast/tag arg file-name line-number)))
                         ast/params)]
    (ast/reified (maybe reified-type-num)
                 {(ast/tag Eq-sym file-name line-number)
                  {(ast/tag =*-sym file-name line-number)
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_EQ_QMARK_") file-name line-number)
                     (ast/params [x* y*]) ""
                     [(ast/and-ast
                       [(ast/call-ast =*-sym
                                      [type-num
                                       (ast/call-ast get-type-sym [y*])])
                        (ast/call-ast maybe-sym [y*])])])]}

                  (ast/tag Type-sym file-name line-number)
                  {type-name-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_const_type_name") file-name line-number)
                     (ast/params [(ast/tag '_)]) ""
                     [(str "* " new-type-name " constructor at " file-name ": " line-number " *")])]

                   ;; TODO: put back in
                   ;; type-mapping-sym
                   ;; [(ast/fn-arity
                   ;;   (ast/tag (str new-type-name "_const_type_map") file-name line-number)
                   ;;   (ast/params [(ast/tag '_)]) ""
                   ;;   [(map-vals (.type-maps new-type-constraint)
                   ;;              (fn [field-set]
                   ;;                (map (keys field-set) ast/quoted-ast)))])]

                   instance?-sym
                   [(ast/fn-arity
                     (ast/tag (str new-type-name "_instance_QMARK_") file-name line-number)
                     (ast/params [x* y*]) ""
                     [;; TODO: remove all inline assertions
                      ;; add constraints to arity struct
                      (-> c/maybe-constraint
                          (c/intersect (c/InferredInner new-type-constraint empty-list c/no-symbol ""))
                          c/ResultConstraint)
                      (ast/and-ast
                       [(ast/call-ast =*-sym
                                      [type-num
                                       (ast/call-ast get-type-sym [y*])])
                        (ast/call-ast maybe-sym [y*])])])]}

                  Function-sym
                  {invoke-sym
                   (let [arity-id (symbol (str new-type-name "_invoke"))]
                     [(ast/fn-arity-ast
                       (ast/tag (str new-type-name "_invoke") file-name line-number)
                       arity-id field-params ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "ReifiedVal *rv = malloc_reified("
                                             field-count ");\n"
                                             "#ifdef SINGLE_THREADED\n"
                                             "rv->refs = refsInit;\n#else\n"
                                             " __atomic_store(&rv->refs,"
                                             " &refsInit, __ATOMIC_RELAXED);\n"
                                             "#endif\n"
                                             "rv->type = " type-num ";\n"
                                             (to-str (map (range field-count)
                                                          (fn [idx]
                                                            (str "rv->impls[" idx "] = arg" idx
                                                                 "_" (inc idx) ";\n"))))
                                             "return((Value *)rv);\n")
                                        "" 0)]
                       (.items field-constraints (comp [c/top-type]
                                                       (.items field-constraints)))
                       (.fields new-type-constraint
                                (merge-with c/intersect
                                            (.fields new-type-constraint)
                                            (-> (zip-lists fields (range (count fields)))
                                                (reduce {} (fn [m [fld idx]]
                                                             (assoc m (c/Field (symbol (str "." fld)))
                                                                    (c/ParamConstraint
                                                                     arity-id (inc idx) []
                                                                     empty-list c/no-symbol ""))))))))])}

                  Container-sym
                  {apply-sym
                   (let [arity-id (symbol (str new-type-name "_apply"))]
                     [(ast/fn-arity-ast
                       (ast/tag (str new-type-name "_apply_ST_") file-name line-number)
                       arity-id (ast/params [(ast/tag '_ file-name line-number)
                                             (ast/tag 'fields file-name line-number)])
                       ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "return(newTypeValue(" type-num ", (Vector *)fields_1));")
                                        "" 0)]
                       (-> c/list-constraint
                           (c/set-items [c/top-type field-constraints]))
                       (.fields new-type-constraint
                                (merge-with c/intersect
                                            (.fields new-type-constraint)
                                            (-> (zip-lists fields (range (count fields)))
                                                (reduce {} (fn [m [fld idx]]
                                                             (assoc m (c/Field (symbol (str "." fld)))
                                                                    (c/ParamConstraint
                                                                     arity-id 1 [(c/GetField idx)]
                                                                     empty-list c/no-symbol ""))))))))])}

                  (ast/tag Stringable-sym file-name line-number)
                  {string-list-sym
                   [(ast/fn-arity (ast/params [(ast/tag 'z)]) ""
                                  [(ast/call-ast list-sym
                                                 ["<ValueConstructor " (str new-type-name) " ["
                                                  (to-str (interpose fields ", "))
                                                  "]>"])])]}})))

(deftype CheckedTypeAST [sym type-num new-type-constraint fields impls]
  Stringable
  (string-list [_]
    (list "(CheckedTypeAST " (str sym) " " (str fields) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  TypeChecker
  (pre-check [ast]
    (for [field-types (get-param-types (ast/params-ast fields nothing))
          ;; _ (se/traverse fields (fn [field]
          ;;                         (for [field-c (get-type-constraint field)]
          ;;                           (print-err 'field (.sym ast) field field-c))))
          _ (se/traverse fields recover-type-constraint)
          invoke-impls (get-type-constraint invoke-sym)
          _ (nip-types)
          _ (push-types)]
      (let [invoke-arities (-> (either (get-in invoke-impls [.ast .impls type-num])
                                       {})
                               vec
                               (reduce {} (fn [arities [k v]]
                                            (assoc arities k (c/fn-arity (.fn-var v)
                                                                         (.param-consts v)
                                                                         (.result-const v))))))]
        (ast/definition-ast sym [(create-constructor sym type-num
                                                     (.invoke-arities new-type-constraint invoke-arities)
                                                     field-types fields)])))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (let [sym (.sym ast)
          loc (ast/location sym)
          fields (-> (.fields ast)
                     .fixed
                     (map ast/untag))
          type-num (new-type-number sym)
          field-destruct (DestructFields fields)
          fields-map (reduce fields {}
                             (fn [m name]
                               (assoc m
                                 (c/Field (symbol (str "." name))) c/top-type)))
          new-type-constraint (-> (c/ReifiedConstraint type-num fields-map (ast/untag sym)
                                                       {} empty-list c/no-symbol "")
                                  (c/update-path loc))]
      (for [_ (se/assoc-in-val [.module .types (ast/untag sym)]
                               new-type-constraint)
            _ (se/assoc-in-val [.constants .type-names type-num] (str sym))
            _ (set-type-constraint sym (b/ConstrainedAST sym (-> c/fn-constraint
                                                                 (.arities (select-keys (.arities c/fn-constraint)
                                                                                        [(count fields)]))
                                                                 (c/update-sym (ast/untag sym))
                                                                 (c/update-path loc))))
            _ (push-types)
            _ (se/traverse fields (fn [sym]
                                    (set-type-constraint sym (b/ConstrainedAST sym c/top-type))))
            field-assertions (-> (.impls ast)
                                 (filter (partial instance? c/ValueConstraint))
                                 (map (fn [c]
                                        (c/update-path c loc)))
                                 (se/traverse lookup-constraint))
            impls (-> (.impls ast)
                      (remove (partial instance? c/Constraints))
                      (flat-map impl-arities)
                      (se/traverse (partial add-prototype-assertions (-> c/list-constraint
                                                                         (c/set-items [new-type-constraint])
                                                                         (c/set-tail c/top-type)
                                                                         (c/update-path loc)))))
            impls (se/traverse impls 
                               (fn [[proto-sym fn-sym arity]]
                                 (let [arity (.body arity (comp [field-destruct]
                                                                (.body arity)))]
                                   (either (map (some (all-syms (.params arity))
                                                      (fn [param-sym]
                                                        (and (some fields (partial = param-sym))
                                                             (maybe param-sym))))
                                                (fn [shadowing]
                                                  (compilation-error "The parameter" (str "'" shadowing "'")
                                                                     "shadows a field of the same name at"
                                                                     (ast/location shadowing))))
                                           (se/state-error [proto-sym fn-sym arity])))))]
        (let [impls (reduce impls {}
                            (fn [impls [proto-sym fn-sym arity]]
                              (let [arity (.body arity (comp [field-destruct]
                                                             (.body arity)))]
                                (either (update-in impls [proto-sym fn-sym]
                                                   (fn [arities]
                                                     (conj arities arity)))
                                        (assoc-in impls [proto-sym fn-sym] [arity])))))
              ;; TODO: eliminate the named symbols
              impls-get (get-in impls [Associative-sym get-symb])
              default-impls (default-type-impls (ast/tag sym loc) fields)
              default-get (get-in default-impls [Associative-sym get-symb])
              impls-assoc (get-in impls [Associative-sym assoc-sym])
              default-assoc (get-in default-impls [Associative-sym assoc-sym])

              ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
              ;; and parameter, respectively
              hash-map-impls (either (map (or impls-get
                                              default-get)
                                          (fn [arities]
                                            (assoc-in {} [Associative-sym get-symb]
                                                      (map arities
                                                           (fn [arity]
                                                             (.body arity (comp [field-destruct]
                                                                                (.body arity))))))))
                                     {})
              hash-map-impls (either (map (or impls-assoc
                                              default-assoc)
                                          (fn [arities]
                                            (assoc-in hash-map-impls [Associative-sym assoc-sym]
                                                      (map arities
                                                           (fn [arity]
                                                             (.body arity (comp [field-destruct]
                                                                                (.body arity))))))))
                                     hash-map-impls)
              impls (either (update impls Associative-sym
                                    (fn [fns]
                                      (dissoc fns assoc-sym get-symb)))
                            impls)
              default-impls (dissoc default-impls Associative-sym)]
          (comp field-assertions
                [(b/TypeExtension new-type-constraint default-impls)
                 (b/TypeExtension new-type-constraint impls)
                 (CreateGetters (.sym ast) type-num new-type-constraint fields loc)
                 ;; TODO: why are the hash-map-impls done twice?
                 (cond (empty? hash-map-impls)
                       (ast/block-comment "" 0 [])
                       (b/TypeExtension new-type-constraint hash-map-impls))
              
                 ;; (reify
                 ;;   Container
                 ;;   (map [y f embed]
                 ;;     (embed y))

                 ;;   TypeChecker
                 ;;   (pre-check [ast]
                 ;;     (for [ft (get-param-types (ast/params-ast fields nothing))]
                 ;;       (do
                 ;;         (cond (= "Boogie" (str sym))
                 ;;               (status 'test _LINE_ "\n" ft)

                 ;;               '_)
                 ;;         ast)))

                 ;;   (type-check [_ _]
                 ;;     (se/state-error (ast/block-comment-ast [] "poop" 99))))
                 (CheckedTypeAST sym type-num new-type-constraint fields impls)]))))))

(extend-type ast/quoted-ast
  TypeChecker
  (wrap-tail [ast params]
    ;; TODO: remove
    (Right ast))

  (pre-check [ast]
    (se/state-error (reify
                      Type
                      (type-name [_]
                        (str "reified at " _LINE_))

                      Stringable
                      (string-list [_]
                        (list (str "'" (.q-val ast))))

                      Eq
                      (=* [_ y]
                        (= y (.q-val ast)))

                      Container
                      (map [x f]
                        x)

                      (map [x f embed]
                        (embed x))

                      ast/FileLoc
                      (ast/location [_]
                        (ast/location ast))

                      TypeChecker
                      (type-check [ast old-ast]
                        (se/state-error (b/ConstrainedAST ast (-> c/sym-constraint
                                                                  (.static-value (symbol (rest (str ast))))
                                                                  (c/update-path (ast/location ast))))))))))

(extend-type ast/main-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (ana constrain-all-syms
                 (ParamConstraintPair (.params ast)
                                      (-> c/list-constraint
                                          (c/set-tail (c/CollectionOf c/string-constraint
                                                                      empty-list c/no-symbol ""))))
                 se/state-error)]
      (.body ast (remove (.body ast) (partial instance? ast/block-comment-ast)))))

  (type-check [ast old-ast]
    (se/state-error (b/ConstrainedAST ast c/top-type))))

(extend-type ast/block-comment-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error (b/ConstrainedAST ast c/top-type))))

(def analyze-forms (rd/parser
                    (grmr/none-or-more
                     (grmr/any
                      (fr/pure (reify
                                 Type
                                 (type-name [_]
                                   (str "Reified at: " _FILE_ ": " _LINE_))

                                 rd/RecursiveDescent
                                 (rd/recursive-descent [p]
                                   (se/state-error
                                    (se/new-se (fn [s]
                                                 (either (for [result-prom (get-in s [.values 'result-prom])
                                                               :when (delivered result-prom)]
                                                           (extract result-prom))
                                                         se/Failure)))))))
                      ;; (parse-module-import ast-checker)
                      (apply-to (fn [type-checker result-prom ast]
                                  ;; (status 'ast ast)
                                  (send type-checker update-context
                                        (se/try
                                          (comp (type-check-ast ast)
                                                (compilation-error "Could not type check code for expression at "
                                                                   (ast/location ast)))
                                          (fn [err]
                                            (deliver result-prom (se/throw (.val err)))
                                            (se/throw (.val err)))))
                                  ast)
                                (grmr/get-value 'type-checker)
                                (grmr/get-value 'result-prom)
                                rdr/top-level)))))

(defn load-module [loader-futs file-name waiter-prom root-dir proj-dir]
  (assert (instance? (map-of c/SymbolOrString Future) loader-futs))

  ;; either the module is in process ...
  (either (map (get loader-futs file-name)
               (fn [mod-prom]
                 ;; in which case, tell it to notify waiting process when completely loaded
                 (assoc loader-futs file-name (map mod-prom (partial deliver waiter-prom)))))

          ;; or module isn't loaded yet
          (let [module-index (count loader-futs)
                ;; init an agent with an empty module context
                ast-checker (-> module-context
                                (.module (Module file-name module-index {} {} c/core-type-constraints empty-list))
                                agent)
                ;; kick off a thread to load and check the module
                loader (future (fn []
                                 (status "Loading" file-name)
                                 (assert-result r (instance? se/StateError r))

                                 (let [result-prom (promise)]
                                   ;; either the module source file can be opened
                                   (either (map (fio/file-in (cond (= file-name 'core)
                                                                   path-to-core
                                                                   file-name))
                                                (fn [file-in]
                                                  ;; if so, parse and type check it
                                                  (let [analyzed (analyze-forms {'file-name file-name
                                                                                 'root-directory root-dir
                                                                                 'project-directory proj-dir
                                                                                 'line-number 1
                                                                                 'type-checker ast-checker
                                                                                 'result-prom result-prom}
                                                                                (lazy-list file-in))]
                                                    (send ast-checker (fn [s]
                                                                        (deliver result-prom
                                                                                 (se/state-error (.module s)))))
                                                    (either (map (instance? se/Error analyzed)
                                                                 (fn [err]
                                                                   (se/throw (.val err))))
                                                            (extract result-prom)))))
                                           ;; or tell everyone it couldn't be
                                           (se/throw (str "Could not find/open " file-name))))))]
            ;; pass the loader to the waiter
            (deliver waiter-prom loader)

            ;; return updated loader map
            (assoc loader-futs file-name loader))))

(defn compile-module [file-name root-dir proj-dir]
  (assert-result r (instance? Future r))

  (let [waiter-prom (promise)]
    (send loaders load-module file-name waiter-prom root-dir proj-dir)
    (extract waiter-prom)))

(main [params]
  (let [core-fut (compile-module 'core toccata-dir toccata-dir)
        loaded (map core-fut
                    (fn [loaded]
                      ((se/try
                         (comp (map loaded (fn [core-module]
                                             (let [p (promise)]
                                               (send modules (fn [_]
                                                               (deliver p '_)
                                                               {'core core-module}))
                                               (extract p))
                                             (status "loaded core"))) 
                               (se/throw "Could not load Toccata core"))
                         (fn [err]
                           (print-err 'core-error _LINE_ "\n" err)
                           (abort)
                           (se/throw (.val err))))
                       'dummy-state)))
        _ (extract loaded)
        _ (let [p (promise)]
            (send flag (fn [_]
                         (deliver p '_)
                         (maybe '_)))
            (extract p))
        mods (extract modules)]

    (map (rest params)
         (fn [file-name]
           (map (sys/file-directory file-name)
                (fn [root-dir]
                  (-> (compile-module file-name root-dir root-dir)
                      (map (fn [loaded]
                             ((se/try
                                (comp (map loaded (fn [core-module]
                                                    (status "loaded" file-name))) 
                                      (se/throw (str "Could not load " file-name)))
                                (fn [err]
                                  (status (.val err))
                                  (se/throw (.val err))))
                              'dummy-state)))
                      extract))))))

  (let [p (promise)]
    (send output (fn [_]
                   (deliver p '_)))
    (extract p))
  (print-err 'done _LINE_))
