
;; 'core' is a virtual value. It is a hash map that all the symbols defined in this file will end up in.
;; It maps symbol literals to values
;; (def core {})

(inline C "#include <limits.h>\n")

;; There's a special hook in the compiler that will print the type of the input to this function
;; at compile time.
(defn show-type [x]
  x)

(defn is-type [x y]
  x)

(defn prefs [s v]
  ;; if you're using this function, you're so far off in the weeds, I can't help you
  ! StringBuffer s
  (inline C " prefs(extractStr(s_0), v_1);\nreturn(v_1);\n"))

(def Sequence (any-of List
                      Vector))
(def String (any-of StringBuffer
                    SubString))
(def HashMap (any-of HashCollisionNode
                     ArrayNode
                     BitmapIndexedNode))
(def FnOrArity (any-of Fn
                       FnArity))

(defn maybe [v]
  !returns (maybe-of (type-of v))

  ;; wrap `v` in a Maybe value
  (inline C Maybe "return(maybe((FnArity *)0, (Value *)0, v_0));"))

(def int-max (inline C "(Value *)&(Integer){IntegerType, -2, INT_MAX};"))
(def int-min (inline C "(Value *)&(Integer){IntegerType, -2, INT_MIN};"))
(def empty-list (inline C "(Value *)&empty_list_struct"))
(def empty-vector (inline C "(Value *)&empty_vect_struct"))

;; TODO: 'nothing' doesn't work right if it has bottom-type for contents
(def nothing (inline C Maybe "(Value *)&(Maybe){MaybeType, -2, 0}"))

(defn fn-apply [f args]
  ! FnOrArity f
  ! List args
  !returns (type-of-result f)
  ;; TODO: implement ArgsOf
  (inline C "return(fnApply(f_0, args_1));"))

(defn default-type-name [value]
  ;; Return the string of the name of the type of `value`
  (inline C StringBuffer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(integer_str(numVal));"))

(defn default-type-args [x]
  (inline C Vector "return(reifiedTypeArgs(x_0));"))

(defn get-refs [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->refs);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn default-get-type [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn mutate-vect-conj [v x]
  ! Vector v
  !returns (vector-of (any-of (type-of x)
                              (inner-type-of v)))

  (inline C Vector "return((Value *)mutateVectConj((Vector *)v_0, x_1));"))
