
;; 'core' is a virtual value. It is a hash map that all the symbols defined in this file will end up in.
;; It maps symbol literals to values
;; (def core {})

(inline C "#include <limits.h>\n")

;; There's a special hook in the compiler that will print the type of the input to this function
;; at compile time.
(defn show-type [x]
  x)

(defn is-type [x y]
  x)

(defn prefs [s v]
  ;; if you're using this function, you're so far off in the weeds, I can't help you
  ! StringBuffer s
  (inline C " prefs(extractStr(s_0), v_1);\nreturn(v_1);\n"))

(def Sequence (any-of List
                      Vector))
(def String (any-of StringBuffer
                    SubString))
(def HashMap (any-of HashCollisionNode
                     ArrayNode
                     BitmapIndexedNode))
(def FnOrArity (any-of Fn
                       FnArity))

(defn maybe [v]
  !returns (maybe-of (type-of v))

  ;; wrap `v` in a Maybe value
  (inline C Maybe "return(maybe((FnArity *)0, (Value *)0, v_0));"))

(def int-max (inline C "(Value *)&(Integer){IntegerType, -2, INT_MAX};"))
(def int-min (inline C "(Value *)&(Integer){IntegerType, -2, INT_MIN};"))
(def empty-list (inline C "(Value *)&empty_list_struct"))
(def empty-vector (inline C "(Value *)&empty_vect_struct"))

;; TODO: 'nothing' doesn't work right if it has bottom-type for contents
(def nothing (inline C Maybe "(Value *)&(Maybe){MaybeType, -2, 0}"))

(defn fn-apply [f args]
  ! FnOrArity f
  ! List args
  !returns (type-of-result f)
  ;; TODO: implement ArgsOf
  (inline C "return(fnApply(f_0, args_1));"))

(defn default-type-name [value]
  ;; Return the string of the name of the type of `value`
  (inline C StringBuffer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(integer_str(numVal));"))

(defn default-type-args [x]
  (inline C Vector "return(reifiedTypeArgs(x_0));"))

(defn get-refs [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->refs);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn default-get-type [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn mutate-vect-conj [v x]
  ! Vector v
  !returns (vector-of (any-of (type-of x)
                              (inner-type-of v)))

  (inline C Vector "return((Value *)mutateVectConj((Vector *)v_0, x_1));"))

(defn list-count [l]
  ! List l
  (inline C Integer "
   Value *numVal = integerValue(((List *)l_0)->len);
   dec_and_free(l_0, 1);
   return(numVal);"))

(defn list-map [l lf]
  ! (required-arities 1) f
  ! (list-of (type-of-arg lf 0)) l
  !returns (list-of (type-of-result lf))
  (inline C List "return(listMap(l_0, lf_1));"))

(defn list-concat [l]
  ! (list-of Sequence) l
  ;; !returns (list-of (inner-type-of (inner-type-of l)))
  (inline C "return(listConcat(l_0));"))

(defn add-numbers [x y]
  ;; TODO: reuse one of the parameters for the result if possible
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal + ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn subtract-numbers [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal - ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn mult-numbers [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal * ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn div [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    int denom = ((Integer *)y_1)->numVal;
    if (denom == 0) {
      fprintf(stderr, \"*** Can not divide by 0\\n\");
      abort();
    }
    Value *numVal = integerValue((int64_t)(((Integer *)x_0)->numVal / denom));
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn mod [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    int denom = ((Integer *)y_1)->numVal;
    if (denom == 0) {
      fprintf(stderr, \"*** Can not divide by 0\\n\");
      abort();
    }
    Value *numVal = integerValue(((Integer *)x_0)->numVal % denom);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn abort []
  (inline C Maybe
   "abort();
    return(nothing);"))

(defn vect-count [v]
  ! Vector v
  (inline C Integer "
   Value *result = integerValue(((Vector *)v_0)->count);
   dec_and_free(v_0, 1);
   return(result);"))

(def emptyBMI
  (inline C BitmapIndexedNode "(Value *)&emptyBMI"))

(defn bit-and [x y]
  ;; Bitwise AND two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitAnd(x_0, y_1));"))

(defn bit-or [x y]
  ;; Bitwise OR two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitOr(x_0, y_1));"))

(defn bit-xor [x y]
  ;; Bitwise XOR two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitXor(x_0, y_1));"))

(defn bit-shift-left [x y]
  ;; Bitwise left shift of x by y bits
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitShiftLeft(x_0, y_1));"))

(defn bit-shift-right [x y]
  ;; Bitwise right shift of x by y bits
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitShiftRight(x_0, y_1));"))

(defn bit-not [x]
  ;; Bitwise NOT single integer value
  ! Integer x
  (inline C Integer "return(bitNot(x_0));"))

(defn deliver [p v]
  ;; Deliver value `v` to any thread waiting on promise `p`. Any thread that
  ;; calls `extract` on `p` after this will return with `v` immediately without waiting
  ! Promise p
  !returns (promise-of (type-of v))
  (inline C Promise "return(deliverPromise(p_0, v_1));"))

(defn delivered [p]
  ;; Test whether a value has been delivered for promise `p`
  ! Promise p
  !returns (maybe-of (type-of p))
  (inline C Maybe "return(promiseDelivered(p_0));"))

(defn cons [x l]
  ;; Add a value `x` to the head of list `l`
  ! List l
  !returns (list-as [(type-of x)] (type-of l))
  (inline C List "
   Value *listVal = (Value *)listCons(x_0, (List *)l_1);
   return(listVal);\n"))

(defn sha1-init []
  (inline C Opaque "return(malloc_sha1());"))

(defn sha1-finalize [ctxt]
  ! Opaque ctxt
  (inline C Integer "return(finalize_sha1(ctxt_0));"))

(defn sha1-update-type [x ctxt]
  (inline C Integer "
  Sha1Update(((Opaque *)ctxt_1)->ptr, (void *)&((Integer *)x_0)->type, 8);
  dec_and_free(x_0, 1);
  return(ctxt_1);
"))

(defn address-of [x]
  (inline C Integer "return(integerValue((long long)x_0));"))

(defn identical [x y]
  ;; Returns a `maybe` value if and only if the `x` and `y` reside at the same address in memory
  !returns (maybe-of (type-of x))

  (inline C Maybe "
  if (x_0 == y_1) {
    dec_and_free(y_1, 1);
    return(maybe((FnArity *)0, (Value *)0, x_0));
  } else {
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(nothing);
  }"))

(defn fn-name [f]
  ! Fn f
  (inline C StringBuffer "
  Value *strVal = stringValue(((Function *)f_0)->name);
  dec_and_free(f_0, 1);
  return(strVal);"))

(defn maybe-map [mv f]
  ! (maybe-of (type-of-arg f 0)) mv
  ! (required-arities 1) f
  !returns (maybe-of (type-of-result f))

  (inline C Maybe "return(maybeMap(mv_0, f_1));"))
