
;; 'core' is a virtual value. It is a hash map that all the symbols defined in this file will end up in.
;; It maps symbol literals to values
;; (def core {})

(inline C "#include <limits.h>\n")

;; There's a special hook in the compiler that will print the type of the input to this function
;; at compile time.
(defn show-type [x]
  x)

(defn is-type [x y]
  x)

(defn prefs [s v]
  ;; if you're using this function, you're so far off in the weeds, I can't help you
  ! StringBuffer s
  (inline C " prefs(extractStr(s_0), v_1);\nreturn(v_1);\n"))

(def Sequence (any-of List
                      Vector))
(def String (any-of StringBuffer
                    SubString))
(def HashMap (any-of HashCollisionNode
                     ArrayNode
                     BitmapIndexedNode))
(def FnOrArity (any-of Fn
                       FnArity))

(defn maybe [v]
  !returns (maybe-of (type-of v))

  ;; wrap `v` in a Maybe value
  (inline C Maybe "return(maybe((FnArity *)0, (Value *)0, v_0));"))

(def int-max (inline C "(Value *)&(Integer){IntegerType, -2, INT_MAX};"))
(def int-min (inline C "(Value *)&(Integer){IntegerType, -2, INT_MIN};"))
(def empty-list (inline C "(Value *)&empty_list_struct"))
(def empty-vector (inline C "(Value *)&empty_vect_struct"))

;; TODO: 'nothing' doesn't work right if it has bottom-type for contents
(def nothing (inline C Maybe "(Value *)&(Maybe){MaybeType, -2, 0}"))

(defn fn-apply [f args]
  ! FnOrArity f
  ! List args
  !returns (type-of-result f)
  ;; TODO: implement ArgsOf
  (inline C "return(fnApply(f_0, args_1));"))

(defn default-type-name [value]
  ;; Return the string of the name of the type of `value`
  (inline C StringBuffer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(integer_str(numVal));"))

(defn default-type-args [x]
  (inline C Vector "return(reifiedTypeArgs(x_0));"))

(defn get-refs [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->refs);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn default-get-type [value]
  (inline C Integer "
    Value *numVal = integerValue(value_0->type);
    dec_and_free(value_0, 1);
    return(numVal);"))

(defn mutate-vect-conj [v x]
  ! Vector v
  !returns (vector-of (any-of (type-of x)
                              (inner-type-of v)))

  (inline C Vector "return((Value *)mutateVectConj((Vector *)v_0, x_1));"))

(defn list-count [l]
  ! List l
  (inline C Integer "
   Value *numVal = integerValue(((List *)l_0)->len);
   dec_and_free(l_0, 1);
   return(numVal);"))

(defn list-map [l lf]
  ! (required-arities 1) f
  ! (list-of (type-of-arg lf 0)) l
  !returns (list-of (type-of-result lf))
  (inline C List "return(listMap(l_0, lf_1));"))

(defn list-concat [l]
  ! (list-of Sequence) l
  ;; !returns (list-of (inner-type-of (inner-type-of l)))
  (inline C "return(listConcat(l_0));"))

(defn add-numbers [x y]
  ;; TODO: reuse one of the parameters for the result if possible
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal + ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn subtract-numbers [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal - ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn mult-numbers [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)x_0)->numVal * ((Integer *)y_1)->numVal);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn div [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    int denom = ((Integer *)y_1)->numVal;
    if (denom == 0) {
      fprintf(stderr, \"*** Can not divide by 0\\n\");
      abort();
    }
    Value *numVal = integerValue((int64_t)(((Integer *)x_0)->numVal / denom));
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn mod [x y]
  ! Integer x
  ! Integer y
  (inline C Integer "
    int denom = ((Integer *)y_1)->numVal;
    if (denom == 0) {
      fprintf(stderr, \"*** Can not divide by 0\\n\");
      abort();
    }
    Value *numVal = integerValue(((Integer *)x_0)->numVal % denom);
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(numVal);"))

(defn abort []
  (inline C Maybe
   "abort();
    return(nothing);"))

(defn vect-count [v]
  ! Vector v
  (inline C Integer "
   Value *result = integerValue(((Vector *)v_0)->count);
   dec_and_free(v_0, 1);
   return(result);"))

(def emptyBMI
  (inline C BitmapIndexedNode "(Value *)&emptyBMI"))

(defn bit-and [x y]
  ;; Bitwise AND two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitAnd(x_0, y_1));"))

(defn bit-or [x y]
  ;; Bitwise OR two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitOr(x_0, y_1));"))

(defn bit-xor [x y]
  ;; Bitwise XOR two integer values
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitXor(x_0, y_1));"))

(defn bit-shift-left [x y]
  ;; Bitwise left shift of x by y bits
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitShiftLeft(x_0, y_1));"))

(defn bit-shift-right [x y]
  ;; Bitwise right shift of x by y bits
  ! Integer x
  ! Integer y
  (inline C Integer "return(bitShiftRight(x_0, y_1));"))

(defn bit-not [x]
  ;; Bitwise NOT single integer value
  ! Integer x
  (inline C Integer "return(bitNot(x_0));"))

(defn deliver [p v]
  ;; Deliver value `v` to any thread waiting on promise `p`. Any thread that
  ;; calls `extract` on `p` after this will return with `v` immediately without waiting
  ! Promise p
  !returns (promise-of (type-of v))
  (inline C Promise "return(deliverPromise(p_0, v_1));"))

(defn delivered [p]
  ;; Test whether a value has been delivered for promise `p`
  ! Promise p
  !returns (maybe-of (type-of p))
  (inline C Maybe "return(promiseDelivered(p_0));"))

(defn cons [x l]
  ;; Add a value `x` to the head of list `l`
  ! List l
  !returns (list-as [(type-of x)] (type-of l))
  (inline C List "
   Value *listVal = (Value *)listCons(x_0, (List *)l_1);
   return(listVal);\n"))

(defn sha1-init []
  (inline C Opaque "return(malloc_sha1());"))

(defn sha1-finalize [ctxt]
  ! Opaque ctxt
  (inline C Integer "return(finalize_sha1(ctxt_0));"))

(defn sha1-update-type [x ctxt]
  (inline C Integer "
  Sha1Update(((Opaque *)ctxt_1)->ptr, (void *)&((Integer *)x_0)->type, 8);
  dec_and_free(x_0, 1);
  return(ctxt_1);
"))

(defn address-of [x]
  (inline C Integer "return(integerValue((long long)x_0));"))

(defn identical [x y]
  ;; Returns a `maybe` value if and only if the `x` and `y` reside at the same address in memory
  !returns (maybe-of (type-of x))

  (inline C Maybe "
  if (x_0 == y_1) {
    dec_and_free(y_1, 1);
    return(maybe((FnArity *)0, (Value *)0, x_0));
  } else {
    dec_and_free(x_0, 1);
    dec_and_free(y_1, 1);
    return(nothing);
  }"))

(defn fn-name [f]
  ! Fn f
  (inline C StringBuffer "
  Value *strVal = stringValue(((Function *)f_0)->name);
  dec_and_free(f_0, 1);
  return(strVal);"))

(defn maybe-map [mv f]
  ! (maybe-of (type-of-arg f 0)) mv
  ! (required-arities 1) f
  !returns (maybe-of (type-of-result f))

  (inline C Maybe "return(maybeMap(mv_0, f_1));"))

(defn str-malloc [len]
  ! Integer len
  (inline C StringBuffer "
  String *strVal = malloc_string(((Integer *)len_0)->numVal);
  strVal->len = 0;
  strVal->buffer[0] = 0;
  dec_and_free(len_0, 1);
  return((Value *)strVal);\n"))

(defn str-append [dest src]
  ! StringBuffer dest
  ! String src
  (inline C StringBuffer "
  String *s_1 = (String *)dest_0;
  if (src_1->type == StringBufferType) {
    String *s2 = (String *)src_1;
    strncat(s_1->buffer, s2->buffer, s2->len);
    s_1->len += s2->len;
  } else if (src_1->type == SubStringType) {
    fprintf(stderr, \"appending to SubSting\\n\");
    abort();
    SubString *s2 = (SubString *)src_1;
    strncat(s_1->buffer, s2->buffer, s2->len);
    s_1->len += s2->len;
  }
  dec_and_free(src_1, 1);
  return(dest_0);"))

(defn pr* [str]
  ! String str
  (inline C Integer "return(prSTAR(str_0));"))

(defn pr-err* [str]
  ! String str
  (inline C Integer "return((*prErrSTAR)(str_0));"))

(defn escape-chars [s]
  ! String s
  (inline C StringBuffer "return(escapeChars(s_0));"))

(defn char [n]
  ;; Convert an integer to a one-character string
  ! Integer n
  (inline C StringBuffer "
  String *strVal = malloc_string(2);
  strVal->len = 1;
  strVal->buffer[0] = ((Integer *)n_0)->numVal;
  strVal->buffer[1] = 0;
  dec_and_free(n_0, 1);
  return((Value *)strVal);\n"))

(defn char-code [c]
  ;; Convert the first character of a string to an integer
  ! String c
  (inline C Integer "
   if (c_0->type == StringBufferType) {
     String *s = (String *)c_0;
     Value *numVal = integerValue((unsigned char)s->buffer[0]);
     dec_and_free(c_0, 1);
     return(numVal);
   } else if (c_0->type == SubStringType) {
     SubString *s = (SubString *)c_0;
     Value *numVal = integerValue((unsigned char)s->buffer[0]);
     dec_and_free(c_0, 1);
     return(numVal);
   }\n"))

(defn subs
  ;; Take a substring of a larger string
  ([src index]
   ! String src
   ! (min-value 0) index
   (inline C SubString "return(subs2(src_0, index_1));"))
  ([src index length]
   ! String src
   ! (min-value 0) index
   ! (min-value 0) length
   (inline C SubString "return(subs3(src_0, index_1, length_2));")))

(defn symbol [sym-str]
  ;; Convert a string to a symbol
  ! String sym-str
  (inline C Symbol "return(symbol(sym_str_0));"))

(defn add-promise-action [p f]
  ! Promise p
  ;; !returns (promise-of (result-of f))
  (inline C Promise "return(addPromiseAction((Promise *)p_0, f_1));"))

(defn promise
  ([] (inline C Promise "return((Value *)malloc_promise());\n"))
  ([v]
   ;; !returns (promise-of (type-of v))
   (deliver (promise) v)))

(defn future
  ([]
   (inline C Future "return(makeFuture((Value *)0));"))
  ([f]
   ! (required-arities 0) f
   (inline C Future "return(makeFuture(f_0));")))

(defn thread-id []
  (inline C Integer "return(integerValue((int64_t)pthread_self()));"))

(defn deliver-future [fut val]
  ! Future fut
  (inline C Future "return(deliverFuture(fut_0, val_1));"))

(defn add-future-action [fut f]
  ! Future fut
  (inline C Future "return(addFutureAction((Future *)fut_0, f_1));"))

(defn agent [v]
  (inline C Agent "return(makeAgent(v_0));"))

(defn integer-gen [x]
  (inline C Opaque "
  if (x_0->type != IntegerType) {
    fprintf(stderr, \"Invalid argument passed to 'integer-gen'\\n\");
    abort();
  }
  intGenerator *intGen = (intGenerator *)my_malloc(sizeof(intGenerator));
#ifdef CHECK_MEM_LEAK
  incTypeMalloc(14, 1);
#endif
  intGen->sym_counter = ((Integer *)x_0)->numVal;
  dec_and_free(x_0, 1);
  return((Value *)opaqueValue((void *)intGen, freeIntGenerator));
"))

(defn new-int [gen]
  ! Opaque gen
  (inline C Integer "
  intGenerator *gen = (intGenerator *)((Opaque *)gen_0)->ptr;
  dec_and_free(gen_0, 1);
  return(integerValue(gen->sym_counter++));
"))

(defn create-lazy []
  ;; private function used for implementing LazyList
  (inline C Opaque "
  extractCache *newCache = (extractCache *)my_malloc(sizeof(extractCache));
#ifdef CHECK_MEM_LEAK
  incTypeMalloc(14, 1);
#endif
  newCache->tail = malloc_list();
  pthread_mutex_init(&newCache->access, NULL);
  return((Value *)opaqueValue((void *)newCache, freeExtractCache));
"))

(defn get-lazy [lazy-struct]
  ! Opaque lazy-struct
  ;; private function used for implementing LazyList
  (inline C List "
  extractCache *cache = (extractCache *)((Opaque *)lazy_struct_0)->ptr;
  incRef((Value *)cache->tail, 1);
  dec_and_free(lazy_struct_0, 1);
  return((Value *)cache->tail);
"))

(defn first-lazy [lazy tail]
  ! List lazy
  ! Opaque tail
  ;; private function used for implementing LazyList
  (inline C Maybe "
  List *cache = (List *)lazy_0;
  extractCache *tail = (extractCache *)((Opaque *)tail_1)->ptr;
  if (cache->head == (Value *)0) {
    pthread_mutex_lock(&tail->access);
    if (cache->head == (Value *)0) {
      // leave the mutex locked and return nothing
      dec_and_free(lazy_0, 1);
      dec_and_free(tail_1, 1);
      return(nothing);
    } else {
// TODO: untested code path
fprintf(stderr, \"first-lazy 4\\n\");
abort();
      pthread_mutex_unlock(&tail->access);
      incRef(cache->head, 1);
      dec_and_free(lazy_0, 1);
      dec_and_free(tail_1, 1);
      return(maybe((FnArity *)0, (Value *)0, cache->head));
    }
  } else {
    Value *head = cache->head;
    incRef(head, 1);
    dec_and_free(lazy_0, 1);
    dec_and_free(tail_1, 1);
    return(maybe((FnArity *)0, (Value *)0, head));
  }
"))

(defn append-to-lazy-tail [tail value]
  ! Opaque tail
  ;; private function used for implementing LazyList
  (inline C Maybe "
  extractCache *cacheTail = (extractCache *)((Opaque *)tail_0)->ptr;
  cacheTail->tail->head = value_1;
  cacheTail->tail->tail = malloc_list();
  List *original = cacheTail->tail;
  cacheTail->tail = cacheTail->tail->tail;
  incRef((Value *)cacheTail->tail, 1);
  dec_and_free(tail_0, 1);
  dec_and_free((Value *)original, 1);
  pthread_mutex_unlock(&cacheTail->access);
  return(nothing);
"))

(defn rest-of-lazy [lazy]
  ! List lazy
  ;; private function used for implementing LazyList
  (inline C List "
  List *cache = (List *)lazy_0;
  Value *result;
  result = (Value *)cache->tail;
  incRef(result, 1);
  dec_and_free(lazy_0, 1);
  return(result);
"))

(defn null-term [s]
  ! String s
  (inline C StringBuffer "return((Value *)nullTerm(s_0));\n"))

;; protocol for implementing the hash map type
(defprotocol HashMapNode
  (hash-seq [m l]
    ! HashMap m
    ! List l
    ;; TODO: add key/val type to result type
    !returns List
    )

  (hash-vec [m v]
    ! HashMap m
    ! Vector v
    !returns Vector
    )

  (get* [m k v hash shift]
    ! HashMap m
    ! Integer hash
    ! Integer shift
    ;; TODO: add val type to result type
    !returns Maybe
    )

  (assoc* [m k v hash shift]
    ! HashMap m
    ! Integer hash
    ! Integer shift
    ;; TODO: add key/val type to result type
    !returns HashMap
    )

  (dissoc* [m k hash shift]
    ! HashMap m
    ;; TODO: if k is a literal, remove from return type
    ! Integer hash
    ! Integer shift
    !returns HashMap
    ))

;; Internal protocol for types.
(defprotocol Type
  (has-field [x field]
    ;; TODO: in generated code, this constraint doesn't appear, so there's a runtime check
    !returns (maybe-of (type-of x))

    ;; Does the type have `field` defined for it
    nothing)

  (get-type [value]
    !returns Integer
    ;; Return the Integer representing the type of `value`
    (default-get-type value))

  (type-name [value]
    ;; Return the string of the name of the type of `value`
    !returns StringBuffer
    (default-type-name value))

  (type-args [x]
    !returns Vector
    ;; Return the values for all the fields of `x` in a vector
    (default-type-args x))

  ;; TODO: what does this even do or is used for?
  (type-mapping [x]
    !returns HashMap
    )

  (instance? [t x]
    ;; test whether `x` is of type `t`
    !returns (maybe-of (type-of x))
    ))

;; Definitions for the 'built-in' types
(def Integer
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(IntegerType, x_1));"))))

(def List
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(ListType, x_1));"))))

(def Maybe
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(MaybeType, x_1));"))))

(def Symbol
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(SymbolType, x_1));"))))

(def Vector
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(VectorType, x_1));"))))

(def Fn
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(FunctionType, x_1));"))))

(def Promise
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(PromiseType, x_1));"))))

(def Future
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(FutureType, x_1));"))))

(def Agent
  (reify
    Type
    (instance? [_ x]
      (inline C Maybe "return(checkInstance(AgentType, x_1));"))))

;; The core protocols of Toccata
;; A type does not have to implement all the protocols or even all of the
;; protocol functions of a given protocol. In fact, most won't

;; For types whose values can be converted to human-readable strings
(defprotocol Stringable
  (string-list [x]
    ;; Create a list of strings of that comprise the representation of `x`
    !returns (list-of String)
    )

  (show* [x indent]
    ! String indent

    ;; Create a string list to show the value `x`
    !returns (list-of String)
    ))

;; For types whose values can be composed
(defprotocol Composition
  (zero [x]
    ;; Produce a value with 'same' type as `x` that can be `comp`d with any value
    ;;`y` of the same type to return `y`
    )

  (comp* [x xs]
    ! Sequence xs
    ;; Compose a number of values of the 'same' type to produce a single value of
    ;; that type. `xs` is a list of values of same type as `x`.
    ;; `comp*` must be associative
    ))

(defn comp
  ;; Compose values using the `comp*` protocol fn.
  ([x] x)
  ([x & xs]
   (comp* x xs)))
