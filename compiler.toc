
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "cd0abb2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "fc41ca7"))
(add-ns b (module "base.toc"))
(add-ns ty (module "typer.toc"))
(add-ns cg (module "codegen.toc"))

(def lf "\n")
(def lflf "\n\n")

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (either (instance? se/Error context)
          (let [new (update context)]
            ;; either the update succeeds, so get the new context
            (either (or (instance? se/Error new)
                        (flat-map (instance? Vector new) second))
                    ;; or keep the existing context
                    context))))

(def core-start (promise))

(def _ (print-err 'creating-parser))
(def t1 (sys/clock_gettime))

(def code-gen (agent (b/CodeContext b/empty-constants
                                    [])))

(def parse-forms
  (rd/parser
   (apply-to (fn [x]
               ;; (b/status 'done-parsing _LINE_
               ;;         (.file (ast/location x))  (count x) 'forms)
               x)
             (grmr/none-or-more
              (grmr/any (reify
                          Type
                          (type-name [_]
                            (str "Reified at: " _FILE_ ": " _LINE_))

                          Container
                          (map [x f]
                            x)

                          (map [x f embed]
                            (embed x))

                          rd/Parser
                          (rd/parse [p s]
                            (either (for [result-prom (get-in s [.values 'result-prom])
                                          :when (delivered result-prom)]
                                      (extract result-prom))
                                    rd/parser-fail)))
                        (apply-to (fn [type-checker result-prom ast]
                                    ;; (b/status 'ast _LINE_ ast)
                                    (send type-checker update-context
                                          (for [;; (b/se-debug 'checking _LINE_ (ast/location ast))
                                                checked (se/try
                                                          (comp (ty/check-ast ast)
                                                                (b/compilation-error
                                                                 "Could not type check expression at "
                                                                 lflf ast
                                                                 (ast/location ast)))
                                                          (fn [err]
                                                            (deliver result-prom err)
                                                            (se/throw (.val err))))
                                                mod (se/update-state identity)]
                                            (do
                                              (send code-gen
                                                    update-context
                                                    (cg/emit-code checked mod))
                                              checked)))
                                    ast)
                                  (grmr/get-value 'type-checker)
                                  (grmr/get-value 'result-prom)
                                  rdr/top-level))))
   ;; (grmr/all
    
   ;;  (apply-to (fn [file-name]
   ;;              (b/status 'parsing-time file-name (div (sys/time-delta (extract core-start)
   ;;                                                                   (sys/clock_gettime))
   ;;                                                   1000))
   ;;              file-name)
   ;;            (grmr/get-value 'file-name)))
   ))

(def _ (print-err 'parser-created (div (sys/time-delta t1 (sys/clock_gettime))
                                       1000)))

(defn compile-module [file-name root-dir proj-dir module-index core-mod]
  ;; kick off a thread to load and check the module
  (b/status "Loading" file-name)
  ;; try to open file for reading
  (either (map (fio/file-in (c/file-name file-name))
               (fn [file-in]
                 ;; if opened, parse and type check it
                 (let [ast-checker (agent (b/new-module file-name module-index core-mod))
                       loading (promise)
                       parse-result (parse-forms {'file-name file-name
                                                  'root-directory root-dir
                                                  'project-directory proj-dir
                                                  'line-number 1
                                                  'type-checker ast-checker
                                                  'result-prom loading}
                                                 (lazy-list file-in))]
                   (cond (instance? rd/ParserError parse-result)
                         (do
                           (b/status (.msg parse-result))
                           (b/wait-for-err-out)
                           (abort))

                         ;; after all expressions have been checked,
                         ;; deliver the resulting b/Module
                         (send ast-checker (fn [mod]
                                             (cond (instance? b/Module mod)
                                                   (b/status "Loaded" file-name)

                                                   (either (map (instance? se/Error mod)
                                                                (fn [err]
                                                                  (b/status (.val err))
                                                                  (b/wait-for-err-out)
                                                                  (and (= b/core file-name)
                                                                       (abort))))
                                                           (b/status "Could not load Toccata file:"
                                                                   file-name)))
                                             (send b/modules (fn [modules]
                                                               (assoc modules file-name mod)))
                                             (deliver loading mod))))
                   loading)))

          ;; or tell everyone it couldn't be
          (do
            (send b/err-out (fn [_]
                              (print-err "Could not find/open " file-name)
                              (abort)))
            (b/wait-for-err-out))))

(main [[_ & params]]
  (deliver core-start (sys/clock_gettime))
  (let [core-mod (cond (= 1 (count params))
                       (let [core-mod (-> (c/ToccataCore (str b/toccata-dir "/no-core.toc"))
                                          (compile-module b/toccata-dir b/toccata-dir 0 'no-core)
                                          extract)]
                         (send code-gen cg/fixup-core-dispatchers core-mod)
                         core-mod)

                       (extract (compile-module b/core b/toccata-dir b/toccata-dir 0 'core)))]
    (b/status 'time-for-core (div (sys/time-delta (extract core-start) (sys/clock_gettime)) 1000))

    ;; TODO: testing core types
    ;; (let [core-types (extract (compile-module "core-types.toc" toccata-dir toccata-dir 1 core-mod))]
    ;;   (cond (instance? b/Module core-types)
    ;;         (status "Loaded core-types")

    ;;         (do
    ;;           (either (map (instance? se/Error core-types)
    ;;                        (fn [err]
    ;;                          (status (.val err))
    ;;                          (b/wait-for-err-out)
    ;;                          (abort)))
    ;;                   (do
    ;;                     (status "Could not load core-types")
    ;;                     (b/wait-for-err-out)
    ;;                     (abort))))))

    (either (or (= 0 (count params))
                (map (and (= 1 (count params))
                          (first params))
                     (fn [file-name]
                       (let [mod-result (compile-module file-name b/toccata-dir b/toccata-dir
                                                        1 core-mod)]
                         (either (and (instance? Promise mod-result)
                                      (map (instance? b/Module (extract mod-result))
                                           (fn [core-mod]
                                             (let [done (promise)]
                                               (send code-gen cg/emit-main done core-mod)
                                               (extract done)))))

                                 '_)))))

            ;; for running assertion tests
            (-> (rest params)
                ;; TODO: empty-defn causes mem leaks
                ;; (remove (partial = "assertion-tests/empty-defn.toc"))
                (map (fn [file-name]
                       (future
                         (fn []
                           (map (sys/file-directory file-name)
                                (fn [root-dir]
                                  (let [
                                        ;; _ (send output (fn [_]
                                        ;;                  (fio/file-out (str file-name ".err"))))
                                        mod-result (compile-module file-name b/toccata-dir
                                                                   b/toccata-dir 1 core-mod)]
                                    (map (instance? Promise mod-result) extract))))))))
                (map extract)
                )))

  (cg/wait-for-output)
  (b/wait-for-err-out))
