
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "3928103"))
;; (def se-nop (se/state-error '_))

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "6184ccb"))

(extend-type Symbol
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(extend-type Integer
  Container
  ;; TODO: remove these
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(extend-type String
  Container
  (map [s _] s)
  (map [s _ embed] (embed s)))

(deftype ConstrainedAST [ast constraint]
  (assert (instance? c/Constraints constraint))

  Stringable
  (string-list [_]
    (list "(ConstrainedAST " (str ast "\n")
          (str constraint) ")"))

  Container
  (map [x f]
    (ConstrainedAST (f ast) (f constraint)))

  (map [x f embed]
    (for [new-ast (f (.ast x))
          new-constraint (f (.constraint x))]
      (ConstrainedAST new-ast new-constraint))))

(defprotocol TypeChecker
  (param-types [_]))

(def ListOrVect (any-of c/VectorConstraint
                        c/ListConstraint))

(defn set-items [c items]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.items c items)

                c))
        c))

(defn set-tail [c tail]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.tail-c c tail)

                c))
        c))

;; (def all-constraint-types [c/top-type
;;                            c/bottom-type
;;                            (c/InferredInner c/top-type empty-list c/no-symbol "")
;;                            (c/CollectionOf c/top-type empty-list c/no-symbol "")
;;                            c/int-constraint
;;                            ;; TODO: put these back in and test
;;                            ;; c/type-of-constraint
;;                            ;; c/inner-type-of-constraint
;;                            c/fn-constraint
;;                            c/sym-constraint
;;                            c/vect-constraint
;;                            c/list-constraint
;;                            c/substr-constraint
;;                            c/strbuff-constraint
;;                            c/string-constraint
;;                            c/hash-coll-constraint
;;                            c/hashmap-constraint
;;                            c/maybe-constraint
;;                            c/set-constraint
;;                            c/agent-constraint
;;                            c/promise-constraint
;;                            c/future-constraint
;;                            c/opaque-constraint
;;                            (c/DebugConstraint c/top-type empty-list c/no-symbol "")
;;                            (c/ParamConstraint 'arity-id 0 [] empty-list c/no-symbol "")
;;                            (c/SetField (c/Field (symbol ".set-map")) c/hashmap-constraint)
;;                            (c/GetField (c/Field (symbol ".set-map")))
;;                            (c/GetInnerType empty-list)
;;                            (c/CallValue [] empty-list c/no-symbol "")
;;                            (c/ModSeqType c/ListFrom 'v (list) 'result "")
;;                            (c/ModSeqType c/VectFrom 'v (list) 'result "")
;;                            (c/ReifiedConstraint 35 {(c/Field (symbol ".set-map")) c/top-type}
;;                                                 (symbol "HashSet")
;;                                                 {2 (c/fn-arity
;;                                                     'f (c/ListConstraint
;;                                                         [(c/ReifiedConstraint 35 {(c/Field (symbol ".set-map"))
;;                                                                                   c/top-type}
;;                                                                               (symbol "HashSet")
;;                                                                               {} (list)  c/no-symbol "")
;;                                                          c/top-type] (c/NoValues []) (list) c/no-symbol "")
;;                                                     c/top-type)}
;;                                                 (list)  c/no-symbol "")
;;                            (c/FnConstraint {1 (c/fn-arity
;;                                                'x (c/ListConstraint [c/top-type]
;;                                                                     (c/CollectionOf c/top-type (list )
;;                                                                                     c/no-symbol "")
;;                                                                     (list) c/no-symbol "")
;;                                                c/top-type)}
;;                                            (list) c/no-symbol "")
;;                            (c/ArgOf 'f 1 empty-list c/no-symbol "")
;;                            ])


(defn test-intersect [c1 c2]
  (let [final-1 (c/intersect c1 c2)
        ;; _ (print-err 'final-1 final-1)
        final-2 (c/intersect c2 c1)]
    ;; (print-err 'final-2 final-2)
    (either (map (= final-2 final-1)
                 (fn [c]
                   ;; (either (map (instance? c/NoValues c)
                   ;;              (fn [_]
                   ;;                (c/conflicting-assertions c _FILE_ _LINE_)
                   ;;                (print-err 'c c)))
                   ;;         (print-err 'final-c c))
                   final-1))
            (do
              (print-err "FAIL!! 'c/intersect not commutative")
              (print-err 'c1 c1)
              (print-err 'c2 c2)
              (print-err final-1)
              (print-err final-2)))) )

(def _  (print-err
         (test-intersect
          (c/SymbolConstraint c/no-symbol (list) c/no-symbol "")
          (c/SymbolConstraint 's (list) c/no-symbol ""))))

;; (defn drop-until [coll pred]
;;   (cond (flat-map (first coll) pred)
;;         coll

;;         (drop-until (rest coll) pred)))

;; (def _ (for [c1 all-constraint-types
;;              c2 (drop-until all-constraint-types (partial = c1))]
;;          (test-intersect c1 c2)))
  
;; (def arity-sym 'fn-arity843)
;; (def c1 (c/ParamConstraint
;;          'fn-arity843 0
;;          [(c/ListConstraint [] (c/CollectionOf
;;                                 (c/ParamConstraint 'fn-arity843 1
;;                                                    [(c/ArgOf 'q 0 (list) c/no-symbol "")]
;;                                                    (list) 'q "")
;;                                 (list ) c/no-symbol "")
;;                             (list) 'x "")]
;;          (list) 'x ""))

;; (def param-cs [(c/ListConstraint [(c/IntegerConstraint 1 2147483647 -2147483648 (list) c/no-symbol "")]
;;                                  (c/NoValues []) (list) c/no-symbol "")
;;                (c/FnConstraint
;;                 {1 (c/fn-arity 'fn-arity844
;;                                (c/ListConstraint
;;                                 [(c/ParamConstraint 'fn-arity844 0
;;                                                     [(c/SumConstraint
;;                                                       [(c/StrBuffConstraint c/no-string (list) c/no-symbol "")
;;                                                        (c/SubStrConstraint c/no-string (list) c/no-symbol "")]
;;                                                       (list) 'src "")]
;;                                                     (list) 'x "")]
;;                                 (c/NoValues []) (list) c/no-symbol "")
;;                                (c/SubStrConstraint c/no-string (list) c/no-symbol ""))}
;;                 (list) c/no-symbol "")])
;; (def _ (print-err (c/reify-type-constraint c1 arity-sym param-cs (c/Location "burp" 33))))

;; (def _  (print-err (c/full-param-constraint
;;                     (c/ParamConstraint
;;                      'fn-arity17 0
;;                      [(c/ListConstraint
;;                        [] (c/CollectionOf
;;                            (c/ParamConstraint 'fn-arity17 1
;;                                               [(c/ArgOf 'lufa 0 (list) c/no-symbol "")]
;;                                               (list) 'lufa "") (list ) c/no-symbol "") (list) 'boogity "")]
;;                      (list) 'boogity ""))))

(main [_]
  ;; (let [c (c/ParamConstraint 'IntGenerator_invoke 1 [] (list) c/no-symbol "")
  ;;       arity 'arity
  ;;       loc (c/Location "" 88)
  ;;       stage-1 (for [new-mods (se/traverse (.mods c)
  ;;                                           (fn [mod]
  ;;                                             (apo (fn [c]
  ;;                                                    (c/reify-c c arity loc))
  ;;                                                  mod
  ;;                                                  se/state-error)))
  ;;                     param-c (se/get-val (.param-index c))]
  ;;                 (Left (reduce new-mods param-c (fn [c mod]
  ;;                                                  ;; (and (instance? ParamConstraint mod)
  ;;                                                  ;;      (do
  ;;                                                  ;;        (print-err 'boomerity _FILE_ _LINE_)
  ;;                                                  ;;        (print-err 'loc loc)
  ;;                                                  ;;        (print-err 'c c)
  ;;                                                  ;;        (print-err 'mod mod)
  ;;                                                  ;;        (abort)))
  ;;                                                  (c/intersect mod c)))))
  ;;       upd (se/update-state identity)
  ;;       stage-2 (map upd
  ;;                    (fn [params]
  ;;                      (print-err "Missing impl" _FILE_ _LINE_
  ;;                                 "\nat: " loc 'arity-id arity
  ;;                                 "\n\n" 'param-c c
  ;;                                 "\n\n" 'params params)
  ;;                      (Left 'wtf)))]
  ;;   (print-err 'stage-1 stage-1)
  ;;   (print-err 'upd upd)
  ;;   (print-err 'stage-2 stage-2)
  ;;   (print-err ((comp* (se/get-val (.param-index c))
  ;;                      (list (map (se/update-state identity)
  ;;                                 (fn [params]
  ;;                                   (print-err "Missing impl" _FILE_ _LINE_
  ;;                                              "\nat: " loc 'arity-id arity
  ;;                                              "\n\n" 'param-c c
  ;;                                              "\n\n" 'params params)
  ;;                                   (Left c/top-type)))))
  ;;               [c/top-type])))

  'done)

;; Design

;; Pass through of dynamic value with literal fields
;; Pass through of dynamic value with updated fields
;; Construct dyn value with apply
;; Update field of dyn value with literal in fun
;; Update field of dyn value with parameter in fun
;; Constrain fields of dynamic param
;; Update an updated field of dyn value with parameter in fun
;; Return field of dyn param. Pass through or updated.
;; All the above nested
;; All the above with dyn values re-named in 'let'
;; All the above for multiple fields in a dyn value on same call
