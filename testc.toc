
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(def se-nop (se/state-error '_))

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "93536de"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "aa76558"))
(add-ns b (module "base.toc"))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(extend-type Symbol
  Container
  (map [x f] x)
  (map [x f embed] (embed x)))

(extend-type Integer
  Container
  ;; TODO: remove these
  (map [x f] x)
  (map [x f embed] (embed x)))

(extend-type String
  Container
  (map [s _] s)
  (map [s _ embed] (embed s)))

(deftype ProtoImpls [fn-sym default-impl impl-fns]
  (assert (instance? Symbol fn-sym))
  (assert (instance? c/FnConstraint default-impl))
  (assert (instance? (map-of Integer c/FnConstraint) impl-fns))

  Stringable
  (string-list [_]
    (list "(ProtoImpls '" (str fn-sym) "\n" (str default-impl) "\n\n" (str impl-fns) ")"))

  Container
  (map [x f]
    (ProtoImpls fn-sym
                (map default-impl f)
                (map-vals impl-fns f)))

  (map [x f embed]
    (for [def-impl (map default-impl f embed)
          impl-fns (contextual-map-vals impl-fns f embed)]
      (ProtoImpls fn-sym def-impl impl-fns)))

  c/Constraint
  (c/show-full [c]
    (comp (list (str "prototype " fn-sym))
          (c/show-full (.default-impl c))))

  (c/format-path [_ n]
    (c/format-path default-impl n))

  (c/assertion-path [_]
    (c/assertion-path default-impl))

  (c/intersect [x y]
    (let [new-c (cond (instance? ProtoImpls y)
                      (c/intersect default-impl (.default-impl y))
                      
                      (c/intersect default-impl y))]
      (either (= c/bottom-type new-c)
              x))))

(defprotocol TypeChecker
  (find-arity [ast type-num args-count]
    (assert-result r (instance? Maybe r)))

  (check-call-site [ast args target]
    (assert (instance? (vector-of b/ConstrainedAST) args))
    (assert-result x (instance? se/StateError x)))

  (call-site-checked [ast]
    (assert-result x (instance? se/StateError x))))

(def ListOrVect (any-of c/VectorConstraint
                        c/ListConstraint))

(defn set-items [c items]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.items c items)

                c))
        c))

(defn set-tail [c tail]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.tail-c c tail)

                c))
        c))

;; (def all-constraint-types [c/top-type
;;                            c/bottom-type
;;                            (c/InferredInner c/top-type empty-list c/no-symbol "")
;;                            (c/CollectionOf c/top-type empty-list c/no-symbol "")
;;                            c/int-constraint
;;                            ;; TODO: put these back in and test
;;                            ;; c/type-of-constraint
;;                            ;; c/inner-type-of-constraint
;;                            c/fn-constraint
;;                            c/sym-constraint
;;                            c/vect-constraint
;;                            c/list-constraint
;;                            c/substr-constraint
;;                            c/strbuff-constraint
;;                            c/string-constraint
;;                            c/hash-coll-constraint
;;                            c/hashmap-constraint
;;                            c/maybe-constraint
;;                            c/set-constraint
;;                            c/agent-constraint
;;                            c/promise-constraint
;;                            c/future-constraint
;;                            c/opaque-constraint
;;                            (c/DebugConstraint c/top-type empty-list c/no-symbol "")
;;                            (c/ParamConstraint 'arity-id 0 [] empty-list c/no-symbol "")
;;                            (c/SetField (c/Field (symbol ".set-map")) c/hashmap-constraint)
;;                            (c/GetField (c/Field (symbol ".set-map")))
;;                            (c/GetInnerType empty-list)
;;                            (c/CallValue [] empty-list c/no-symbol "")
;;                            (c/ModSeqType c/ListFrom 'v (list) 'result "")
;;                            (c/ModSeqType c/VectFrom 'v (list) 'result "")
;;                            (c/ReifiedConstraint 35 {(c/Field (symbol ".set-map")) c/top-type}
;;                                                 (symbol "HashSet")
;;                                                 {2 (c/fn-arity
;;                                                     'f (c/ListConstraint
;;                                                         [(c/ReifiedConstraint 35 {(c/Field (symbol ".set-map"))
;;                                                                                   c/top-type}
;;                                                                               (symbol "HashSet")
;;                                                                               {} (list)  c/no-symbol "")
;;                                                          c/top-type] (c/NoValues []) (list) c/no-symbol "")
;;                                                     c/top-type)}
;;                                                 (list)  c/no-symbol "")
;;                            (c/FnConstraint {1 (c/fn-arity
;;                                                'x (c/ListConstraint [c/top-type]
;;                                                                     (c/CollectionOf c/top-type (list )
;;                                                                                     c/no-symbol "")
;;                                                                     (list) c/no-symbol "")
;;                                                c/top-type)}
;;                                            (list) c/no-symbol "")
;;                            (c/ArgOf 'f 1 empty-list c/no-symbol "")
;;                            (c/ResultOf 'f empty-list c/no-symbol "")
;;                            ])


(defn drop-until [coll pred]
  (cond (flat-map (first coll) pred)
        coll

        (drop-until (rest coll) pred)))

(defn test-intersect [c1 c2]
  (let [final-1 (c/intersect c1 c2)
        ;; _ (print-err 'final-1 final-1)
        ;; _ (print-err "------")
        final-2 (c/intersect c2 c1)]
    ;; (print-err 'final-2 final-2)
    (either (map (= final-2 final-1)
                 (fn [c]
                   ;; (either (map (instance? c/NoValues c)
                   ;;              (fn [_]
                   ;;                (c/conflicting-assertions c _FILE_ _LINE_)
                   ;;                (print-err 'c c)))
                   ;;         (print-err 'final-c c))
                   final-1))
            (do
              (print-err "FAIL!! 'c/intersect not commutative")
              (print-err 'c1 c1)
              (print-err 'c2 c2)
              (print-err final-1)
              (print-err final-2)))) )

(def _
  (-> (test-intersect
       (c/ArgOf 'f 0 empty-list c/no-symbol "")
       c/top-type)
      print-err))

(def _
  (-> (test-intersect
       c/top-type
       (c/AritiesRequired [1] empty-list 'f ""))
      print-err))

;; (def _ (print-err (=* (c/ComputedConstraint 
;;                        [(c/AritiesRequired [1] empty-list 'f "")
;;                         (c/ArgOf 'f 0 empty-list c/no-symbol "")]
;;                        [] empty-list 'f "")
;;                       (c/ComputedConstraint 
;;                        [(c/AritiesRequired [1] empty-list 'f "")
;;                         (c/ArgOf 'f 0 empty-list c/no-symbol "")]
;;                        [] empty-list 'f ""))))

;; (def _
;;   (print-err (c/full-param-constraint
;;               (c/ComputedConstraint 
;;                [(c/ComputedConstraint 
;;                  [(c/ArgOf 'f 0 (list) c/no-symbol "")]
;;                  empty-list 'f "")

;;                 (c/IntegerConstraint 1 2147483647 -2147483648 (list) c/no-symbol "")]
;;                empty-list 'mv ""))))

;; (def _ (for [c1 all-constraint-types
;;              c2 (drop-until all-constraint-types (partial = c1))]
;;          (test-intersect c1 c2)))
  
;; (def _ (print-err (-> c/fn-constraint
;;                       (.arities (select-keys (.arities c/fn-constraint)
;;                                              [5])))))

;; (def arity-sym 'fn-arity28)
;; (def c1 
;;   (c/fn-arity 'fn-arity28
;;               (c/ListConstraint [(c/ParamConstraint 'fn-arity28 0 empty-list 'x "")
;;                                  (c/ComputedConstraint 
;;                                   [(c/ParamConstraint 'fn-arity28 1 empty-list 'l "")
;;                                    (c/ListConstraint []
;;                                                      (c/CollectionOf
;;                                                       c/top-type empty-list c/no-symbol "") empty-list 'l "")]
;;                                   [] empty-list 'l "")]
;;                                 (c/NoValues []) empty-list c/no-symbol "")
;;               (c/ListConstraint [(c/ParamConstraint 'fn-arity28 0 empty-list 'x "")]
;;                                 (c/ComputedConstraint 
;;                                  [(c/ParamConstraint 'fn-arity28 1 empty-list 'l "")
;;                                   (c/ListConstraint []
;;                                                     (c/CollectionOf
;;                                                      c/top-type empty-list c/no-symbol "") empty-list 'l "")
;;                                   (c/CollectionOf
;;                                    c/top-type empty-list c/no-symbol "")]
;;                                  [] empty-list 'l "") empty-list c/no-symbol ""))
;; )

;; (def param-cs
;;   [(c/SymbolConstraint 'a empty-list c/no-symbol "")
;;    c/no-tail
;;    (c/ListConstraint [] c/no-tail empty-list c/no-symbol "")])

;; (def _ (print-err (c/reify-type-constraint c1 arity-sym param-cs (c/Location "burp" 33))))

;; (def c1 (c/SumConstraint
;;          [(c/FnConstraint
;;            {2 (c/fn-arity 'a
;;                           (c/ListConstraint [c/top-type
;;                                              c/top-type]
;;                                             (c/NoValues [])
;;                                             (list) c/no-symbol "")
;;                           c/top-type)}
;;            (list) c/no-symbol "")
;;           (c/FnConstraint
;;            {2 (c/fn-arity 'flat-map
;;                           (c/ListConstraint
;;                            [(c/ParamConstraint 'fn-arity68 0
;;                                                [(c/MaybeConstraint c/top-type (list) c/no-symbol "")
;;                                                 (c/MaybeConstraint (c/ParamConstraint 'fn-arity68 1
;;                                                                                       [(c/ArgOf 'f 0 (list)
;;                                                                                                 c/no-symbol "")]
;;                                                                                       (list) 'f "")
;;                                                                    (list) 'mv "")
;;                                                 (c/MaybeConstraint c/top-type (list) c/no-symbol "")]
;;                                                (list) 'mv "")
;;                             (c/ParamConstraint 'fn-arity68 1
;;                                                [(c/FnConstraint
;;                                                  {1 (c/fn-arity 'a
;;                                                                 (c/ListConstraint
;;                                                                  [c/top-type]
;;                                                                  (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                                  (list) c/no-symbol "")
;;                                                                 (c/MaybeConstraint c/top-type (list)
;;                                                                                    c/no-symbol ""))}
;;                                                  (list) c/no-symbol "")]
;;                                                (list) 'f "")]
;;                            (c/NoValues []) (list) c/no-symbol "")
;;                           (c/ParamConstraint 'fn-arity68 1
;;                                              [(c/CallValue [c/top-type] (list) 'f "")
;;                                               (c/MaybeConstraint c/top-type (list) c/no-symbol "")]
;;                                              (list) 'f ""))}
;;            (list) c/no-symbol "")
;;           (c/FnConstraint
;;            {2 (c/fn-arity 'flat-map
;;                           (c/ListConstraint
;;                            [(c/ParamConstraint 'fn-arity82 0
;;                                                [(c/ListConstraint [] (c/CollectionOf c/top-type (list )
;;                                                                                      c/no-symbol "")
;;                                                                   (list) c/no-symbol "")
;;                                                 (c/ListConstraint
;;                                                  []
;;                                                  (c/CollectionOf (c/ParamConstraint 'fn-arity82 1
;;                                                                                     [(c/ArgOf 'lf 0 (list)
;;                                                                                               c/no-symbol "")]
;;                                                                                     (list) 'mf "")
;;                                                                  (list) c/no-symbol "")
;;                                                  (list) 'boogity "")
;;                                                 (c/ListConstraint
;;                                                  []
;;                                                  (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                  (list) c/no-symbol "")]
;;                                                (list) 'l "")
;;                             (c/ParamConstraint 'fn-arity82 1
;;                                                [(c/FnConstraint
;;                                                  {c/variadic
;;                                                   (c/fn-arity 'a (c/ListConstraint
;;                                                                   []
;;                                                                   (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                                                    (list) c/no-symbol "")
;;                                                               (c/ListConstraint
;;                                                                []
;;                                                                (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                                (list) c/no-symbol ""))}
;;                                                  (list) c/no-symbol "")]
;;                                                (list) 'mf "")]
;;                            (c/NoValues []) (list) c/no-symbol "")
;;                           (c/ParamConstraint 'fn-arity82 1
;;                                              [(c/CallValue c/no-args (list) c/no-symbol "")
;;                                               (c/SumConstraint
;;                                                [(c/ListConstraint
;;                                                  []
;;                                                  (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                  (list) c/no-symbol "")
;;                                                 (c/VectorConstraint
;;                                                  []
;;                                                  (c/CollectionOf c/top-type (list ) c/no-symbol "") (list)
;;                                                  c/no-symbol "")]
;;                                                (list) 'a "")
;;                                               (c/ListConstraint [] (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                                                 (list) c/no-symbol "")]
;;                                              (list) 'mf ""))}
;;            (list) c/no-symbol "")]
;;          (list) 'flat-map ""))

;; (def args [(c/ParamConstraint 'fn-arity98 0 [] (list) 'prev "") 
;;            (c/FnConstraint {1 (c/fn-arity 'fn-arity99
;;                                           (c/ListConstraint [(c/ParamConstraint 'fn-arity99 0 [] (list) 'prev "")]
;;                                                             (c/NoValues []) (list) c/no-symbol "")
;;                                           (c/MaybeConstraint (c/ParamConstraint 'fn-arity98 1 [] (list) 'v "")
;;                                                              (list) c/no-symbol ""))}
;;                            (list) c/no-symbol "")])

;; (def _ (print-err 'c1 c1))

;; (def c
;;   (ProtoImpls
;;    'hash-seq
;;    (c/FnConstraint
;;     {2 (c/fn-arity 'hash-seq
;;                    (c/ListConstraint
;;                     [(c/ComputedConstraint 
;;                       [(c/ParamConstraint 'hash-seq 0 (list) 'm "")

;;                        (c/SumConstraint
;;                         [(c/HashMapConstraint 11 {} c/top-type c/top-type (list) c/no-symbol "")

;;                          (c/HashMapConstraint 12 {} c/top-type c/top-type (list) c/no-symbol "")

;;                          (c/HashMapConstraint 13 {} c/top-type c/top-type (list) c/no-symbol "")]
;;                         (list) 'm "")]
;;                       (list) 'm "")
;;                      (c/ComputedConstraint 
;;                       [(c/ParamConstraint 'hash-seq 1 (list) 'l "")
;;                        (c/ListConstraint [] (c/CollectionOf c/top-type (list ) c/no-symbol "") (list) 'l "")]
;;                       (list) 'l "")]
;;                     (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                     (list) c/no-symbol "")
;;                    (c/ListConstraint [] (c/CollectionOf c/top-type (list ) c/no-symbol "")
;;                                      (list) 'result ""))}
;;     (list) c/no-symbol "")
;;    {}))

;; (def _ (apply print-err (map (cata c/show-full c) (partial str  "\n  "))))

(main [_]
  ;; (let [c (c/ParamConstraint 'IntGenerator_invoke 1 [] (list) c/no-symbol "")
  ;;       arity 'arity
  ;;       loc (c/Location "" 88)
  ;;       stage-1 (for [new-mods (se/traverse (.mods c)
  ;;                                           (fn [mod]
  ;;                                             (apo (fn [c]
  ;;                                                    (c/reify-c c arity loc))
  ;;                                                  mod
  ;;                                                  se/state-error)))
  ;;                     param-c (se/get-val (.param-index c))]
  ;;                 (Left (reduce new-mods param-c (fn [c mod]
  ;;                                                  ;; (and (instance? ParamConstraint mod)
  ;;                                                  ;;      (do
  ;;                                                  ;;        (print-err 'boomerity _FILE_ _LINE_)
  ;;                                                  ;;        (print-err 'loc loc)
  ;;                                                  ;;        (print-err 'c c)
  ;;                                                  ;;        (print-err 'mod mod)
  ;;                                                  ;;        (abort)))
  ;;                                                  (c/intersect mod c)))))
  ;;       upd (se/update-state identity)
  ;;       stage-2 (map upd
  ;;                    (fn [params]
  ;;                      (print-err "Missing impl" _FILE_ _LINE_
  ;;                                 "\nat: " loc 'arity-id arity
  ;;                                 "\n\n" 'param-c c
  ;;                                 "\n\n" 'params params)
  ;;                      (Left 'wtf)))]
  ;;   (print-err 'stage-1 stage-1)
  ;;   (print-err 'upd upd)
  ;;   (print-err 'stage-2 stage-2)
  ;;   (print-err ((comp* (se/get-val (.param-index c))
  ;;                      (list (map (se/update-state identity)
  ;;                                 (fn [params]
  ;;                                   (print-err "Missing impl" _FILE_ _LINE_
  ;;                                              "\nat: " loc 'arity-id arity
  ;;                                              "\n\n" 'param-c c
  ;;                                              "\n\n" 'params params)
  ;;                                   (Left c/top-type)))))
  ;;               [c/top-type])))

    'done)

;; Design

;; Pass through of dynamic value with literal fields
;; Pass through of dynamic value with updated fields
;; Construct dyn value with apply
;; Update field of dyn value with literal in fun
;; Update field of dyn value with parameter in fun
;; Constrain fields of dynamic param
;; Update an updated field of dyn value with parameter in fun
;; Return field of dyn param. Pass through or updated.
;; All the above nested
;; All the above with dyn values re-named in 'let'
;; All the above for multiple fields in a dyn value on same call
