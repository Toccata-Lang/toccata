
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "9e16fc9"))
;; (def se-nop (se/state-error '_))

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "3c94753"))

(extend-type Symbol
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(extend-type Integer
  Container
  ;; TODO: remove these
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(extend-type String
  Container
  (map [s _] s)
  (map [s _ embed] (embed s)))

(deftype ConstrainedAST [ast constraint]
  (assert (instance? c/Constraints constraint))

  Stringable
  (string-list [_]
    (list "(ConstrainedAST " (str ast "\n")
          (str constraint) ")"))

  Container
  (map [x f]
    (ConstrainedAST (f ast) (f constraint)))

  (map [x f embed]
    (for [new-ast (f (.ast x))
          new-constraint (f (.constraint x))]
      (ConstrainedAST new-ast new-constraint))))

(defprotocol TypeChecker
  (param-types [_]))

(def ListOrVect (any-of c/VectorConstraint
                        c/ListConstraint))

(defn set-items [c items]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.items c items)

                c))
        c))

(defn set-tail [c tail]
  (cata (fn [c]
          (cond (instance? ListOrVect c)
                (.tail-c c tail)

                c))
        c))

;; (def c1 (c/ParamConstraint 'AType-x-setter 0
;;                            [(c/SetField (c/Field (symbol ".x")) (c/ParamConstraint 'AType-x-setter 1
;;                                                                                    []
;;                                                                                    (list) c/no-symbol ""))
;;                             (c/ReifiedConstraint 65 {(c/Field (symbol ".x")) c/top-type}
;;                                                  (symbol "AType") (list) c/no-symbol "")]
;;                            (list) c/no-symbol ""))

;; (def args [(c/ReifiedConstraint 65 {(c/Field (symbol ".x"))
;;                                     (c/IntegerConstraint 9 2147483647 -2147483648 (list) c/no-symbol "")}
;;                                 (symbol "AType") (list) c/no-symbol "")
;;            (c/SymbolConstraint c/no-symbol (list) c/no-symbol "")])

(def all-constraint-types [c/top-type
                           c/bottom-type
                           (c/InferredInner c/top-type empty-list c/no-symbol "")
                           (c/CollectionOf c/top-type empty-list c/no-symbol "")
                           c/int-constraint
                           ;; TODO: put these back in and test
                           ;; c/type-of-constraint
                           ;; c/inner-type-of-constraint
                           c/fn-constraint
                           c/sym-constraint
                           c/vect-constraint
                           c/list-constraint
                           c/substr-constraint
                           c/strbuff-constraint
                           c/string-constraint
                           c/hash-coll-constraint
                           c/hashmap-constraint
                           c/maybe-constraint
                           c/set-constraint
                           c/agent-constraint
                           c/promise-constraint
                           c/future-constraint
                           c/opaque-constraint
                           (c/DebugConstraint c/top-type empty-list c/no-symbol "")
                           (c/ParamConstraint 'arity-id 0 [] empty-list c/no-symbol "")
                           (c/SetField (c/Field (symbol ".set-map")) c/hashmap-constraint)
                           (c/GetField (c/Field (symbol ".set-map")))
                           (c/GetInnerType empty-list)
                           (c/CallValue [] empty-list c/no-symbol "")
                           (c/ModSeqType c/ListFrom 'v (list) 'result "")
                           (c/ModSeqType c/VectFrom 'v (list) 'result "")
                          ])


(defn test-intersect [c1 c2]
  (let [final-1 (c/intersect c1 c2)
        ;; _ (print-err 'final-1 final-1)
        final-2 (c/intersect c2 c1)]
    ;; (print-err 'final-2 final-2)
    (either (map (= final-2 final-1)
                 (fn [c]
                   ;; (either (map (instance? c/NoValues c)
                   ;;              (fn [_]
                   ;;                (c/conflicting-assertions c _FILE_ _LINE_)
                   ;;                (print-err 'c c)))
                   ;;         (print-err 'final-c c))
                   final-1))
            (do
              (print-err "FAIL!! 'c/intersect not commutative")
              (print-err 'c1 c1)
              (print-err 'c2 c2)
              (print-err final-1)
              (print-err final-2)))) )

(defn drop-until [coll pred]
  (cond (flat-map (first coll) pred)
        coll

        (drop-until (rest coll) pred)))

(def arity-sym 'HashSet_invoke)
(def c1 (c/ReifiedConstraint 35 {(c/Field (symbol ".set-map"))
                                 (c/ParamConstraint 'HashSet_invoke 1 [] (list) c/no-symbol "")}
                             (symbol "HashSet")
                             {} (list)  c/no-symbol ""))

(def param-cs [(c/ReifiedConstraint
                63 {} (symbol "reified value at")
                {2 (c/fn-arity 'HashSet_invoke
                               (c/ListConstraint [c/top-type c/top-type] (c/NoValues []) (list) c/no-symbol "")
                               (c/ReifiedConstraint
                                35 {(c/Field (symbol ".set-map"))
                                    (c/ParamConstraint 'HashSet_invoke 1 [] (list) c/no-symbol "")}
                                (symbol "HashSet") {} (list)  c/no-symbol ""))}
                (list)  c/no-symbol "")
               c/top-type])

(main [_]
  ;; (let [c (c/ParamConstraint 'IntGenerator_invoke 1 [] (list) c/no-symbol "")
  ;;       arity 'arity
  ;;       loc (c/Location "" 88)
  ;;       stage-1 (for [new-mods (se/traverse (.mods c)
  ;;                                           (fn [mod]
  ;;                                             (apo (fn [c]
  ;;                                                    (c/reify-c c arity loc))
  ;;                                                  mod
  ;;                                                  se/state-error)))
  ;;                     param-c (se/get-val (.param-index c))]
  ;;                 (Left (reduce new-mods param-c (fn [c mod]
  ;;                                                  ;; (and (instance? ParamConstraint mod)
  ;;                                                  ;;      (do
  ;;                                                  ;;        (print-err 'boomerity _FILE_ _LINE_)
  ;;                                                  ;;        (print-err 'loc loc)
  ;;                                                  ;;        (print-err 'c c)
  ;;                                                  ;;        (print-err 'mod mod)
  ;;                                                  ;;        (abort)))
  ;;                                                  (c/intersect mod c)))))
  ;;       upd (se/update-state identity)
  ;;       stage-2 (map upd
  ;;                    (fn [params]
  ;;                      (print-err "Missing impl" _FILE_ _LINE_
  ;;                                 "\nat: " loc 'arity-id arity
  ;;                                 "\n\n" 'param-c c
  ;;                                 "\n\n" 'params params)
  ;;                      (Left 'wtf)))]
  ;;   (print-err 'stage-1 stage-1)
  ;;   (print-err 'upd upd)
  ;;   (print-err 'stage-2 stage-2)
  ;;   (print-err ((comp* (se/get-val (.param-index c))
  ;;                      (list (map (se/update-state identity)
  ;;                                 (fn [params]
  ;;                                   (print-err "Missing impl" _FILE_ _LINE_
  ;;                                              "\nat: " loc 'arity-id arity
  ;;                                              "\n\n" 'param-c c
  ;;                                              "\n\n" 'params params)
  ;;                                   (Left c/top-type)))))
  ;;               [c/top-type])))
  (print-err (c/reify-type-constraint c1 arity-sym param-cs (c/Location "burp" 33)))
  ;; (print-err (test-intersect (c/ListConstraint [] (c/NoValues []) (list) c/no-symbol "")
  ;;                            (c/ModSeqType c/VectFrom 'v (list) 'result "")))
  ;; (string-list (c/ModSeqType c/ListFrom 'v (list) 'result ""))

  ;; (for [c1 all-constraint-types
  ;;       c2 (drop-until all-constraint-types (partial = c1))]
  ;;   (test-intersect c1 c2))
  
  'done)

;; Design

;; Pass through of dynamic value with literal fields
;; Pass through of dynamic value with updated fields
;; Construct dyn value with apply
;; Update field of dyn value with literal in fun
;; Update field of dyn value with parameter in fun
;; Constrain fields of dynamic param
;; Update an updated field of dyn value with parameter in fun
;; Return field of dyn param. Pass through or updated.
;; All the above nested
;; All the above with dyn values re-named in 'let'
;; All the above for multiple fields in a dyn value on same call
