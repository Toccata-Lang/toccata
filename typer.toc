
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "90b9152"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "792416c"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "f8eb07a"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
;; (add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
;;                            "free.toc"
;;                            :sha "5c353f2"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(def output (agent nothing))

(defn status [& msg]
  (send output (fn [out-file?]
                 (assert (instance? Maybe out-file?))

                 (apply print-err msg)
                 (map out-file?
                      (fn [out-file]
                        (fio/write out-file (str (to-str (interpose msg " ")) "\n"))
                        out-file)))))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(def core (c/ToccataCore path-to-core))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(defn new-module [file-name module-index]
  (Module file-name module-index {} {}
          c/core-type-constraints
          (list {'empty-list (c/update-sym c/empty-list-constraint
                                           'empty-list)
                 'empty-vector (c/update-sym c/empty-vect-constraint
                                             'empty-vector)
                 'int-max (assoc-in c/int-constraint
                                    [.fields 'static-value] int-max)
                 'int-min (assoc-in c/int-constraint
                                    [.fields 'static-value] int-min)
                 'nothing (assoc-in c/maybe-constraint
                                    [.fields 'contents]
                                    c/no-contents)})))

(defprotocol TypeChecker
  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       "\n" (type-name ast) ast
                       "\n\n" constraint))

  (recover-val-type [x]
    (assert-result x (instance? se/StateError x))

    (se/state-error x))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast))

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       "\n" (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(defn type-check-ast [ast]
  (cond (and (= c/bottom-type ast)
             (first (.constraints ast)))
        (compilation-error (conf-ass _LINE_ ast (ast/location ast)))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (status 'type-checking _LINE_ loc
              ;;                 "\n" 'ast ast
              ;;                 "\n\n" 'new-ast new-ast)]
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                             "\n\n" 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and (extract flag)
            ;;        (maybe (print-err 'final-ast _LINE_ loc
            ;;                          "\n" final-ast))))
            final-ast))))

(def _ (print-err 'creating-parser))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (apply-to (fn [type-checker ast]
                (status 'ast _LINE_ ast)
                (send type-checker update-context
                      (se/try
                        (comp (type-check-ast ast)
                              (compilation-error "Could not type check code for expression at "
                                                 (ast/location ast)))
                        (fn [err]
                          (wait-for-output)
                          (print-err (.val err))
                          (abort))))
                ast)
              (grmr/get-value 'type-checker)
              rdr/top-level))))
(def _ (print-err 'parser-created))

(defn compile-module [file-name root-dir proj-dir module-index]
  ;; kick off a thread to load and check the module
  (status "Loading" file-name)
  ;; try to open file for reading
  (either (map (fio/file-in (c/file-name file-name))
               (fn [file-in]
                 ;; if opened, parse and type check it
                 (let [ast-checker (agent (new-module file-name module-index))
                       loading (promise)
                       parse-result (parse-forms {'file-name file-name
                                                  'root-directory root-dir
                                                  'project-directory proj-dir
                                                  'line-number 1
                                                  'type-checker ast-checker
                                                  'result-prom loading}
                                                 (lazy-list file-in))]
                   (cond (instance? rd/ParserError parse-result)
                         (do
                           (status (.msg parse-result))
                           (wait-for-output)
                           (abort))

                         ;; after all expressions have been checked,
                         ;; deliver the resulting Module
                         (send ast-checker (partial deliver loading)))
                   loading)))

          ;; or tell everyone it couldn't be
          (do
            (status "Could not find/open " file-name)
            (wait-for-output)
            (abort)))
  )

(main [params]
  (let [core-start (sys/clock_gettime)
        core-mod (extract (compile-module core toccata-dir toccata-dir 0))]
    (status 'time-for-core (div (sys/time-delta core-start (sys/clock_gettime)) 1000))
    ;; (-> (rest params)
    ;;     ;; TODO: empty-defn causes mem leaks
    ;;     ;; (remove (partial = "assertion-tests/empty-defn.toc"))
    ;;     (map (fn [file-name]
    ;;            (map (sys/file-directory file-name)
    ;;                 (fn [root-dir]
    ;;                   (send modules (fn [_]
    ;;                                   {'core core-mod}))
    ;;                   (let [_ (send output (fn [_]
    ;;                                          (fio/file-out (str file-name ".err"))))
    ;;                         core-result (compile-module file-name toccata-dir toccata-dir)
    ;;                         core-result (either (map (instance? Promise core-result) extract)
    ;;                                             core-result)]
    ;;                     (cond (instance? Module core-result)
    ;;                           (status 'Loaded file-name)

    ;;                           (do
    ;;                             (either (map (instance? se/Error core-result)
    ;;                                          (fn [err]
    ;;                                            (status (.val err))))
    ;;                                     (status "Could not load Toccata file:" file-name))))))))))
    )

  (wait-for-output))
