
(add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
                           "free.toc"
                           :sha "5c353f2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "f3a18dc"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "26534ac"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "07b7412"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "4846add"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "ff13fae"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "0885281"))
(add-ns b (module "base.toc"))

(def Tagged (any-of Symbol
                    ast/tagged-symbol))

(def flag (agent nothing))

(def output (agent 0))

(defn status [& msg]
  (send output (fn [_]
                 (apply print-err msg))))

(defn wait-for-output []
  (let [p (promise)]
    (send output (partial deliver p))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(def type-counter (int-generator c/TypeCount))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

;; TODO: use 'either' here
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conflicting-assertions [failing-constraint loc]
  (to-str (list* "Conflicting assertions"
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype ProtoArity [type-num arity]
  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f embed]
    (map (f arity)
         (partial .arity x))))

(deftype ProtoImpls [fn-sym default-impl impls]
  (assert (instance? Symbol fn-sym))
  (assert (instance? c/FnConstraint default-impl))
  (assert (instance? (map-of Integer c/FnConstraint) impls))

  Stringable
  (string-list [_]
    (list "(ProtoImpls " (str fn-sym) "\n" (str default-impl) "\n" (str impls) ")"))

  Container
  (map [x f]
    (ProtoImpls fn-sym
                (map default-impl f)
                (map-vals impls (fn [impl-fns]
                                  (map-vals impl-fns (fn [arities]
                                                       (map arities f)))))))

  (map [x f embed]
    (for [def-impl (map default-impl f embed)
          impl-fns (contextual-map-vals impls
                                        (fn [impl-fns]
                                          (contextual-map-vals impl-fns f embed))
                                        embed)]
      (ProtoImpls fn-sym def-impl impl-fns))))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include ProtoImpls
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(defn get-types []
  (se/get-in-val [.value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.value-types])
            (fn [types-list]
              (se/assoc-in-val [.value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn add-getter [sym types-list]
  (assert (instance? Symbol sym))
  (assert (instance? (list-of HashMap) types-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [required-field (c/ReifiedConstraint c/UnknownType {(c/Field sym) c/top-type}
                                            (symbol (str "field " (rest sym) " required"))
                                            (.arities c/fn-constraint {}) empty-list c/no-symbol "")
        arities {1 (c/fn-arity (symbol "") (c/ListConstraint [required-field]
                                                             c/bottom-type empty-list c/no-symbol "")
                             c/top-type)
                 2 (c/fn-arity (symbol "") (c/ListConstraint [required-field c/top-type]
                                                             c/bottom-type empty-list c/no-symbol "")
                             c/top-type)}
        getter (ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? types-list)
          (list {sym getter})

          (get-in types-list [0 sym])
          types-list

          (map types-list (fn [value-types]
                            (assoc value-types sym getter))))))

(defn get-core-value-type [sym]
  (assert (instance? Symbol sym))
  (se/new-se (fn [s]
               (either (or (and (= 0 (.index s))
                                (or (map (get-in s [.value-types 0 sym])
                                         (fn [val-type]
                                           [val-type s]))
                                    (for [first-char (first (str sym))
                                          _ (= first-char ".")
                                          new-s (update-in s [.value-types]
                                                           (fn [val-types]
                                                             (add-getter sym val-types)))
                                          val-type  (get-in new-s [.value-types 0 sym])]
                                      [val-type new-s])
                                    (maybe se/Failure)))
                           (map (get-in (extract modules) ['core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           ;; last ditch effort
                           (let [core-prom (promise)]
                             ;; (status 'sending sym _LINE_)
                             (send modules (fn [mods]
                                             (either (or (map (get-in mods ['core .value-types 0 sym])
                                                              (fn [val-type]
                                                                (deliver core-prom val-type)
                                                                mods))
                                                         (for [first-char (first (str sym))
                                                               _ (= first-char ".")
                                                               new-mods (update-in mods ['core .value-types]
                                                                                   (fn [val-types]
                                                                                     (add-getter sym val-types)))
                                                               val-type (get-in new-mods ['core .value-types 0 sym])]
                                                           (do
                                                             (deliver core-prom val-type)
                                                             new-mods)))
                                                     (do
                                                       (deliver core-prom nothing)
                                                       mods))))
                             (map (extract core-prom)
                                  (fn [expr]
                                    [expr s]))))
                       se/Failure))))

(defn get-value-type [sym]
  (assert (instance? Tagged sym))

  (let [loc (ast/location sym)
        sym (ast/untag sym)]
    ;; TODO: this does not look up namespaced symbols
    (comp (se/get-in-val [.value-types 0 sym])
          (get-core-value-type sym)
          (compilation-error "Could not find type constraint for '" sym "' at " loc))))

(defn set-value-type [sym constraint]
  (assert (instance? Tagged sym))
  (assert (instance? (any-of c/AllValues c/SymbolConstraints ProtoImpls) constraint))

  (map (se/update-in-val [.value-types]
                         (fn [types-list]
                           (let [sym (ast/untag sym)]
                             (either (map (first types-list)
                                          (fn [value-types]
                                            (cons (assoc value-types sym constraint)
                                                  (rest types-list))))
                                     (list {sym constraint})))))
       (fn [_]
         constraint)))

(defn append-value-type [sym constraint loc]
  (assert (instance? Tagged sym))
  (assert (instance? c/Constraints constraint))

  (let [curr-const (se/try
                     (get-value-type sym)
                     (fn [_]
                       (se/state-error c/top-type)))]

    (cond (= constraint c/top-type)
          curr-const

          (flat-map curr-const
                    (fn [curr-const]
                      (let [new-const (c/trim (c/intersect curr-const constraint))]
                        ;; (let [loc (ast/location sym)]
                        ;;   (or (= (.file loc) 'core)
                        ;;       (= (.line loc) 0)
                        ;;       (do
                        ;;         (print-err 'appending _LINE_ loc sym
                        ;;                    "\n" 'constraint constraint
                        ;;                    "\n\n" 'curr curr-const
                        ;;                    "\n\n" 'new-const new-const)
                        ;;         nothing)))

                        (cond (= new-const c/bottom-type)
                              (compilation-error (conflicting-assertions new-const loc))

                              (set-value-type sym (c/update-path new-const loc)))))))))

(defn remove-value-type [sym]
  (assert (instance? Tagged sym))
  (se/update-in-val [.value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types (ast/untag sym))
                                           (rest types-list))))
                              types-list))))

(defn add-proto-impl [type-num fn-name arg-count arity-c]
  (assert (instance? c/fn-arity arity-c))

  (flat-map (get-value-type fn-name)
            (fn [proto-impls]
              (assert (instance? ProtoImpls proto-impls))

              (comp (se/update-in-val [fn-name .impls type-num]
                                      (fn [fn-c]
                                        (assert (instance? c/FnConstraint fn-c))

                                        (assoc-in fn-c [.arities arg-count] arity-c)))
                    (se/assoc-in-val [fn-name .impls type-num]
                                     (.arities c/fn-constraint {arg-count arity-c}))))))

(defn get-type-info [type-sym]
  (se/get-in-val [.types (ast/untag type-sym)]))

(defprotocol TypeChecker
  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       "\n" (type-name ast) ast
                       "\n\n" constraint))

  (check-call-site [ast args target]
    (assert-result x (instance? se/StateError x)))

  (call-site-checked [ast args target]
    (assert-result x (instance? se/StateError x)))

  (recover-val-type [x]
    (assert-result x (instance? se/StateError x))

    (se/state-error x))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast))

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       "\n" (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(defn all-syms [params]
  (assert (instance? ast/BindingTarget params))

  (cata all-symbols params))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (ana recover-val-type params se/state-error))

(defn type-check-ast [ast]
  (cond (= c/bottom-type ast)
        (compilation-error (conflicting-assertions ast (ast/location ast)))

        (for [new-ast (pre-check ast)
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (extract flag)
              ;;              (maybe (print-err 'type-checking _LINE_ loc
              ;;                                "\n" 'ast ast
              ;;                                "\n\n" 'new-ast new-ast
              ;;                                "\n\n" 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and (extract flag)
            ;;        (maybe (print-err 'final-ast _LINE_ loc
            ;;                          "\n" final-ast))))
            final-ast))))

(defn reify-constraint [c]
  ;; (status 'reify-constraint _LINE_ c)
  (se/state-error c))

(extend-type c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (map (either (map (c/extract-sym old-c)
                      (fn [sym]
                        (append-value-type sym c (ast/location old-c))))
                 se-nop)
         (fn [_]
           c))))

(extend-type c/AllValues
  TypeChecker
  (param-types [c]
    (se/state-error c))

  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error ast)))

(extend-type c/fn-arity
  TypeChecker
  (check-call-site [arity args target]
    ;; (or ;; (= (.line loc) 0)
    ;;     ;; (= (.file loc) 'core)
    ;;  (maybe (status 'checking-fn-constraint _LINE_ target (ast/location target)
    ;;                    "\n" 'arity arity
    ;;                    "\n\n" 'args args)))
    (let [loc (ast/location target)
          arg-count (count args)
          fixed-params (-> (.param-consts arity)
                           c/extract-items-constraints)
          required-args (count fixed-params)]
      (cond (< arg-count required-args)
            (compilation-error "Insufficient number of arguments to function"
                               (either (map (instance? Tagged target)
                                            (fn [_]
                                              (str "'" target "' called at")))
                                       "called at")
                               loc)

            (let [[fixed-args var-args] (-> args
                                            (map (fn [arg]
                                                   (either (get arg .constraint)
                                                           c/top-type)))
                                            (split required-args))
                  var-args (-> c/list-constraint
                               (.items var-args)
                               (.tail-c c/bottom-type))
                  fixed-params (map fixed-params (fn [c]
                                                   (c/reify-type-constraint c (.arity-id arity)
                                                                            (conj fixed-args var-args)
                                                                            loc)))
                  var-params (either (= (.tail-c (.param-consts arity)) c/bottom-type)
                                     (-> (.tail-c (.param-consts arity))
                                         (c/reify-type-constraint (.arity-id arity)
                                                                  (conj fixed-args var-args)
                                                                  loc)))
                  arg-cs (-> c/list-constraint
                             (.items fixed-args)
                             (.tail-c var-args))
                  param-cs (-> c/list-constraint
                               (.items fixed-params)
                               (.tail-c var-params))
                  checked-args (c/intersect arg-cs param-cs)]
              (for [new-arg-cs (cond (= c/bottom-type checked-args)
                                     (do
                                       (status 'site _LINE_ loc "\n" target
                                                  "\n\n" 'args args
                                                  "\n\n" 'arity arity)
                                       (compilation-error (conflicting-assertions checked-args loc)))

                                     (se/state-error (c/extract-items-constraints checked-args arg-count)))
                    _ (se/traverse (zip-lists new-arg-cs args)
                                   (fn [[c arg]]
                                     (update-constraint arg
                                                        ;; TODO: this call to 'reify-type-constraint' seems redundant
                                                        (c/reify-type-constraint c (.arity-id arity)
                                                                                 new-arg-cs loc)
                                                        loc)))]
                (let [[fixed-args variadic-args] (split new-arg-cs required-args)
                      param-cs (conj fixed-args
                                     (-> c/list-constraint
                                         (.items variadic-args)
                                         (.tail-c c/bottom-type)))
                      r (either (map (and (= target 'show-type)
                                          (first new-arg-cs))
                                     (fn [c]
                                       (apply status (map (cata c/show-full (c/update-path c loc))
                                                          (partial str  "\n  ")))
                                       c))
                                (-> (.result-const arity)
                                    (c/update-path loc)
                                    (c/reify-type-constraint (.arity-id arity) param-cs loc)))]
                  ;; (or ;; (= (.line loc) 0)
                  ;;     ;; (= (.file loc) 'core)
                  ;;     (do
                  ;;       (status 'call-fn _LINE_ target (.arity-id arity) loc
                  ;;               "\n" 'args (-> args
                  ;;                              b/remove-asts
                  ;;                              (interpose  "\n")
                  ;;                              vec)
                  ;;               "\n\n" 'result-const (.result-const arity)
                  ;;               "\n\n" 'fn-result r)
                  ;;       nothing))
                  (Left r)))))))

  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error ast)))

(extend-type c/FnConstraint
  TypeChecker
  (check-call-site [ast args target]
    (either (map (or (map (get (.arities ast) (count args))
                          (fn [arity]
                            (.arities ast {(count args) arity})))
                     (map (get (.arities ast) c/variadic)
                          (fn [arity]
                            (.arities ast {c/variadic arity}))))
                 (fn [ast]
                   (se/state-error (Right ast))))
            (compilation-error "Could not find valid arity for function"
                               (either (map (instance? Tagged target)
                                            (fn [_]
                                              (str "to '" target "' called at")))
                                       "called at")
                               (ast/location target)
                               "with" (count args) "arguments.")))

  (call-site-checked [fc args target]
    (let [arg-count (count args)]
      (either (map (or (get (.arities fc) arg-count)
                       (get (.arities fc) c/variadic))
                   se/state-error)
              (do
                ;; TODO: fix up
                (print-err 'blewey 'core _LINE_)
                (abort)
                (compilation-error "Could not call" target))))))

(extend-type ast/tagged-symbol
  TypeChecker
  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (check-call-site [ast args target]
    (se/state-error (Right ast)))

  (call-site-checked [c _ _]
    (se/state-error (.constraint c)))

  (all-symbols [ast]
    [ast])

  (recover-val-type [sym]
    (let [sym (ast/untag sym)]
      (flat-map (se/get-in-val [.value-types])
                (fn [types-list]
                  (assert (instance? List types-list))
                  (either (for [value-types (nth types-list 1)
                                prev-constraint (get value-types sym)]
                            (set-value-type sym prev-constraint))
                          (remove-value-type sym))))))

  (param-types [sym]
    (flat-map (get-value-type sym)
              (fn [c]
                (let [c (either (map (instance? c/DebugConstraint c)
                                     (fn [c]
                                       (status (to-str (show c)))
                                       (.constraint c)))
                                c)]
                  (either (map (instance? c/ParamConstraint c)
                               (fn [c]
                                 (let [param-c (c/full-param-constraint c)]
                                   (cond (= c/bottom-type param-c)
                                         (compilation-error (conflicting-assertions param-c (ast/location sym)))

                                         (se/state-error c)))))
                          (se/state-error c))))))

  (type-check [s old-s]
    (map (get-value-type s)
         (fn [c]
           (.constraint s c)))))

(extend-type ast/params-ast
  TypeChecker
  (all-symbols [params]
    (comp* (either (.variadic params)
                   [])
           (seq (.fixed params))))

  (param-types [params]
    (-> c/seq-constraint
        (c/set-tail (either (.variadic params)
                            c/bottom-type))
        (c/set-items (.fixed params))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> c/list-constraint
                (c/set-items (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (either (for [var-param (.variadic old-ast)
                    :when (instance? Tagged var-param)]
                (let [var-c (-> c/list-constraint
                                (c/update-path (ast/location var-param)))]
                  (map (set-value-type var-param var-c)
                       (fn [_]
                         (-> ast
                             (.constraint (.tail-c c c/coll-of-any))
                             (assoc-in [.variadic .constraint] var-c))))))
              (se/state-error (.constraint ast c))))))

(extend-type ast/inline-ast
  TypeChecker
  (type-check [ast old-ast]
    (map (reify-constraint (.constraint ast))
         (partial .constraint ast))))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (map (cata param-types params se/state-error)
       (fn [c]
         (let [c (c/trim c)]
           (-> c/list-constraint
               (c/set-items (c/extract-items-constraints c))
               (c/set-tail (c/extract-tail-constraint c)))))))

(extend-type c/DebugConstraint
  TypeChecker
  (type-check [c old-c]
    (either (map (c/extract-sym c)
                 (fn [sym]
                   (append-value-type (ast/tag sym) c (ast/location old-c))))
            (se/state-error c))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (gensym "fn-arity")
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (or (= (.line loc) 0)
            ;;             (= (.file loc) 'core)
            ;;             (do
            ;;               (print-err 'pre-fn-arity (.fn-sym ast) loc
            ;;                          "\n" 'params (.params ast)
            ;;                          "\n\n" 'old-param-cs (.param-consts ast)
            ;;                          "\n\n" 'body (.body ast)
            ;;                          "\n\n" 'result-const (.result-const ast))
            ;;               nothing))]
            _ (set-value-type ast/result-sym c/top-type)
            _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                      (set-value-type sym c/top-type)))
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   se-nop

                                   (append-value-type sym
                                                      (c/ParamConstraint arity-id index []
                                                                         empty-list (ast/untag sym) "")
                                                      loc))))
            _ (either (for [variadic-sym (.variadic (.params ast))
                            :when (instance? ast/params-ast variadic-sym)]
                        (append-value-type variadic-sym
                                           (c/ParamConstraint arity-id arg-count []
                                                              empty-list
                                                              (ast/untag variadic-sym) "")
                                           loc))
                      se-nop)]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast)))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (get-value-type ast/result-sym)
            _ (recover-val-type ast/result-sym)
            pts (map (get-param-types (.params old-ast))
                     (fn [c]
                       (c/update-path c loc)))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            ;; :let [_ (or (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;             (and (or (= "vector" (str (.fn-sym ast)))
            ;;                      (= "vec" (str (.fn-sym ast))))
            ;;                  (do
            ;;                    (print-err 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                               "\n" 'orig-pts orig-pts)
            ;;                    nothing)))]
            :let [result-c (-> (either (map (last (.body ast)) .constraint)
                                       c/top-type)
                               (c/intersect result-c))
                  result-c (either (map (instance? c/DebugConstraint result-c)
                                        (fn [c]
                                          (status (to-str (cons "Result type" (drop (show c) 2))))
                                          (.constraint c)))
                                   result-c)]
            _ (either (map (or (= c/bottom-type pts)
                               (= c/bottom-type result-c))
                           (fn [failure-c]
                             (compilation-error (conflicting-assertions failure-c loc))))
                      se-nop)]
        (.constraint ast (c/fn-arity (.fn-var ast) pts result-c))))))

(extend-type ast/fn-ast
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conflicting-assertions new-c loc))))
              (se/state-error (.constraint ast new-c)))))

  (pre-check [ast]
    (let [loc (ast/location ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) 'core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  "\n" ast)
      ;;       nothing))
      (either (map (.fn-sym ast)
                   (fn [sym]
                     (for [_ (push-types)
                           _ (set-value-type sym (-> c/fn-constraint
                                                     (c/update-path loc)
                                                     (c/update-sym (ast/untag sym))))]
                       (.arities ast (map (.arities ast)
                                          (fn [arity]
                                            (.fn-sym arity sym)))))))
              (se/state-error ast))))

  (type-check [ast old-ast]
    (let [fn-c (either (map (.fn-sym ast)
                            (fn [sym]
                              (-> c/fn-constraint
                                  (c/update-path (ast/location sym))
                                  (c/update-sym (ast/untag sym)))))
                       c/fn-constraint)
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (get-in arity-c [.param-consts .tail-c])
                                         :when (= c/bottom-type variadic)
                                         fixed-params (get-in arity-c [.param-consts .items])]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) 'core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) "\n" fn-c)
      ;;         nothing)))
      (se/state-error (.constraint ast fn-c)))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or (= (.line loc) 0)
    ;;       ;; (= (.file loc) 'core)
    ;;       (do
    ;;         (print-err 'checking ast)
    ;;         nothing)))
    (for [_ (push-types)]
      (.value-exprs ast (-> (.value-exprs ast)
                            (remove (partial instance? ast/block-comment-ast))
                            (map (fn [inner-ast]
                                   (cond (instance? ast/fn-ast inner-ast)
                                         (.fn-sym inner-ast (maybe (.sym ast)))

                                         (instance? c/SumConstraint inner-ast)
                                         (b/ConstrainedSum (.alts inner-ast) (.path inner-ast)
                                                           (ast/untag (.sym ast)) (.var inner-ast))

                                         inner-ast)))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))]
      (for [_ (pop-types)
            c (either (map (last (.value-exprs ast))
                           (fn [val]
                             (cond (instance? c/Constraints val)
                                   ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                   ;; the updated version. Possibly a bug in assoc-in*
                                   (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                             (set-value-type (.sym old-ast) val))

                                   (set-value-type (.sym old-ast) (.constraint val)))))
                      (set-value-type (.sym old-ast) c/top-type))]
        (do
          ;; (status 'def _LINE_ loc (.sym old-ast) "\n" c)
          ast)))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (comp (se/get-in-val [.value-types 0 (ast/untag (.fn-name ast)) .default-impl])
                  (set-value-type (.fn-name ast)
                                  (ProtoImpls (ast/untag (.fn-name ast)) (.arities c/fn-constraint {}) {})))
          _ (push-types)
          _ (set-value-type ast/result-sym c/top-type)
          _ (se/traverse (all-syms (.params ast))
                         (fn [sym]
                           (set-value-type sym c/top-type)))]
      ast))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))]
      (for [pts (get-param-types (.params old-ast))
            result-c (se/try
                       (get-value-type ast/result-sym)
                       (fn [_]
                         (se/state-error c/top-type)))
            :let [impl-c (c/fn-arity (ast/untag (.fn-name old-ast)) pts result-c)]
            _ (remove-value-type ast/result-sym)
            _ (recover-types (.params old-ast))
            _ (nip-types)
            _ (se/update-in-val [.value-types]
                                (fn [types-list]
                                  (let [sym (ast/untag (.fn-name ast))]
                                    (either (map (first types-list)
                                                 (fn [value-types]
                                                   (cons (assoc-in value-types
                                                                   [sym .default-impl .arities arg-count]
                                                                   impl-c)
                                                         (rest types-list))))
                                            (list {sym (ProtoImpls sym
                                                                   (.arities c/fn-constraint {arg-count impl-c})
                                                                   {})})))))]
        (.constraint ast impl-c)))))

(extend-type ast/protocol-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/call-ast
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conflicting-assertions new-c loc))))
              (se/state-error (.constraint ast new-c)))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.call-target old-ast))]
      (for [
            ;; _ (se/when (or ;; (= (.line loc) 0)
            ;;                ;; (= (.file loc) 'core)
            ;;             (maybe (print-err 'calling-top _LINE_ loc
            ;;                               "\n" 'target (.call-target ast)
            ;;                               "\n\n" 'target-c (.constraint (.call-target ast))
            ;;                               "\n\n" 'args (str "[" (-> (.args ast)
            ;;                                                         (map .constraint)
            ;;                                                         (interpose  "\n")
            ;;                                                         to-str)
            ;;                                                 "]")))
            ;;                (maybe nothing)))
            result-type (elgot (fn [inner-ast]
                                 ;; (or ;; (= (.line loc) 0)
                                 ;;     ;; (= (.file loc) 'core)
                                 ;;     (do
                                 ;;       (status 'calling _LINE_ loc "\n" (type-name inner-ast) inner-ast
                                 ;;               "\n" 'target (.call-target old-ast)
                                 ;;               "\n\n" 'args (str "[" (-> (.args ast)
                                 ;;                                         (map .constraint)
                                 ;;                                         (interpose  "\n")
                                 ;;                                         to-str)
                                 ;;                                 "]")
                                 ;;               "\n\n" 'old-args (.args old-ast))
                                 ;;       nothing))
                                 (check-call-site inner-ast (.args ast) (.call-target old-ast)))
                               (fn [c]
                                 (call-site-checked c (.args ast) (.call-target old-ast)))
                               (.call-target ast) se/state-error)
            ;; _ (se/when (or ;; (= (.line loc) 0)
            ;;                ;; (= (.file loc) 'core)
            ;;                (maybe (status 'calling-result _LINE_ loc
            ;;                               "\n" 'result-type result-type))
            ;;                (maybe nothing)))
            _ (either (map (and (= c/bottom-type result-type)
                                (first (.constraints result-type)))
                           (fn [_]
                             (compilation-error (conflicting-assertions result-type loc))))
                      se-nop)]
        (-> old-ast 
            (.args (.args ast))
            (.constraint result-type))))))

(extend-type ProtoArity
  TypeChecker
  (type-check [ast old-ast]
    (map (add-proto-impl (.type-num ast)
                         (-> old-ast .arity .fn-sym)
                         (-> old-ast .arity .params .fixed count)
                         (.constraint (.arity ast)))
         (fn [_]
           ast))))

(extend-type ast/reify-ast
  TypeChecker
  (pre-check [ast]
    (let [reified-type-num (either (.type-num ast)
                                   (extract type-counter))]
      (-> ast
          (.type-num (maybe reified-type-num))
          (map (fn [arity]
                 (ProtoArity reified-type-num arity)))
          se/state-error)))

  (type-check [ast old-ast]
    (let [invoke-arities (either (map (get-in ast [.impls (ast/tag 'Fn) (ast/tag 'invoke)])
                                      (fn [arities]
                                        (reduce arities {}
                                                (fn [m arity]
                                                  (assoc m (count (.fixed (.params (.arity arity))))
                                                         (.constraint (.arity arity)))))))
                                 {})]
      (-> ast
          (map .arity)
          (.constraint (c/ReifiedConstraint (extract (.type-num ast)) {}
                                            (symbol (str "reified value at "
                                                         (ast/location ast)))
                                            (.arities c/fn-constraint invoke-arities)
                                            empty-list c/no-symbol ""))
          se/state-error))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (for [type-info (get-type-info (.type ast))
          :let [type-num (c/get-type-num type-info)]]
      (map ast (fn [arity]
                 (ProtoArity type-num arity)))))

  (type-check [ast old-ast]
    (se/state-error (map ast .arity))))

(extend-type ProtoImpls
  TypeChecker
  (check-call-site [ast args target]
    (either (map (first args)
                 (fn [disp-arg]
                   (let [disp-type (c/get-type-num (.constraint disp-arg))
                         fn-c (either (get-in ast [.impls disp-type])
                                 (.default-impl ast))]
                     (either (map (get (.arities fn-c) (count args))
                                  (fn [arity]
                                    (se/state-error (Right (.arities fn-c {(count args) arity})))))
                             (compilation-error "Could not find valid arity for function"
                                                (either (map (instance? Tagged target)
                                                             (fn [_]
                                                               (str "to '" target "' called at")))
                                                        "called at")
                                                (ast/location target)
                                                "with" (count args) "arguments.")))))
            (compilation-error "The call to" (str "'" (.fn-sym ast) "'") "at" (ast/location target)
                               "requires at least one argument."))))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          ;; :let [loc (ast/location ast)
          ;;       _ (or (= (.line loc) 0)
          ;;             (= (.file loc) 'core)
          ;;             (do
          ;;               (print-err 'binding-type-check _LINE_ loc
          ;;                          "\n" 'ast ast)
          ;;               nothing))]
          _ (se/traverse (all-syms (.binding ast)) (fn [sym]
                                                     (set-value-type sym c/top-type)))]
      ast))

  (type-check [ast old-ast]
    (for [_ (push-types)
          ;; :let [loc (ast/location ast)
          ;;       _ (or (= (.line loc) 0)
          ;;             (= (.file loc) 'core)
          ;;             (do
          ;;               (print-err 'binding-type-check loc
          ;;                          "\n\n" 'ast ast)
          ;;               nothing))]
          new-binding (update-constraint (.binding ast) (.constraint (.val ast)) (ast/location old-ast))]
      (.binding ast new-binding))))

(extend-type ast/let-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or ;; (= (.line loc) 0)
    ;;       ;; (= (.file loc) 'core)
    ;;       (do
    ;;         (status 'let _LINE_ loc
    ;;                    "\n" ast)
    ;;         nothing)))
    (-> ast
        (.body (remove (.body ast)
                       (partial instance? ast/block-comment-ast)))
        se/state-error))

  ;; (type-check [ast old-ast]
  ;;   (for [_ (se/traverse (reverse (.bindings ast))
  ;;                        (fn [binding-ast]
  ;;                          (let [binding (.binding binding-ast)
  ;;                                val (.val binding-ast)]
  ;;                            (for [val-c (either (or (map (instance? Tagged binding)
  ;;                                                         (partial get-type-constraint))
  ;;                                                    (map (instance? ast/params-ast binding)
  ;;                                                         (fn [_]
  ;;                                                           (map (get-param-types binding)
  ;;                                                                (fn [binding-c]
  ;;                                                                  (assert (instance? c/ListConstraint binding-c))
  ;;                                                                  (-> c/seq-constraint
  ;;                                                                      (c/set-items (.items binding-c))
  ;;                                                                      (c/set-tail (.tail-c binding-c))))))))
  ;;                                                (se/state-error c/top-type))
  ;;                                  _ (se/traverse (all-syms binding)
  ;;                                                 recover-type-constraint)
  ;;                                  _ (update-constraint val (b/remove-asts val-c) (ast/location binding))
  ;;                                  ;; :let [loc (ast/location old-ast)
  ;;                                  ;;       _ (or (= (.line loc) 0)
  ;;                                  ;;             (= (.file loc) 'core)
  ;;                                  ;;             (do
  ;;                                  ;;               (print-err 'let loc
  ;;                                  ;;                          "\n" 'binding (type-name binding) binding
  ;;                                  ;;                          "\n\n" 'val val
  ;;                                  ;;                          "\n\n" 'val-c val-c)
  ;;                                  ;;               nothing))]
  ;;                                  _ (nip-types)]
  ;;                              '_))))]
  ;;     (let [result-c (either (map (last (.body ast)) .constraint)
  ;;                            c/top-type)]
  ;;       (b/ConstrainedAST ast (c/clear-sym result-c)))))
  )

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (grmr/any
     (fr/pure (reify
                Type
                (type-name [_]
                  (str "Reified at: " _FILE_ ": " _LINE_))

                rd/RecursiveDescent
                (rd/recursive-descent [p]
                  (se/state-error
                   (se/new-se (fn [s]
                                (either (for [result-prom (get-in s [.values 'result-prom])
                                              :when (delivered result-prom)]
                                          (extract result-prom))
                                        se/Failure)))))))
     (apply-to (fn [type-checker result-prom ast]
                 ;; (status 'ast _LINE_ ast)
                 (send type-checker update-context
                       (se/try
                         (comp (type-check-ast ast)
                               (compilation-error "Could not type check code for expression at "
                                                  (ast/location ast)))
                         (fn [err]
                           (deliver result-prom err)
                           (se/throw (.val err)))))
                 ast)
               (grmr/get-value 'type-checker)
               (grmr/get-value 'result-prom)
               rdr/top-level)))))

(defn compile-module [file-name root-dir proj-dir]
  (let [mod-prom (promise)]
    (send modules
          (fn [mods]
            (either (map (get mods file-name) (partial deliver mod-prom))
                    (let [module-index (count mods)
                          loading (promise)
                          ;; attach an action to 'loading' to be executed when a value is delivered to it
                          _ (map loading (fn [result]
                                           (send modules (fn [mods]
                                                           (assoc mods file-name result)))
                                           result))
                          ;; init an agent with an empty module context
                          ast-checker (agent (Module file-name module-index {} {}
                                                     c/core-type-constraints empty-list))
                          ;; kick off a thread to load and check the module
                          _ (future (fn []
                                      (status "Loading" file-name)

                                      (either (map (fio/file-in (cond (= file-name 'core)
                                                                      path-to-core
                                                                      file-name))
                                                   (fn [file-in]
                                                     ;; if so, parse and type check it
                                                     (let [parse-result (parse-forms {'file-name file-name
                                                                                      'root-directory root-dir
                                                                                      'project-directory proj-dir
                                                                                      'line-number 1
                                                                                      'type-checker ast-checker
                                                                                      'result-prom loading}
                                                                                     (lazy-list file-in))]
                                                       (cond (instance? se/Error parse-result)
                                                             (deliver loading parse-result)

                                                             ;; after all expressions have been checked,
                                                             ;; deliver the resulting Module
                                                             (send ast-checker (partial deliver loading))))))

                                              ;; or tell everyone it couldn't be
                                              (deliver loading (se/Error (str "Could not find/open " file-name)
                                                                         '_)))))]
                      (deliver mod-prom loading)
                      (assoc mods file-name loading)))))
    (extract mod-prom)))

(main [params]
  (let [core-result (compile-module 'core toccata-dir toccata-dir)
        core-result (either (map (instance? Promise core-result) extract)
                            core-result)]
    (cond (instance? Module core-result)
          core-result

          (do
            (either (map (instance? se/Error core-result)
                         (fn [err]
                           (status (.val err))))
                    (status "Could not load Toccata core."))
            (wait-for-output)
            (abort))))

  (wait-for-output))
