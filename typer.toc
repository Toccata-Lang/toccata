
(add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
                           "free.toc"
                           :sha "5c353f2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "3928103"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "ad576e3"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f854f65"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "4846add"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "22982cd"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "5f48eeb"))

(def output (agent 0))

(defn status [& msg]
  (send output (fn [_]
                 (apply print-err msg))))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(deftype Closures [closures refs-map]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map)))

(def empty-closures (Closures [] {}))

(deftype FunctionArityContext [sym-count syms context-syms closed-over field-constrs]
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; constraints for fields in type-ast implementations
  (assert (instance? (maybe-of c/ListConstraint) field-constrs))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while checking a module
(deftype ModuleContext [fn-context module]
  ;; fn-context             context for the fn currently being checked
  (assert (instance? FunctionArityContext fn-context))
  ;; module                info for each module compiled
  (assert (instance? Module module))

  Stringable
  (string-list [_] (list "<ModuleContext "
                         (str module) ">")))

(def module-context (ModuleContext (FunctionArityContext 0 {} {} empty-closures nothing)
                                   (Module 'core 0 {} {} {} {})))

;; Agent holds map of module file name to Module value
(def modules (agent {}))

;; Agent holds map of module file name to promise that will be delivered when module is loaded
(def loaders (agent {}))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

;; TODO: use 'either' here
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(defprotocol TypeChecker
  (check-module [ast root-dir proj-dir]
    (assert-result r (instance? Promise r)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    ;; (se/state-error ast)
    )

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    ;; (se/state-error ast)
    ))

(defn type-check-ast [ast]
  (for [new-ast (pre-check ast)
        newer-ast (map new-ast type-check-ast se/state-error)
        final-ast (type-check newer-ast new-ast)]
    final-ast))

(defn analyze-forms [ast-checker result-prom]
  (rd/parser
   (grmr/none-or-more
    (grmr/any
     (fr/pure (reify
                Type
                (type-name [_]
                  (str "Reified at: " _FILE_ ": " _LINE_))

                rd/RecursiveDescent
                (rd/recursive-descent [p]
                  (se/state-error
                   (se/new-se (fn [_]
                                (cond (delivered result-prom)
                                      (extract result-prom)
                                      se/Failure)))))))
     ;; (parse-module-import ast-checker)
     (apply-to (fn [ast]
                 (status 'ast ast)
                 (send ast-checker update-context
                       (se/try
                         (comp (type-check-ast ast)
                               (compilation-error "Could not type check code for expression at "
                                                  (ast/file-name ast) (ast/line-number ast)))
                         (fn [err]
                           (deliver result-prom err)
                           (se/throw (.val err))))))
               rdr/top-level)))))

(defn load-module [loader-futs file-name waiter-prom root-dir proj-dir]
  (assert (instance? (map-of c/SymbolOrString Future) loader-futs))

  ;; either the module is in process ...
  (either (map (get loader-futs file-name)
               (fn [mod-prom]
                 ;; in which case, tell it to notify waiting process when completely loaded
                 (assoc loader-futs file-name (map mod-prom (partial deliver waiter-prom)))))

          ;; or module isn't loaded yet
          (let [module-index (count loader-futs)
                ;; init an agent with an empty module context
                ast-checker (-> module-context
                                (.module (Module file-name module-index {} {} {} {}))
                                agent)
                ;; kick off a thread to load and check the module
                loader (future (fn []
                                 (status "Loading " file-name)
                                 (assert-result r (instance? se/StateError r))

                                 (let [result-prom (promise)]
                                   ;; either the module source file can be opened
                                   (either (map (fio/file-in (cond (= file-name 'core)
                                                                   path-to-core
                                                                   file-name))
                                                (fn [file-in]
                                                  ;; if so, parse and type check it
                                                  (let [analyzer (analyze-forms ast-checker result-prom)
                                                        analyzed (analyzer {'file-name file-name
                                                                            'root-directory root-dir
                                                                            'project-directory proj-dir
                                                                            'line-number 1}
                                                                           (lazy-list file-in))]
                                                    (send ast-checker (fn [_]
                                                                        (status 'done-checking)
                                                                        (deliver result-prom 'checked)))
                                                    (either (map (instance? se/Error analyzed)
                                                                 (fn [err]
                                                                   (se/throw (.val err))))
                                                            (se/state-error (extract result-prom))))))
                                           ;; or tell everyone it couldn't be
                                           (se/throw (str "Could not find/open " file-name))))))]
            ;; pass the loader to the waiter
            (deliver waiter-prom loader)

            ;; return updated loader map
            (assoc loader-futs file-name loader))))

(defn compile-module [file-name root-dir proj-dir]
  (assert-result r (instance? Future r))

  (let [waiter-prom (promise)]
    (send loaders load-module file-name waiter-prom root-dir proj-dir)
    (extract waiter-prom)))

(main [params]
  (map (compile-module 'core toccata-dir toccata-dir)
       (fn [loaded]
         ((se/try
            (comp (map loaded (fn [core-module]
                                (status 'cm core-module)
                                (status "loaded core"))) 
                  (se/throw "Could not load Toccata core"))
            (fn [err]
              (status (.val err))
              (se/throw (.val err))))
          'dummy-state)))

  ;; (map params (fn [file-name]
  ;;               (let [waiter (promise)]
  ;;                 (map (sys/file-directory file-name)
  ;;                      (fn [root-dir]
  ;;                        (send modules compile-module file-name waiter root-dir root-dir)))
  ;;                 (extract waiter))))
  )
