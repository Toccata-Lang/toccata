
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "93536de"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f613e93"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "5b5acfb"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
;; (add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
;;                            "free.toc"
;;                            :sha "5c353f2"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(def output (agent nothing))

(defn status [& msg]
  (send output (fn [out-file?]
                 (assert (instance? Maybe out-file?))

                 (apply print-err msg)
                 (map out-file?
                      (fn [out-file]
                        (fio/write out-file (str (to-str (interpose msg " ")) "\n"))
                        out-file)))))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(def core (c/ToccataCore path-to-core))

(def lflf "\n\n")

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(def Function-sym (ast/tag 'Function))
(def invoke-sym (ast/tag 'invoke))

(deftype ProtoArity [type-num arity]
  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (partial .arity x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location arity)))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(defn new-module [file-name module-index]
  (Module file-name module-index {} {}
          c/core-type-constraints
          (list {'empty-list (c/update-sym c/empty-list-constraint
                                           'empty-list)
                 'empty-vector (c/update-sym c/empty-vect-constraint
                                             'empty-vector)
                 'int-max (assoc-in c/int-constraint
                                    [.fields 'static-value] int-max)
                 'int-min (assoc-in c/int-constraint
                                    [.fields 'static-value] int-min)
                 'nothing (assoc-in c/maybe-constraint
                                    [.fields 'contents]
                                    c/no-contents)})))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(def type-counter (int-generator c/TypeCount))

(defn get-types []
  (se/get-in-val [.value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.value-types])
            (fn [types-list]
              (se/assoc-in-val [.value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn add-getter [sym types-list]
  (assert (instance? Symbol sym))
  (assert (instance? (list-of HashMap) types-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [required-field (.sym c/empty-reified (symbol (str "field '" (rest (str sym)) "' required")))
        arities {1 (c/fn-arity (symbol (str sym "_getter"))
                               (c/ListConstraint [required-field]
                                                 c/no-tail empty-list c/no-symbol "")
                             c/top-type)
                 2 (c/fn-arity (symbol (str sym "_setter"))
                               (c/ListConstraint [required-field c/top-type]
                                                 c/no-tail empty-list c/no-symbol "")
                             c/top-type)}
        getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? types-list)
          (list {sym getter})

          (get-in types-list [0 sym])
          types-list

          (map types-list (fn [value-types]
                            (assoc value-types sym getter))))))

(defn get-core-value-type [sym]
  (assert (instance? Symbol sym))

  (se/new-se (fn [s]
               (either (or (and (= 0 (.index s))
                                (or (map (get-in s [.value-types 0 sym])
                                         (fn [val-type]
                                           [val-type s]))
                                    (for [first-char (first (str sym))
                                          _ (= first-char ".")
                                          new-s (update-in s [.value-types]
                                                           (fn [val-types]
                                                             (add-getter sym val-types)))
                                          val-type  (get-in new-s [.value-types 0 sym])]
                                      [val-type new-s])
                                    (maybe se/Failure)))
                           (map (get-in (extract modules) [core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           ;; last ditch effort
                           (let [core-prom (promise)]
                             ;; (status 'sending sym _LINE_)
                             (send modules (fn [mods]
                                             (assert-result r (instance? HashMap r))
                                             (either (or (map (get-in mods [core .value-types 0 sym])
                                                              (fn [val-type]
                                                                (deliver core-prom (maybe val-type))
                                                                mods))
                                                         (for [first-char (first (str sym))
                                                               _ (= first-char ".")
                                                               new-mods (update-in mods [core .value-types]
                                                                                   (fn [val-types]
                                                                                     (add-getter sym val-types)))
                                                               val-type (get-in new-mods [core .value-types 0 sym])]
                                                           (do
                                                             (deliver core-prom (maybe val-type))
                                                             new-mods)))
                                                     (do
                                                       (deliver core-prom nothing)
                                                       mods))))
                             (map (extract core-prom)
                                  (fn [expr]
                                    [expr s]))))
                       se/Failure))))

(defn get-value-type [sym]
  (assert (instance? ast/tagged-symbol sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (let [loc (ast/location sym)
              sym (ast/untag sym)]
          ;; TODO: this does not look up namespaced symbols
          (comp (se/get-in-val [.value-types 0 sym])
                (get-core-value-type sym)
                (compilation-error "Could not find type constraint for" (str "'" sym "'") "at" loc)))))

(defn set-value-type [sym constraint]
  (assert (instance? ast/OptionalTagged sym))
  (assert (instance? c/Constraints constraint))

  (cond (= c/no-symbol sym)
        (se/state-error constraint)

        (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ constraint)
          se-nop)

        (map (se/update-in-val [.value-types]
                               (fn [types-list]
                                 (let [sym (ast/untag sym)]
                                   (either (map (first types-list)
                                                (fn [value-types]
                                                  (-> value-types
                                                      (dissoc sym)
                                                      (assoc sym constraint)
                                                      (cons (rest types-list)))))
                                           (list {sym constraint})))))
             (fn [_]
               constraint))))

(defn append-value-type [sym constraint loc]
  (assert (instance? ast/OptionalTagged sym))
  (assert (instance? c/Constraints constraint))

  (cond (= sym c/no-symbol)
        (se/state-error constraint)

        (= (str sym) "")
        (map se-nop (fn [_]
                      (status "Bad call to append-value-type" _LINE_ loc sym "\n" constraint)
                      '_))

        (= constraint c/top-type)
        (se/try
          (get-value-type sym)
          (fn [_]
            (se/state-error c/top-type)))

        (flat-map (se/try
                    (get-value-type sym)
                    (fn [_]
                      (se/state-error c/top-type)))
                  (fn [curr-const]
                    (cond (= curr-const c/top-type)
                          (set-value-type sym (c/trim (c/update-path constraint loc)))

                          (let [new-const (c/trim (c/intersect curr-const constraint))]
                            ;; (let [loc (ast/location sym)]
                            ;;   (or ;; (= (.file loc) core)
                            ;;    ;; (= (.line loc) 0)
                            ;;    (and (= sym 'loufa)
                            ;;         (do
                            ;;           (print-err 'appending _LINE_ loc (str "\"" sym "\"")
                            ;;                      "\n" 'constraint constraint
                            ;;                      lflf 'curr curr-const
                            ;;                      lflf 'untrimmed (c/intersect curr-const constraint)
                            ;;                      lflf 'new-const new-const)
                            ;;           nothing))))

                            (cond (= new-const c/bottom-type)
                                  (compilation-error 'site _LINE_ loc 'appending sym
                                                     "\n" 'curr curr-const
                                                     lflf 'constraint constraint
                                                     lflf 'new-const new-const

                                                     lflf (conf-ass _LINE_ new-const loc))

                                  (instance? c/ProtoImpls curr-const)
                                  se-nop

                                  (set-value-type sym (c/update-path new-const loc)))))))))

(defn remove-value-type [sym]
  (assert (instance? ast/tagged-symbol sym))
  (se/update-in-val [.value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types (ast/untag sym))
                                           (rest types-list))))
                              types-list))))

(defn add-impl [proto-impls type-num arg-count arity-c loc]
  (instance? c/ProtoImpls proto-impls)

  (either (map (get-in proto-impls [.default-impl .arities arg-count])
               (fn [default-arity]
                 (let [new-params (-> (.param-consts default-arity)
                                      .items
                                      count
                                      range
                                      vec
                                      (map (fn [n]
                                             (c/ParamConstraint (.arity-id arity-c) n
                                                                empty-list c/no-symbol ""))))
                       ;; _ (cond (and (= c/StringBufferType type-num)
                       ;;              (= (.fn-sym proto-impls) 'drop-while))
                       ;;         (status 'default-arity _LINE_ loc
                       ;;                 "\n\n" 'def default-arity
                       ;;                 "\n\n" 'new-params new-params)

                       ;;         '_)
                       default-arity (cond (= (str (.arity-id default-arity)) "")
                                           default-arity

                                           (let [def-ar (c/reify-type-constraint default-arity
                                                                                 (.arity-id default-arity)
                                                                                 new-params loc)]
                                             (cond (= c/bottom-type def-ar)
                                                   (do
                                                     (print-err 'site _LINE_ loc type-num arg-count
                                                                "\n\n" 'default-arity default-arity
                                                                "\n\n" 'params new-params
                                                                "\n\n" (conf-ass _LINE_ def-ar loc))
                                                     (abort))
                                                   def-ar)))
                       new-arity-c (c/trim (c/intersect arity-c default-arity))]
                   ;; (cond (and (= c/StringBufferType type-num)
                   ;;            (= (.fn-sym proto-impls) 'drop-while))
                   ;;       (status 'proto-result _LINE_ loc
                   ;;               "\n\n" 'def default-arity
                   ;;               "\n\n" 'arity arity-c
                   ;;               "\n\n" 'new new-arity-c)

                   ;;       '_)
                   (cond (= new-arity-c c/bottom-type)
                         (compilation-error 'impl _LINE_
                                            "\n" 'def default-arity
                                            "\n\n" 'arity arity-c
                                            "\n\n" 'new new-arity-c
                                            "\n\n" (conf-ass _LINE_ new-arity-c loc))

                         ;; happy path
                         (either (update-in proto-impls [.impl-fns type-num]
                                            (fn [fn-c]
                                              (assert (instance? c/FnConstraint fn-c))

                                              (assoc-in fn-c [.arities arg-count] new-arity-c)))
                                 (assoc-in proto-impls [.impl-fns type-num]
                                           (.arities c/fn-constraint {arg-count new-arity-c})))))))
          (compilation-error "No prototype for" (str "'" (.fn-sym proto-impls) "'") "with" (str arg-count)
                             "arguments at" loc)))

(defn add-proto-impl [type-num fn-sym arg-count arity-c]
  (assert (instance? Integer type-num))
  (assert (instance? c/fn-arity arity-c))

  (let [loc (ast/location fn-sym)]
    (cond (> 1 type-num)
          (compilation-error "Invalide prototype implementation type-num for" (str "'" fn-sym "'") "at"
                             (ast/location fn-sym))

          (= (str fn-sym) "")
          (do
            (print-err 'compiler-error _LINE_ (str "'" fn-sym "'") (ast/location fn-sym)
                       "\n\n" arity-c)
            (abort))

          ;; TODO: test for namespaced fn-sym
          (comp (flat-map (se/get-in-val [.value-types 0 (ast/untag fn-sym)])
                          (fn [proto-impls]
                            (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                                  (compilation-error "An implementation for" (str "'" fn-sym "'") "already exists\n"
                                                     "Redefinition attempted at" (ast/location fn-sym))
                                  (let [new-proto (add-impl proto-impls type-num arg-count arity-c loc)]
                                    (cond (instance? c/ProtoImpls new-proto)
                                          (for [vts (se/get-val .value-types)
                                                _ (se/set-val .value-types
                                                              (map vts (fn [m]
                                                                         (assoc m (ast/untag fn-sym) new-proto))))]
                                            new-proto)

                                          ;; add-impl might return a compilation error
                                          ;; TODO: this obviously never gets called. It should be se/state-error
                                          new-proto)))))

                (flat-map se-nop
                          (fn [x]
                            (let [core-prom (promise)]
                              (send modules (fn [mods]
                                              (assert (instance? HashMap mods))
                                              (assert-result r (instance? HashMap r))

                                              (let [sym (ast/untag fn-sym)]
                                                (either (for [val-types-list (get-in mods [core .value-types])
                                                              val-types (first val-types-list)
                                                              proto-impls (get val-types sym)]
                                                          (let [new-proto (add-impl proto-impls type-num
                                                                                    arg-count arity-c loc)
                                                                val-types-list (map val-types-list
                                                                                    (fn [m]
                                                                                      (assoc m sym new-proto)))]
                                                            (cond (instance? c/ProtoImpls new-proto)
                                                                  (do
                                                                    (deliver core-prom se-nop)
                                                                    (assoc-in mods [core .value-types]
                                                                              val-types-list))

                                                                  (do
                                                                    (deliver core-prom new-proto)
                                                                    mods))))
                                                        (do
                                                          (deliver core-prom 
                                                                   (compilation-error "Could not find protocol for"
                                                                                      (str "'" fn-sym "'")
                                                                                      "at" (ast/location fn-sym)))
                                                          mods)))))
                              (extract core-prom))))))))

(defn get-type-info [type-sym loc]
  ;; TODO: needs to handled namespaced type-sym
  ;; (or ;; (= (.file loc) core)
  ;;     ;; (= (.line loc) 0)
  ;;  (and ( = type-sym 'BitmapIndexedNode)
  ;;       (do
  ;;         (status 'get-type _LINE_ loc type-sym)
  ;;         (maybe '_))))
  (comp (se/get-in-val [.types (ast/untag type-sym)])
        (flat-map se-nop
                  (fn [_]
                    ;; Look in the core module
                    (let [core-prom (promise)]
                      (send modules (fn [mods]
                                      ;; (or ;; (= (.file loc) core)
                                      ;;  ;; (= (.line loc) 0)
                                      ;;  (and ( = type-sym 'BitmapIndexedNode)
                                      ;;       (do
                                      ;;         (status 'get-type _LINE_ loc type-sym "\n"
                                      ;;                 (get-in mods [core .types (ast/untag type-sym)]))
                                      ;;         (maybe '_))))
                                      (either (or (for [core-mod (get mods core)
                                                        _ (instance? Promise core-mod)]
                                                    (deliver core-prom se/zero-se))
                                                  (map (get-in mods [core .types (ast/untag type-sym)])
                                                       (fn [type-inf]
                                                         (deliver core-prom (se/state-error type-inf)))))
                                              (deliver core-prom se/zero-se))
                                      mods))
                      (extract core-prom))))
        (compilation-error "No type named" (str "'" type-sym "'")
                           "was found. Used at" loc)))

(defprotocol TypeChecker
  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       "\n" (type-name ast) ast
                       lflf constraint))

  (recover-val-type [x]
    (assert-result x (instance? se/StateError x))

    (se/state-error (RecurseFinal x)))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    ;; TODO: put back in when done
    ;; (se/state-error ast)
    )

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       "\n" (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(def ConstrainedAST (any-of ast/call-ast
                            ;; ast/params-ast
                            ast/fn-ast
                            ;; ast/fn-arity-ast
                            ;; ast/let-ast
                            ;; ast/or-ast
                            ;; ast/and-ast
                            ;; ast/either-ast
                            ast/string-ast
                            ast/integer-ast
                            ;; ast/cond-ast
                            ;; ast/quoted-ast
                            ;; ast/tagged-symbol
                            ;; ast/prototype-ast
                            ;; ast/reify-ast
                            ast/block-comment-ast))

(extend-type ConstrainedAST
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error 'site _LINE_ loc
                                        "\n" 'ast ast
                                        "\n\n" 'ast-constraint (.constraint ast)
                                        "\n\n" 'constraint constraint
                                        "\n\n" 'new-c new-c
                                        "\n\n" (conf-ass _LINE_ new-c loc))))
              (se/state-error (.constraint ast (c/update-path new-c loc)))))))

(defn all-syms [params]
  (assert (instance? ast/ParamType params))

  (cata all-symbols params))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (apo recover-val-type params se/state-error))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (map (cata param-types params se/state-error)
       (fn [c]
         (c/trim (c/intersect c c/list-constraint)))))

;; TODO: remove when done
(def DefaultPreCheck (any-of Vector
                             c/AllValues
                             c/NoSymbol
                             c/ReifiedConstraint
                             c/SumConstraint
                             c/VectorConstraint
                             c/ListConstraint
                             c/CollectionOf
                             c/TypeOfConstraint
                             c/FnConstraint
                             c/TypeOp
                             c/MultiConstraint
                             c/fn-arity
                             c/NoTail
                             c/ParamConstraint
                             ast/string-ast
                             ast/integer-ast
                             ast/call-ast
                             ast/inline-ast
                             ast/tagged-symbol
                             ast/protocol-ast
                             ast/params-ast))

;; TODO: remove when done
(def DefaultTypeCheck (any-of Vector
                              c/AllValues
                              c/NoSymbol
                              c/NoTail
                              c/fn-arity
                              c/MultiConstraint
                              ast/protocol-ast
                              ast/inline-ast))

;; TODO: remove when done
(extend-type DefaultPreCheck
  TypeChecker
  (pre-check [ast]
    (se/state-error ast)))

;; TODO: remove when done
(extend-type DefaultTypeCheck
  TypeChecker
  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast)))

(def DefaultConst (any-of c/AllValues
                          c/NoSymbol))

(extend-type DefaultConst ;; c/Constraints
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(def DefaultSymConst (any-of c/ReifiedConstraint
                             c/CollectionOf
                             c/ListConstraint
                             c/VectorConstraint
                             c/SumConstraint
                             c/TypeOp
                             c/FnConstraint))

(extend-type DefaultSymConst ;; c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (flat-map (cond (= (.sym c) c/no-symbol)
                      (se/state-error '_)
                      (get-value-type (ast/tag (.sym c) loc)))
                (fn [_]
                  (append-value-type (ast/tag (.sym c) loc) c loc))))))

(extend-type c/ReifiedConstraint
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (flat-map (cond (= c/UnknownType (c/type-num c))
                      (get-type-info (c/type-sym c) loc)
                      (se/state-error c))
                (fn [type-c]
                  (append-value-type (ast/tag (.sym c) loc)
                                     type-c loc))))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    ;; TODO: restrict use to fn params only
    (flat-map (get-value-type (.param-sym old-c))
              (fn [type-c]
                (let [loc (ast/location c)]
                  (append-value-type (ast/tag (.sym c) loc) type-c loc))))))

(extend-type ProtoArity
  TypeChecker
  (pre-check [pa]
    (for [_ (push-types)]
      (do
        (cond (= (.fn-sym (.arity pa)) 'apply)
              (status 'checking-pa _LINE_ (.type-num pa) (ast/location pa) (.fn-sym (.arity pa)))
              '_)
        pa)))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          :let [_ (cond (= (.fn-sym (.arity ast)) 'apply)
                        (print-err 'adding-impl _LINE_ (.type-num ast) (ast/location ast) (.fn-sym (.arity ast))
                                   ast)
                        '_)
                t1 (sys/clock_gettime)]
          _ (add-proto-impl (.type-num ast)
                            (-> old-ast .arity .fn-sym)
                            (-> old-ast .arity .params .fixed count)
                            (-> ast .arity .constraint))]
      (do
        (cond (= (.fn-sym (.arity ast)) 'apply)
              (status 'checked-pa _LINE_ (.type-num ast) (ast/location ast) (.fn-sym (.arity ast))
                      "\n" ast
                      "\n\n" 'time (sys/time-delta t1 (sys/clock_gettime)))
              '_)
        (c/trim ast)))))

(extend-type ast/reify-ast
  TypeChecker
  (pre-check [ast]
    (let [reified-type-num (either (instance? Integer (.type-num ast))
                                   (extract type-counter))]
      (-> ast
          (.type-num reified-type-num)
          (.impls (map-vals (.impls ast)
                            (fn [impl-fns]
                              (map-vals impl-fns
                                        (fn [arities]
                                          (map arities
                                               (partial ProtoArity reified-type-num)))))))
          se/state-error)))

  (type-check [ast old-ast]
    (let [invoke-arities (either (map (get-in ast [.impls Function-sym invoke-sym])
                                      (fn [arities]
                                        (reduce arities {}
                                                (fn [m arity]
                                                  (assoc m (count (.fixed (.params (.arity arity))))
                                                         (.constraint (.arity arity)))))))
                                 {})]
      (-> ast
          (.impls (map-vals (.impls ast)
                            (fn [impl-fns]
                              (map-vals impl-fns
                                        (fn [arities]
                                          (map arities .arity))))))
          (.constraint (c/ReifiedConstraint (.type-num ast) (symbol (str "reified value at "
                                                                         (ast/location ast)))
                                            {} {}
                                            (.arities c/fn-constraint invoke-arities)
                                            empty-list c/no-symbol ""))
          se/state-error))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          fixed-params (-> ast .params .fixed)
          arg-count (count fixed-params)
          all-param-syms (remove (all-syms (.params ast))
                                 (partial = (ast/tag '_)))]
      (cond (< (count (set all-param-syms)) (count all-param-syms))
            (compilation-error "Duplicate parameter names in prototype at" loc)

            (for [_ (comp (se/get-in-val [.value-types 0 (ast/untag (.fn-name ast)) .default-impl])
                          (set-value-type (.fn-name ast)
                                          (c/ProtoImpls (ast/untag (.fn-name ast))
                                                      (.arities c/fn-constraint {}) {})))
                  _ (push-types)
                  _ (set-value-type ast/result-sym c/top-type)
                  ;; :let [_ (or ;; (= (.line loc) 0)
                  ;;             ;; (= (.file loc) core)
                  ;;          (and (= (.fn-name ast) 'vec)
                  ;;               (do
                  ;;                 (print-err 'pre-prototype _LINE_ (.fn-name ast) (ast/location ast)
                  ;;                            "\n" 'body (.default-body ast))
                  ;;                 nothing)))]
                  _ (se/traverse all-param-syms
                                 (fn [sym]
                                   (set-value-type sym c/top-type)))
                  _ (se/traverse (zip-lists fixed-params (range arg-count))
                                 (fn [[sym index]]
                                   (cond (instance? ast/params-ast sym)
                                         ;; TODO: this probably needs expanding
                                         se-nop

                                         (= sym '_)
                                         (set-value-type sym c/top-type) 

                                         (append-value-type sym
                                                            (c/ParamConstraint (.fn-name ast) index
                                                                               empty-list (ast/untag sym) "")
                                                            loc))))]
              ast))))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))]
      (for [pts (get-param-types (.params old-ast))
            result-c (se/try
                       (get-value-type ast/result-sym)
                       (fn [_]
                         (se/state-error c/top-type)))
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) core)
            ;;          (and (= (.fn-name ast) 'reduce)
            ;;               (do
            ;;                 (status 'check-prototype _LINE_ (.fn-name ast) (ast/location ast)
            ;;                         "\n" ast
            ;;                         "\n\n" 'pts pts
            ;;                         "\n\n" 'result result-c)
            ;;                 nothing)))]
            :let [pts (.tail-c pts c/no-tail)
                  impl-c (c/fn-arity (ast/untag (.fn-name old-ast)) pts result-c)]
            _ (remove-value-type ast/result-sym)
            _ (recover-types (.params old-ast))
            _ (nip-types)
            _ (se/update-in-val [.value-types]
                                (fn [types-list]
                                  (let [sym (ast/untag (.fn-name ast))]
                                    (either (map (first types-list)
                                                 (fn [value-types]
                                                   (cons (assoc-in value-types
                                                                   [sym .default-impl .arities arg-count]
                                                                   impl-c)
                                                         (rest types-list))))
                                            (list {sym (c/ProtoImpls sym
                                                                   (.arities c/fn-constraint {arg-count impl-c})
                                                                   {})})))))]
        (.constraint ast impl-c)))))

(extend-type ast/call-ast
  TypeChecker
  (type-check [ast old-ast]
    (either (and (= (.call-target old-ast) 'show-type)
                 (map (first (.args ast))
                      (fn [arg]
                        (status 'showing (ast/location (.call-target old-ast)) arg
                                "\n" (.constraint arg))
                        (se/state-error arg))))

          (let [loc (ast/location (.call-target old-ast))
                target-c (.constraint (.call-target ast))
                arg-count (count (.args ast))]
            ;; (for [_ (and (instance? c/ProtoImpls target-c)
            ;;              (< 1968 (.line loc)))
            ;;       disp-arg (map (first (.args ast)) .constraint)
            ;;       :let [val-num (c/type-num disp-arg)]
            ;;       :when-not (or (instance? c/ParamConstraint disp-arg)
            ;;                     (= c/UnknownType val-num)
            ;;                     (get-in target-c [.impl-fns val-num .arities arg-count]))]
            ;;   (status 'call-proto _LINE_ loc
            ;;           "\n" ast
            ;;           "\n\n" 'disp val-num disp-arg))
            (let [print-info? (and ;; (= (.call-target old-ast) 'flat-map)
                                   ;; (= (.file loc) "core-types.toc")
                                   ;; (= (.line loc) 1414)
                                   nothing
                                   )]
              (for [
                    ;; TODO: attempting to replace a ProtoImpls target-c using this code fails dramatically
                    ;; No idea why.
                    ;; target-c (cond (instance? c/ProtoImpls target-c)
                    ;;                (get-value-type (.fn-sym target-c))
                    ;;                (se/state-error target-c))

                    ;; _ (map se-nop (fn [_]
                    ;;                 (cond print-info?
                    ;;                       (print-err 'call-site _LINE_ loc (.call-target old-ast)
                    ;;                        ;; "\n" 'target-c target-c
                    ;;                                  )
                    ;;                       '_)))

                    ;; TODO: this might have a perf hit. Check after all assertion tests pass
                    target-c (cond (or (instance? c/FnConstraint target-c)
                                       (instance? c/ReifiedConstraint target-c))
                                   (cata (fn [inner]
                                           ;; Get the current type info for any proto impls
                                           (cond (instance? c/ProtoImpls inner)
                                                 (get-value-type (ast/tag (.fn-sym inner) loc))

                                                 (se/state-error inner)))
                                         target-c
                                         se/state-error)

                                   (se/state-error target-c))
                    :let [arg-cs (map (.args ast) .constraint)
                          ;; _ (map print-info?
                          ;;        (fn [_]
                          ;;          (print-err 'call-site _LINE_ loc (.call-target old-ast)
                          ;;                     "\n" 'target-c target-c
                          ;;                     "\n\n" 'args (str "[" (-> arg-cs
                          ;;                                               (interpose "\n ")
                          ;;                                               to-str)
                          ;;                                       "]")
                          ;;                     )))
                          [result-type arg-cs] (c/do-call-value target-c arg-cs (list loc))
                          result-type (c/trim result-type)
                          ;; _ (map print-info?
                          ;;        (fn [_]
                          ;;          (print-err 'call-site _LINE_ loc (.call-target ast)
                          ;;                     "\n" 'result ;; result-type
                          ;;                     )))
                          ]
                    _ (update-constraint (.call-target ast)
                                         (.required-arities c/fn-constraint [arg-count])
                                         loc)
                    _ (either (map (and (= c/bottom-type result-type)
                                        (first (.constraints result-type)))
                                   (fn [_]
                                     (compilation-error 'site _LINE_ loc
                                                        "\n" old-ast
                                                        "\n\n" 'target-c target-c
                                                        "\n\n" 'arg-cs (map (.args ast) .constraint)
                                                        "\n\n" 'result-type result-type
                                                        "\n\n" (conf-ass _LINE_ result-type loc))))
                              (se/traverse (zip-lists (.args ast) arg-cs)
                                           (fn [[ast arg-c]]
                                             (update-constraint ast arg-c loc))))]
                (let [t4 (sys/clock_gettime)]
                  ;; (cond print-info?
                  ;;       (print-err 't1-t2 (sys/time-delta t1 t2)
                  ;;                  "\n" 't2-t3 (sys/time-delta t2 t3)
                  ;;                  "\n" 't3-t4 (sys/time-delta t3 t4)
                  ;;                  "\n" 't1-t4 (sys/time-delta t1 t4))
                  ;;       '_)
                  (-> ast
                      (.args (.args ast))
                      (.constraint result-type)))))))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (set-value-type (.sym ast) c/top-type)]
      (do
        ;; (let [loc (ast/location ast)]
        ;;   (or (= (.line loc) 0)
        ;;       ;; (= (.file loc) core)
        ;;       (and ;; (= (.sym ast) 'HashMap)
        ;;        (do
        ;;          (print-err 'checking _LINE_ loc ast)
        ;;          nothing))))
        (.value-exprs ast (-> (.value-exprs ast)
                              (remove (partial instance? ast/block-comment-ast))
                              (map (fn [inner-ast]
                                     (cond (instance? ast/fn-ast inner-ast)
                                           (.fn-sym inner-ast (.sym ast))

                                           (instance? c/SymbolConstraints inner-ast)
                                           (c/update-sym inner-ast (ast/untag (.sym ast)))

                                           inner-ast))))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))]
      (let [sym (.sym old-ast)]
        (for [_ (pop-types)
              c (either (map (last (.value-exprs ast))
                             (fn [val]
                               (cond (instance? c/Constraints val)
                                     ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                     ;; the updated version. Possibly a bug in assoc-in*

                                     ;; TODO: this version produces a very cryptic error message
                                     ;; (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                     ;;           (set-value-type (.sym old-ast) val))

                                     (flat-map (se/assoc-in-val [.types (ast/untag sym)] val)
                                               (fn [_]
                                                 (set-value-type sym (c/trim val))))

                                     (and (= c/top-type (.constraint val))
                                          (or (= sym 'empty-list)
                                              (= sym 'empty-vector)
                                              (= sym 'int-max)
                                              (= sym 'int-min)
                                              (= sym 'nothing)))
                                     (flat-map (get-value-type sym)
                                               (fn [c]
                                                 (set-value-type sym (c/update-path c loc))))

                                     (set-value-type sym (c/trim (.constraint val))))))
                        (set-value-type (.sym old-ast) c/top-type))]
          (do
            ;; (status 'defed _LINE_ loc (.sym old-ast)
            ;;            lflf c)
            ast))))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (gensym "fn-arity")
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) core)
            ;;          (and (= (.fn-sym ast) 'fn-apply)
            ;;               (do
            ;;                 (status 'pre-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'params (.params ast)
            ;;                         lflf 'body "[" (to-str (interpose (.body ast) lflf)) "]"
            ;;                         lflf 'const (.constraint ast))
            ;;                 nothing)))]
            _ (set-value-type ast/result-sym c/top-type)
            _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                      (set-value-type sym c/top-type)))
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   se-nop

                                   (append-value-type sym
                                                      (c/ParamConstraint arity-id index
                                                                  empty-list (ast/untag sym) "")
                                                      loc))))
            _ (append-value-type (.variadic (.params ast))
                                 (c/ParamConstraint arity-id arg-count
                                                    empty-list
                                                    (ast/untag (.variadic (.params ast)))
                                                    "")
                                 loc)
            ;; TODO: should use cata to make all the variadic syms be lists
            ]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast)))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (get-value-type ast/result-sym)
            _ (recover-val-type ast/result-sym)
            pts (get-param-types (.params old-ast))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            :let [body-c (either (map (last (.body ast)) .constraint)
                                 c/top-type)
                  final-c (elgot c/descend?
                                 (fn [c]
                                   (cond (= c c/empty-reified)
                                         c/top-type

                                         c))
                                 (c/intersect result-c body-c))]
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;          ;; (= (.file loc) core)
            ;;          (and (= (.fn-sym ast) 'cross-lists)
            ;;               (do
            ;;                 (status 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'pts pts
            ;;                         lflf 'result-c result-c
            ;;                         lflf 'body-c body-c
            ;;                         lflf 'final-c final-c
            ;;                         lflf 'body-exprs (str "[" (to-str (interpose (.body ast) "\n")) "]"))
            ;;                 nothing)))]
            _ (either (map (or (= c/bottom-type pts)
                               (= c/bottom-type final-c))
                           (fn [failure-c]
                             (compilation-error 'arity _LINE_ loc (.fn-sym old-ast)
                                                lflf 'pts pts
                                                lflf 'result-c result-c
                                                lflf 'body-c body-c
                                                lflf 'final-c final-c
                                                lflf 'body (either (map (last (.body ast)) .constraint)
                                                                     c/top-type)
                                                lflf (conf-ass _LINE_ failure-c loc))))
                      se-nop)]
        ;; TODO: use update-constraint here
        (.constraint ast (c/trim (c/intersect (.constraint ast)
                                              (c/fn-arity (.fn-var ast) pts final-c))))))))

(extend-type ast/fn-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          sym (.fn-sym ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  "\n" ast)
      ;;       nothing))
      (for [_ (push-types)
            _ (set-value-type sym (-> c/fn-constraint
                                      (c/intersect (c/coll-of-c c/empty-reified))
                                      (c/update-path loc)
                                      (c/update-sym (ast/untag sym))))]
        (.arities ast (map (.arities ast)
                           (fn [arity]
                             (.fn-sym arity sym)))))))

  (type-check [ast old-ast]
    (let [sym (.fn-sym ast)
          fn-c (-> c/fn-constraint
                   (c/update-path (ast/location sym))
                   (c/update-sym (ast/untag sym)))
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (get-in arity-c [.param-consts .tail-c])
                                         :when (= c/no-tail variadic)
                                         fixed-params (get-in arity-c [.param-consts .items])]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) "\n" fn-c)
      ;;         nothing)))
      (flat-map (nip-types)
                (fn [_]
                  (se/state-error (.constraint ast fn-c)))))))

(extend-type ast/tagged-symbol
  TypeChecker
  (param-types [sym]
    (get-value-type sym))

  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (all-symbols [ast]
    [ast])

  (recover-val-type [sym]
    (flat-map (se/get-in-val [.value-types])
              (fn [types-list]
                (assert (instance? List types-list))
                (map (either (for [value-types (nth types-list 1)
                                   prev-constraint (get value-types sym)]
                               (set-value-type sym prev-constraint))
                             (remove-value-type sym))
                     RecurseFinal))))

  (type-check [s old-s]
    (map (get-value-type s)
         (partial .constraint s))))

(extend-type ast/params-ast
  TypeChecker
  (recover-val-type [x]
    (se/state-error (RecurseWith x)))

  (update-constraint [ast constraint loc]
    (either (map (instance? c/ListConstraint (.variadic ast))
                 (fn [_]
                   (status "Compiler error:" _FILE_ _LINE_ "\n" 'variadic (.variadic ast))))
            '_)
    (let [new-c (-> (.constraint ast)
                    (c/intersect c/seq-constraint)
                    (c/intersect (c/update-path constraint loc)))]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c loc))))
              (let [[item-cs tail-item-cs] (-> (c/get-items new-c)
                                               (split (count (.fixed ast))))
                    tail-c (-> c/list-constraint
                               (c/set-items tail-item-cs)
                               (c/set-tail (c/get-tail new-c))
                               (c/replace-path (.path new-c)))]
                (for [_ (se/traverse (zip-lists (seq (.fixed ast)) item-cs)
                                     (fn [[ast c]]
                                       (update-constraint ast c loc)))
                      _ (update-constraint (.variadic ast) tail-c loc)]
                  (.constraint ast new-c))))))

  (all-symbols [params]
    (comp* (.variadic params)
           (seq (.fixed params))))

  (param-types [params]
    (-> c/seq-constraint
        (c/set-tail (.variadic params))
        (c/set-items (.fixed params))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> c/seq-constraint
                (c/set-items (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (map (append-value-type (.variadic ast) c/list-constraint
                              (ast/location (.variadic ast)))
           (fn [appended-var]
             (-> ast
                 (.constraint (c/set-tail c c/coll-of-any))
                 (.variadic (either (= c/no-symbol (.variadic ast))
                                    (.constraint (ast/tag (.variadic ast))
                                                 appended-var)))))))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (for [
          ;; _ (map se-nop (fn [_]
          ;;                 (print-err 'extending _LINE_ (ast/location ast) (.type ast))))
          type-info (get-type-info (.type ast) (ast/location ast))
          ;; TODO: don't allow extension of refined types
          :let [type-infos (cond (instance? c/SumConstraint type-info)
                                 (.alts type-info)
                                 [type-info])]
          new-ast (map ast
                       (fn [arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (either (-> (.params arity)
                                     .fixed
                                     first 
                                     (map (fn [first-param]
                                            ;; (print-err 'params _LINE_ (ast/location first-param)
                                            ;; first-param)
                                            (let [disp-param (ast/untag first-param)]
                                              (-> type-infos
                                                  (map (fn [type-info]
                                                         (let [type-info (c/update-sym type-info disp-param)
                                                               new-bod (comp [type-info] (.body arity))]
                                                           (ProtoArity (c/type-num type-info)
                                                                       (.body arity new-bod)))))
                                                  se/state-error)))))
                                 (compilation-error "Prototype implentation for "
                                                    (str "'" (.fn-sym arity) "'")
                                                    "must have at least one parameter at"
                                                    (ast/location (.fn-sym arity)))))
                       se/state-error)]
      (-> (either (get new-ast .impls)
                  {})
          vals
          vec
          (map vals)
          (map vec)))))

(extend-type ast/string-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (-> (.constraint ast (assoc-in c/strbuff-constraint [.fields 'static-value] str-val))
          se/state-error ))))

(extend-type ast/integer-ast
  TypeChecker
  (type-check [ast old-ast]
    (-> (.constraint ast (-> (assoc-in c/int-constraint [.fields 'static-value] (.int old-ast))
                             (c/update-path (ast/location old-ast))))
        se/state-error)))

(deftype OrClause [clause types]
  Stringable
  (string-list [_]
    (list "(OrClause " (str clause) " {})"))

  Container
  (map [_ f]
    (OrClause (f clause) types))

  (map [c f embed]
    (map (f clause)
         (partial .clause c)))

  ast/FileLoc
  (ast/location [_]
    (ast/location clause))

  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (let [loc (ast/location old-ast)]
      (for [new-clause (update-constraint (.clause ast) c/maybe-constraint loc)
            types (pop-types)]
        (OrClause new-clause types)))))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clause (OrClause (.clause ast) {}))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          _ (push-types (.types (.clause ast)))]
      (let [new-clause (.clause (.clause ast))]
        (-> ast
            (.clause new-clause)
            (.constraint (-> (c/sum-type [(.base c/inner-type-of (.constraint new-clause))
                                          (.constraint (.alt ast))])
                             (c/update-path (ast/location old-ast)))))))))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          ;; _ (map se-nop
          ;;        (fn [_]
          ;;          (let [loc (ast/location ast)]
          ;;            (or (= (.line loc) 0)
          ;;                (= (.file loc) 'core)
          ;;                (do
          ;;                  (status 'checking-binding _LINE_ loc
          ;;                             "\n" 'ast ast)
          ;;                  nothing)))))
          _ (se/traverse (all-syms (.binding ast)) (fn [sym]
                                                     (set-value-type sym c/top-type)))]
      ast))

  (type-check [ast old-ast]
    (let [binding (.binding ast)
          val (.val ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [binding-c (cata param-types binding se/state-error)
            _ (se/traverse (all-syms binding) recover-val-type)
            val-c (update-constraint val binding-c loc)
            ;; :let [loc (ast/location old-ast)
            ;;       _ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;          (do
            ;;            (status 'let _LINE_ loc
            ;;                    "\n" 'binding (type-name binding) binding
            ;;                    "\n\n" 'val val
            ;;                    "\n\n" 'orig-val-c (.constraint val)
            ;;                    "\n\n" 'val-c val-c)
            ;;            nothing))]
            _ (nip-types)]
        (.constraint ast (either (and (instance? Vector cont)
                                      (map (last cont) .constraint))
                                 (.constraint (.cont ast))))))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (for [types (get-types)]
      (.types ast types)))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)]
      (for [_ (pop-types)
            _ (push-types (.types ast))
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            ]
        (-> ast
            (.clause (update-constraint clause c/maybe-constraint (ast/location old-ast)))
            (.constraint (.constraint cont)))))))

(extend-type ast/cond-ast
  TypeChecker
  (pre-check [ast]
    (for [types (get-types)]
      (.types ast types)))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          val (.value ast)
          cont (.cont ast)]
      (for [_ (pop-types)
            _ (push-types (.types ast))
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            ]
        (-> ast
            (.clause (update-constraint clause c/maybe-constraint (ast/location old-ast)))
            (.constraint (c/trim (c/sum-type [(.constraint val)
                                              (.constraint cont)]))))))))

(def _ (print-err 'creating-parser))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(defn type-check-ast [ast]
  (cond (and (= c/bottom-type ast)
             (first (.constraints ast)))
        (compilation-error (conf-ass _LINE_ ast (ast/location ast)))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (status 'type-checking _LINE_ loc
              ;;                 lflf 'ast ast
              ;;                 lflf 'new-ast new-ast)]
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and ;; (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                             lflf 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and ;; (extract flag)
            ;;        (maybe (status 'final-ast _LINE_ loc
            ;;                          lflf final-ast))))
            final-ast))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (apply-to (fn [type-checker ast]
                ;; (status 'ast _LINE_ ast)
                (send type-checker update-context
                      (flat-map se-nop
                                (fn [_]
                                  (status 'checking _LINE_ ast)
                                  (se/try
                                    (comp (type-check-ast ast)
                                          (compilation-error "Could not type check code for expression at "
                                                             (ast/location ast)))
                                    (fn [err]
                                      (send output (fn [_]
                                                     (print-err (.val err))
                                                     (abort)))
                                      (wait-for-output)
                                      se-nop)))))
                ast)
              (grmr/get-value 'type-checker)
              rdr/top-level))))
(def _ (print-err 'parser-created))

(defn compile-module [file-name root-dir proj-dir module-index]
  ;; kick off a thread to load and check the module
  (status "Loading" file-name)
  ;; try to open file for reading
  (either (map (fio/file-in (c/file-name file-name))
               (fn [file-in]
                 ;; if opened, parse and type check it
                 (let [ast-checker (agent (new-module file-name module-index))
                       loading (promise)
                       parse-result (parse-forms {'file-name file-name
                                                  'root-directory root-dir
                                                  'project-directory proj-dir
                                                  'line-number 1
                                                  'type-checker ast-checker
                                                  'result-prom loading}
                                                 (lazy-list file-in))]
                   (cond (instance? rd/ParserError parse-result)
                         (do
                           (send output (fn [_]
                                            (print-err (.msg parse-result))
                                            (abort)))
                           (wait-for-output))

                         ;; after all expressions have been checked,
                         ;; deliver the resulting Module
                         (send ast-checker (partial deliver loading)))
                   loading)))

          ;; or tell everyone it couldn't be
          (do
            (send output (fn [_]
                           (print-err "Could not find/open " file-name)
                           (abort)))
            (wait-for-output))))

(main [params]
  (let [core-start (sys/clock_gettime)
        core-mod (extract (compile-module core toccata-dir toccata-dir 0))]
    (send modules (fn [_]
                    {core core-mod}))
    (status 'time-for-core (div (sys/time-delta core-start (sys/clock_gettime)) 1000))
    ;; (-> (rest params)
    ;;     ;; TODO: empty-defn causes mem leaks
    ;;     ;; (remove (partial = "assertion-tests/empty-defn.toc"))
    ;;     (map (fn [file-name]
    ;;            (map (sys/file-directory file-name)
    ;;                 (fn [root-dir]
    ;;                   (send modules (fn [_]
    ;;                                   {core core-mod}))
    ;;                   (let [_ (send output (fn [_]
    ;;                                          (fio/file-out (str file-name ".err"))))
    ;;                         core-result (compile-module file-name toccata-dir toccata-dir)
    ;;                         core-result (either (map (instance? Promise core-result) extract)
    ;;                                             core-result)]
    ;;                     (cond (instance? Module core-result)
    ;;                           (status 'Loaded file-name)

    ;;                           (do
    ;;                             (either (map (instance? se/Error core-result)
    ;;                                          (fn [err]
    ;;                                            (status (.val err))))
    ;;                                     (status "Could not load Toccata file:" file-name))))))))))
    )

  (wait-for-output))
