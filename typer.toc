
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "02ee23c"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "e62b358"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "c2488d4"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
;; (add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
;;                            "free.toc"
;;                            :sha "5c353f2"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(def output (agent (maybe nothing)))

(def core-start (promise))
(def max-time (agent 0))
(def start-time (agent 0))

(defn status [& msg]
  (send output (fn [out-file?]
                 ;; (assert (instance? Maybe out-file?))

                 ;; (and out-file?
                 ;;      (maybe (apply print-err msg)))

                 (apply print-err msg)
                 ;; (map out-file?
                 ;;      (fn [out-file]
                 ;;        (fio/write out-file (str (to-str (interpose msg " ")) lf))
                 ;;        out-file))
                 )))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(def core (c/ToccataCore path-to-core))

(def lf "\n")
(def lflf "\n\n")

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 lf
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(def curr-arity (c/tag "#curr-arity"))
(def Function-sym (c/tag 'Function))
(def invoke-sym (c/tag 'invoke))
(def Type-sym (c/tag 'Type))
(def type-name-sym (c/tag 'type-name))
(def has-field-sym (c/tag 'has-field))
(def Eq-sym (c/tag 'Eq))
(def =*-sym (c/tag '=*))
(def get-symb (c/tag 'get))
(def maybe-sym (c/tag 'maybe))
(def assoc-sym (c/tag 'assoc))
(def sha1-sym (c/tag 'sha1))
(def sha1-update-sym (c/tag 'sha1-update))
(def sha1-init-sym (c/tag 'sha1-init))
(def sha1-finalize-sym (c/tag 'sha1-finalize))
(def sha1-update-type-sym (c/tag 'sha1-update-type))
(def default-type-args-sym (c/tag 'default-type-args))
(def identical-sym (c/tag 'identical))
(def nothing-sym (c/tag 'nothing))
(def get-type-sym (c/tag 'default-get-type))
(def Associative-sym (c/tag 'Associative))
(def Hashable-sym (c/tag 'Hashable))
(def instance?-sym (c/tag 'instance?))
(def Container-sym (c/tag 'Container))
(def apply-sym (c/tag 'apply))
(def Stringable-sym (c/tag 'Stringable))
(def string-list-sym (c/tag 'string-list))
(def list-sym (c/tag 'list))

(deftype ProtoArity [type-num arity]
  (assert (instance? (all-of Integer (min 1))
                     type-num))

  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (partial .arity x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location arity)))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol)
                             Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (let [core-prom (promise)]
    ;; (send modules (fn [mods]
    ;;                 (map (get mods core)
    ;;                      (partial deliver core-prom))
    ;;                 mods))
    (Module file-name module-index {}
            (cond (= module-index 0)
                  {}
                  {core core-mod})
            c/core-type-constraints
            (list {'empty-list (c/update-sym c/empty-list-constraint
                                             (c/tag 'empty-list))
                   'empty-vector (c/update-sym c/empty-vect-constraint
                                               (c/tag 'empty-vector))
                   'int-max (assoc-in c/int-constraint
                                      [.fields c/static-value] int-max)
                   'int-min (assoc-in c/int-constraint
                                      [.fields c/static-value] int-min)
                   'nothing (assoc-in c/maybe-constraint
                                      [.fields c/contents] c/no-contents)}))))

(def type-counter (int-generator c/TypeCount))

(defn report-type-stack [& msg]
  (map (se/get-val .value-types)
       (fn [vts]
         (status 'type-depth (to-str (interpose msg " "))
                 (count vts)))))

(defn get-types []
  (se/get-in-val [.value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.value-types])
            (fn [types-list]
              (se/assoc-in-val [.value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn add-getter [sym types-list]
  (assert (instance? c/TaggedSymbol sym))
  (assert (instance? (list-of HashMap) types-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [field-sym (c/Field sym)
        required-field (-> c/empty-reified
                           (.fields {field-sym c/top-type})
                           (.type-symbol (c/tag (str "field '" (rest (str sym)) "' required"))))
        getter-sym (c/tag (str sym "_getter"))
        setter-sym (c/tag (str sym "_setter"))
        arities {1 (c/fn-arity getter-sym
                               (c/seq-c [(c/multi [(c/param getter-sym 0)
                                                   required-field])])
                               (c/type-op c/get-from-op (c/param getter-sym 0)
                                          [field-sym]))
                 2 (c/fn-arity setter-sym
                               (c/seq-c [(c/multi [(c/param setter-sym 0)
                                                   required-field])
                                         (c/param setter-sym 1)])
                               (c/type-op c/set-to-op (c/param setter-sym 0)
                                          [[field-sym] (c/param setter-sym 1)]))}
        getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? types-list)
          (list {sym getter})

          (get-in types-list [0 sym])
          types-list

          (map types-list (fn [value-types]
                            (assoc value-types sym getter))))))

(defn get-core-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))

  (se/new-se (fn [s]
               (either (or (and (= 0 (.index s))
                                (or (map (get-in s [.value-types 0 sym])
                                         (fn [val-type]
                                           [val-type s]))
                                    (for [first-char (first (str sym))
                                          _ (= first-char ".")
                                          new-s (update-in s [.value-types]
                                                           (fn [val-types]
                                                             (add-getter sym val-types)))
                                          val-type (get-in new-s [.value-types 0 sym])]
                                      [val-type new-s])
                                    (maybe se/Failure)))
                           (map (get-in s [.namespaces core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           (for [first-char (first (str sym))
                                 _ (= first-char ".")
                                 new-s (update-in s [.namespaces core .value-types]
                                                  (fn [val-types]
                                                    (add-getter sym val-types)))
                                 val-type (get-in new-s [.namespaces core .value-types 0 sym])]
                             (do
                               ;; (send modules
                               ;;       (fn [mods]
                               ;;         (assert-result r (instance? HashMap r))
                               ;;         (either (or (get-in mods [core .value-types 0 sym])
                               ;;                     (update-in mods [core .value-types]
                               ;;                                (fn [val-types]
                               ;;                                  (add-getter sym val-types))))
                               ;;                 mods)))
                               [val-type new-s]))
                           ;; last ditch effort
                           ;; (let [core-prom (promise)]
                           ;;   ;; (status 'sending sym _LINE_)
                           ;;   (send modules (fn [mods]
                           ;;                   (assert-result r (instance? HashMap r))
                           ;;                   (either (or (map (get-in mods [core .value-types 0 sym])
                           ;;                                    (fn [val-type]
                           ;;                                      (deliver core-prom (maybe val-type))
                           ;;                                      mods))
                           ;;                               (for [first-char (first (str sym))
                           ;;                                     _ (= first-char ".")
                           ;;                                     new-mods (update-in mods [core .value-types]
                           ;;                                                         (fn [val-types]
                           ;;                                                           (add-getter sym val-types)))
                           ;;                                     val-type (get-in new-mods [core .value-types 0 sym])]
                           ;;                                 (do
                           ;;                                   (deliver core-prom (maybe val-type))
                           ;;                                   new-mods)))
                           ;;                           (do
                           ;;                             (deliver core-prom nothing)
                           ;;                             mods))))
                           ;;   (map (extract core-prom)
                           ;;        (fn [expr]
                           ;;          [expr s])))
                           )
                       se/Failure))))

(defn get-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (= sym c/no-symbol)
        c/top-type

        (let [loc (ast/location sym)]
          ;; TODO: this does not look up namespaced symbols
          (comp (se/get-in-val [.value-types 0 sym])
                (get-core-value-type sym)
                (compilation-error "Could not find type constraint for" (str "'" sym "'") "at" loc)))))

(defn set-value-type [sym constraint]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? c/Constraints constraint))

  (cond (= c/no-symbol sym)
        (se/state-error constraint)

        (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ constraint)
          se-nop)

        (map (se/update-in-val [.value-types]
                               (fn [types-list]
                                 (either (map (first types-list)
                                              (fn [value-types]
                                                (-> value-types
                                                    (dissoc sym)
                                                    (assoc sym constraint)
                                                    (cons (rest types-list)))))
                                         (list {sym constraint}))))
             (fn [_]
               constraint))))

(defn append-value-type [sym constraint loc]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? c/Constraints constraint))

  (cond (= sym c/no-symbol)
        (se/state-error constraint)

        (= (str sym) "")
        (map se-nop (fn [_]
                      (status "Bad call to append-value-type" _LINE_ loc sym lf constraint)
                      '_))

        (= constraint c/top-type)
        (se/try
          (get-value-type sym)
          (fn [_]
            (se/state-error c/top-type)))

        (= constraint c/bottom-type)
        (compilation-error ;; 'site _LINE_ loc 'appending sym
                           ;; lflf 'constraint constraint
                           ;; lflf
                           (conf-ass _LINE_ constraint loc))

        (flat-map (se/try
                    (get-value-type sym)
                    (fn [_]
                      (se/state-error c/top-type)))
                  (fn [curr-const]
                    (cond (= curr-const c/top-type)
                          (set-value-type sym (c/update-path constraint loc))

                          (let [new-const (c/intersect (c/update-path constraint loc)
                                                       curr-const)]
                            ;; (let [loc (ast/location sym)]
                            ;;   (or ;; (= (.file loc) core)
                            ;;       ;; (= (.line loc) 0)
                            ;;       (do
                            ;;         (status 'appending _LINE_ loc (str "\"" sym "\"")
                            ;;                 lf 'constraint constraint
                            ;;                 lflf 'curr curr-const
                            ;;                 lflf 'untrimmed (c/intersect curr-const constraint)
                            ;;                 lflf 'new-const new-const)
                            ;;         nothing)))

                            (cond (= new-const c/bottom-type)
                                  (compilation-error ;; 'site _LINE_ loc 'appending sym
                                                     ;; lf 'curr curr-const
                                                     ;; lflf 'constraint constraint
                                                     ;; lflf 'new-const new-const
                                                     ;; lflf
                                                     (conf-ass _LINE_ new-const loc))

                                  (instance? c/ProtoImpls curr-const)
                                  se-nop

                                  (set-value-type sym (c/update-path new-const loc)))))))))

(defn remove-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))
  (se/update-in-val [.value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types sym)
                                           (rest types-list))))
                              types-list))))

(defn get-type-info [type-sym]
  (assert (instance? c/TaggedSymbol type-sym))

  ;; TODO: needs to handled namespaced type-sym
  ;; (or ;; (= (.file loc) core)
  ;;     ;; (= (.line loc) 0)
  ;;  (and ( = type-sym 'BitmapIndexedNode)
  ;;       (do
  ;;         (status 'get-type _LINE_ loc type-sym)
  ;;         (maybe '_))))
  (comp (se/get-in-val [.types type-sym])
        (se/get-in-val [.namespaces core .types type-sym])
        ;; (flat-map se-nop
        ;;           (fn [_]
        ;;             ;; Look in the core module
        ;;             (let [core-prom (promise)]
        ;;               (send modules (fn [mods]
        ;;                               ;; (or ;; (= (.file loc) core)
        ;;                               ;;  ;; (= (.line loc) 0)
        ;;                               ;;  (and ( = type-sym 'BitmapIndexedNode)
        ;;                               ;;       (do
        ;;                               ;;         (status 'get-type _LINE_ loc type-sym lf
        ;;                               ;;                 (get-in mods [core .types (ast/untag type-sym)]))
        ;;                               ;;         (maybe '_))))
        ;;                               (either (or (for [core-mod (get mods core)
        ;;                                                 _ (instance? Promise core-mod)]
        ;;                                             (deliver core-prom se/zero-se))
        ;;                                           (map (get-in mods [core .types (ast/untag type-sym)])
        ;;                                                (fn [type-inf]
        ;;                                                  (deliver core-prom (se/state-error type-inf)))))
        ;;                                       (deliver core-prom se/zero-se))
        ;;                               mods))
        ;;               (extract core-prom))))
        (compilation-error "No type named" (str "'" type-sym "'")
                           "was found. Used at" (ast/location type-sym))))

(defn add-impl [proto-impls type-num arg-count arity-c loc]
  (instance? c/ProtoImpls proto-impls)

  (either (map (get-in proto-impls [.default-impl .arities arg-count])
               (fn [dflt-arity]
                 (let [new-params (-> (.param-consts dflt-arity)
                                      c/get-items
                                      count
                                      range
                                      vec
                                      (map (partial c/param (.arity-id arity-c))))
                       ;; TODO: need to account for destructuring of params
                       dflt-arity (cond (= (str (.arity-id dflt-arity)) "")
                                           dflt-arity

                                           (let [def-ar (c/reify-type-constraint dflt-arity
                                                                                 (.arity-id dflt-arity)
                                                                                 new-params loc)]
                                             (cond (= c/bottom-type def-ar)
                                                   (do
                                                     (print-err 'site _LINE_ loc type-num arg-count
                                                                lflf 'dflt-arity dflt-arity
                                                                lflf 'params new-params
                                                                lflf (conf-ass _LINE_ def-ar loc))
                                                     (abort))
                                                   def-ar)))
                       new-arity-c (c/intersect arity-c dflt-arity)]
                   ;; (cond (and (= c/ListType type-num)
                   ;;            (= (.fn-sym proto-impls) 'vec))
                   ;;       (status 'proto-result _LINE_ loc
                   ;;               lflf 'def dflt-arity
                   ;;               lflf 'orig (get-in proto-impls [.default-impl .arities arg-count])
                   ;;               lflf 'arity arity-c
                   ;;               lflf 'new new-arity-c)

                   ;;       '_)
                   (cond (= new-arity-c c/bottom-type)
                         (compilation-error ;; 'impl _LINE_
                                            ;; lf 'def dflt-arity
                                            ;; lflf 'arity arity-c
                                            ;; lflf 'new new-arity-c
                                            ;; lflf
                                            (conf-ass _LINE_ new-arity-c loc))

                         ;; happy path
                         (either (update-in proto-impls [.impl-fns type-num]
                                            (fn [fn-c]
                                              (assert (instance? c/FnConstraint fn-c))

                                              (assoc-in fn-c [.arities arg-count] new-arity-c)))
                                 (assoc-in proto-impls [.impl-fns type-num]
                                           (.arities c/fn-constraint {arg-count new-arity-c})))))))
          (compilation-error "No prototype for" (str "'" (.fn-sym proto-impls) "'") "with"
                             (str arg-count) "arguments at" loc)))

(defn add-ns-impl [ns sym type-num arg-count arity-c loc]
  (fn [mods]
    (assert (instance? HashMap mods))
    (assert-result r (instance? HashMap r))

    (either (for [val-types-list (get-in mods [ns .value-types])
                  val-types (first val-types-list)
                  proto-impls (get val-types sym)]
              (let [new-proto (add-impl proto-impls type-num
                                        arg-count arity-c loc)
                    val-types-list (map val-types-list
                                        (fn [m]
                                          (assoc m sym new-proto)))]
                (cond (instance? c/ProtoImpls new-proto)
                      (assoc-in mods [ns .value-types]
                                val-types-list)

                      ;; add-impl might return a compilation error
                      (do
                        (status (.val new-proto))
                        (wait-for-output)
                        (abort)))))
            mods)))

(defn insert-invoke [type-num arity-c]
  (let [arity-rank (either (map (get-in arity-c [.param-consts])
                                (fn [params]
                                  (count (c/get-items params))))
                           0)]
    (se/update-val .types
                   (fn [types-info]
                     (map-vals types-info
                               (fn [type-info]
                                 (either (for [_ (instance? c/ReifiedConstraint type-info)
                                               _ (= (.type-number type-info) type-num)]
                                           (.invoke-fn type-info
                                                       (.arities c/fn-constraint
                                                                 {arity-rank arity-c})))

                                         type-info)))))))

(defn add-proto-impl [type-num fn-sym arg-count arity-c]
  (assert (instance? Integer type-num))
  (assert (instance? c/fn-arity arity-c))

  (cond (= type-num c/UnknownType)
        (abort)
        '_)
  (let [loc (ast/location fn-sym)]
    (cond (= (str fn-sym) "")
          (do
            (print-err 'compiler-error _LINE_ (str "'" fn-sym "'") (ast/location fn-sym)
                       lflf arity-c)
            (abort))

          (comp (for [proto-impls (se/get-in-val [.value-types 0 fn-sym])
                      new-proto (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                                      (flat-map (se-debug 'proto _LINE_ type-num fn-sym arg-count)
                                                (fn [_]
                                                  (compilation-error "An implementation for" (str "'" fn-sym "'")
                                                                     "already exists\n"
                                                                     "Redefinition attempted at" loc)))
                                      (let [new-proto (add-impl proto-impls type-num
                                                                arg-count arity-c loc)]
                                        (cond (instance? c/ProtoImpls new-proto)
                                              (for [vts (se/get-val .value-types)
                                                    _ (se/set-val .value-types
                                                                  (map vts (fn [m]
                                                                             (assoc m fn-sym new-proto))))]
                                                new-proto)

                                              ;; add-impl might return a compilation error
                                              new-proto)))
                      _ (cond (= invoke-sym fn-sym)
                              (insert-invoke type-num arity-c)

                              se-nop)]
                  new-proto
                  )
                ;; TODO: test for namespaced fn-sym
                (let [ns core]
                  (for [proto-impls (se/get-in-val [.namespaces ns .value-types 0 fn-sym])
                        new-proto (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                                        ;; TODO: what about 'invoke' and 'apply' impls
                                        ;; especially 'apply'
                                        (compilation-error "An implementation for" (str "'" fn-sym "'")
                                                           "already exists\n"
                                                           "Redefinition attempted at" loc)
                                        (let [new-proto (add-impl proto-impls type-num
                                                                  arg-count arity-c loc)]
                                          (cond (instance? c/ProtoImpls new-proto)
                                                (for [vts (se/get-in-val [.namespaces ns .value-types])
                                                      :let [new-vts (map vts
                                                                         (fn [m]
                                                                           (assoc m fn-sym new-proto)))]
                                                      _ (se/assoc-in-val [.namespaces ns .value-types]
                                                                         new-vts)]
                                                  (do
                                                    ;; (send modules (add-ns-impl fn-sym ns type-num
                                                    ;;                            arg-count arity-c loc))
                                                    new-proto))
                                                new-proto)))
                        _ (cond (= invoke-sym fn-sym)
                                (insert-invoke type-num arity-c)

                                se-nop)]
                    new-proto))
                (for [nss (se/get-in-val [.namespaces core .value-types 0])
                      _ (compilation-error 'wth _LINE_ fn-sym loc)]
                  '_)))))

(defprotocol TypeChecker
  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       lf (type-name ast) ast
                       lflf constraint))

  (recover-val-type [x]
    (assert-result r (instance? se/StateError r))

    (se/state-error (RecurseFinal x)))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    ;; TODO: put back in when done
    ;; (se/state-error ast)
    )

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       lf (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(def ConstrainedAST (any-of ast/call-ast
                            ;; ast/params-ast
                            ast/fn-ast
                            ;; ast/fn-arity-ast
                            ;; ast/let-ast
                            ast/or-ast
                            ast/and-ast
                            ast/either-ast
                            ast/string-ast
                            ast/integer-ast
                            ast/cond-ast
                            ast/binding-ast
                            ast/quoted-ast
                            ;; c/TaggedSymbol
                            ;; ast/prototype-ast
                            ;; ast/reify-ast
                            ast/block-comment-ast))

(extend-type Opaque
  Eq
  (=* [x y]
    nothing))

(extend-type ConstrainedAST
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error ;; 'site _LINE_ loc
                                        ;; lf 'ast ast
                                        ;; lflf 'ast-constraint (.constraint ast)
                                        ;; lflf 'constraint constraint
                                        ;; lflf 'new-c new-c
                                        ;; lflf
                                        (conf-ass _LINE_ new-c loc))))
              (se/state-error (.constraint ast (c/update-path new-c loc)))))))

(defn all-syms [params]
  (assert (instance? ast/ParamType params))

  (cata all-symbols params))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (apo recover-val-type params se/state-error))

(defn get-param-types [params]
  (assert (instance? (any-of c/TaggedSymbol ast/params-ast) params))

  (cata param-types params se/state-error))

;; TODO: remove when done
(def DefaultPreCheck (any-of Vector
                             ;; ProtoArity
                             c/AllValues
                             c/NoSymbol
                             c/ReifiedConstraint
                             c/SumConstraint
                             c/SeqConstraint
                             c/CollectionOf
                             c/TypeOfConstraint
                             c/FnConstraint
                             c/TypeOp
                             c/MultiConstraint
                             c/fn-arity
                             c/Field
                             c/NoTail
                             c/ParamConstraint
                             c/Contents
                             c/StaticValue
                             c/Min
                             c/Max
                             ast/string-ast
                             ast/integer-ast
                             ast/call-ast
                             ast/inline-ast
                             ast/do-ast
                             c/TaggedSymbol
                             ast/protocol-ast
                             ast/params-ast))

;; TODO: remove when done
(def DefaultTypeCheck (any-of Vector
                              c/AllValues
                              c/NoSymbol
                              c/NoTail
                              c/Contents
                              c/StaticValue
                              c/Min
                              c/Max
                              c/fn-arity
                              ast/protocol-ast
                              ast/block-comment-ast))

;; TODO: remove when done
(extend-type DefaultPreCheck
  TypeChecker
  (pre-check [ast]
    (se/state-error ast)))

;; TODO: remove when done
(extend-type DefaultTypeCheck
  TypeChecker
  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast)))

(def DefaultConst (any-of c/AllValues
                          c/ParamConstraint
                          c/FnConstraint
                          c/ReifiedConstraint
                          c/MultiConstraint
                          c/CollectionOf
                          c/SeqConstraint
                          c/SumConstraint
                          c/NoSymbol))

(extend-type DefaultConst ;; c/Constraints
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(def DefaultSymConst (any-of c/ReifiedConstraint
                             c/CollectionOf
                             c/SeqConstraint
                             c/SumConstraint
                             c/MultiConstraint
                             c/TypeOp
                             c/FnConstraint))

(extend-type DefaultSymConst ;; c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (append-value-type (.sym c) c loc))))

(extend-type Integer
  TypeChecker
  (pre-check [n]
    (se/state-error (c/IntegerConstraint n))))

(extend-type c/NoSymbol
  TypeChecker
  (update-constraint [x _ _]
    (se/state-error x)))

(extend-type c/NoValues
  TypeChecker
  (type-check [c old-c]
    (compilation-error (conf-ass _LINE_ c (ast/location c)))))

(extend-type c/Field
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c))

  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/ReifiedConstraint
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (flat-map (cond (= c/UnknownType (c/type-num c))
                      (get-type-info (.type-symbol c))
                      (se/state-error c))
                (fn [type-c]
                  (append-value-type (.sym c) type-c loc))))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    ;; TODO: restrict use to fn params only
    (flat-map (get-value-type (.param-sym old-c))
              (fn [type-c]
                (let [loc (ast/location c)]
                  (append-value-type (.sym c) type-c loc))))))

(extend-type ProtoArity
  TypeChecker
  (pre-check [ast]
    ;; (map (se-debug 'checking _LINE_ (ast/location ast))
    ;;      (fn [_]
    ;;        ast))
    (se/state-error ast)
    )

  (type-check [ast old-ast]
    (for [_ (add-proto-impl (.type-num ast)
                            (-> old-ast .arity .fn-sym)
                            (-> old-ast .arity .params .fixed count)
                            (-> ast .arity .constraint))]
      ast)))

(extend-type ast/inline-ast
  TypeChecker
  (type-check [ast old-ast]
    (map (type-check (.constraint ast) (.constraint ast))
         (partial .constraint ast))))

(extend-type ast/reify-ast
  TypeChecker
  (pre-check [ast]
    (let [reified-type-num (either (instance? Integer (.type-num ast))
                                   (extract type-counter))
          type-sym (c/tag (str "reified value at " (ast/location ast)))]
      (for [_ (push-types)
            _ (se/assoc-in-val [.types type-sym]
                               (c/ReifiedConstraint reified-type-num type-sym {} {}
                                                    c/fn-constraint empty-list c/no-symbol ""))]
        (-> ast
            (.type-num reified-type-num)
            (map (partial ProtoArity reified-type-num))))))

  (type-check [ast old-ast]
    (let [type-sym (c/tag (str "reified value at " (ast/location old-ast)))]
      (for [_ (pop-types)
            new-c (get-type-info type-sym)]
        (-> ast
            (map .arity)
            (.constraint new-c))))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          fixed-params (-> ast .params .fixed)
          arg-count (count fixed-params)
          all-param-syms (remove (all-syms (.params ast))
                                 (partial = (c/tag '_)))]
      (cond (< (count (set all-param-syms)) (count all-param-syms))
            (compilation-error "Duplicate parameter names in prototype at" loc)

            (for [_ (comp (se/get-in-val [.value-types 0 (.fn-name ast) .default-impl])
                          (set-value-type (.fn-name ast)
                                          (c/ProtoImpls (.fn-name ast)
                                                      (.arities c/fn-constraint {}) {})))
                  _ (push-types)
                  _ (set-value-type ast/result-sym c/top-type)
                  ;; :let [_ (or ;; (= (.line loc) 0)
                  ;;             ;; (= (.file loc) core)
                  ;;          (and (= (.fn-name ast) 'first)
                  ;;               (do
                  ;;                 (send output (fn [_] (maybe nothing)))
                  ;;                 (status 'pre-prototype _LINE_ (.fn-name ast) (ast/location ast)
                  ;;                         lf 'body (.default-body ast))
                  ;;                 nothing)))]
                  _ (se/traverse all-param-syms
                                 (fn [sym]
                                   (set-value-type sym c/top-type)))
                  _ (se/traverse (zip-lists fixed-params (range arg-count))
                                 (fn [[sym index]]
                                   (cond (instance? ast/params-ast sym)
                                         ;; TODO: this probably needs expanding
                                         se-nop

                                         (= sym '_)
                                         (set-value-type sym c/top-type) 

                                         (append-value-type sym
                                                            (c/param (.fn-name ast) index)
                                                            loc))))]
              ast))))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))
          variadic (.variadic (.params old-ast))]
      (for [pts (map (get-param-types (.params old-ast))
                     (fn [pts]
                       (-> pts
                           (c/set-seq-tail c/no-tail)
                           (c/intersect c/list-constraint))))
            result-c (se/try
                       (get-value-type ast/result-sym)
                       (fn [_]
                         (se/state-error c/top-type)))
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) core)
            ;;          (and (= (.fn-name ast) 'vec)
            ;;               (do
            ;;                 (status 'check-prototype _LINE_ (.fn-name ast) (ast/location ast)
            ;;                         lf ast
            ;;                         lflf 'pts pts
            ;;                         lflf 'result result-c)
            ;;                 (send output (fn [_] nothing))
            ;;                 nothing)))]
            :let [pts (c/set-seq-tail pts c/no-tail)
                  impl-c (c/fn-arity (.fn-name old-ast) pts result-c)]
            _ (remove-value-type ast/result-sym)
            _ (recover-types (.params old-ast))
            _ (nip-types)
            _ (se/update-in-val [.value-types]
                                (fn [types-list]
                                  (let [sym (.fn-name ast)]
                                    (either (map (first types-list)
                                                 (fn [value-types]
                                                   (cons (assoc-in value-types
                                                                   [sym .default-impl .arities arg-count]
                                                                   impl-c)
                                                         (rest types-list))))
                                            (list {sym (c/ProtoImpls sym
                                                                   (.arities c/fn-constraint
                                                                             {arg-count impl-c})
                                                                   {})})))))]
        (.constraint ast impl-c)))))

(extend-type ast/call-ast
  TypeChecker
  (type-check [ast old-ast]
    (either (and (= (.call-target old-ast) 'show-type)
                 (map (first (.args ast))
                      (fn [arg]
                        (status 'showing (ast/location (.call-target old-ast)) arg
                                lf (c/trim (.constraint arg)))
                        (se/state-error arg))))

          (let [loc (ast/location (.call-target old-ast))
                target-c (.constraint (.call-target ast))
                arg-cs (map (.args ast) .constraint)
                arg-count (count arg-cs)]
            ;; (for [_ (and (instance? c/ProtoImpls target-c)
            ;;              (< 1968 (.line loc)))
            ;;       disp-arg (map (first (.args ast)) .constraint)
            ;;       :let [val-num (c/type-num disp-arg)]
            ;;       :when-not (or (instance? c/ParamConstraint disp-arg)
            ;;                     (= c/UnknownType val-num)
            ;;                     (get-in target-c [.impl-fns val-num .arities arg-count]))]
            ;;   (status 'call-proto _LINE_ loc
            ;;           lf ast
            ;;           lflf 'disp val-num disp-arg))
            (let [print-info? (and (= (.call-target old-ast) 'assoc)
                                   (= (.line loc) 2896)
                                   ;; (= (.file loc) "assertion-tests/get-field.toc")
                                   nothing
                                   )]
              (for [
                    ;; TODO: attempting to replace a ProtoImpls target-c using this code fails dramatically
                    ;; No idea why.
                    ;; target-c (cond (instance? c/ProtoImpls target-c)
                    ;;                (get-value-type (.fn-sym target-c))
                    ;;                (se/state-error target-c))

                    ;; _ (map se-nop (fn [_]
                    ;;                 (cond print-info?
                    ;;                       (print-err 'call-site _LINE_ loc (.call-target old-ast)
                    ;;                        ;; lf 'target-c target-c
                    ;;                                  )
                    ;;                       '_)))

                    ;; TODO: this might have a perf hit. Check after all assertion tests pass
                    target-c (cond (or (instance? c/FnConstraint target-c)
                                       (instance? c/ReifiedConstraint target-c))
                                   (apo (fn [inner]
                                          ;; Get the current type info for any proto impls
                                          (cond (instance? c/ProtoImpls inner)
                                                (map (get-value-type (.fn-sym inner))
                                                     RecurseFinal)

                                                (se/state-error (RecurseWith inner))))
                                        target-c
                                        se/state-error)

                                   (se/state-error target-c))
                    :let [
                          _ (map print-info?
                                 (fn [_]
                                   (status 'call-site _LINE_ loc (.call-target old-ast)
                                           lf 'target-c target-c
                                           lflf 'args (str "[" (-> arg-cs
                                                                   (interpose "\n ")
                                                                   to-str)
                                                           "]")
                                           )))

                          [result-type param-cs] (c/do-call-value target-c arg-cs (list loc))
                          ;; result-type (c/trim result-type)

                          _ (map print-info?
                                 (fn [_]
                                   (status 'call-site _LINE_ loc (.call-target ast)
                                           lf 'result result-type
                                           lflf 'param-cs param-cs
                                           )))
                          ]
                    result-type (either (for [reified-c (instance? c/ReifiedConstraint result-type)
                                              :when-not (= c/no-symbol (.type-symbol reified-c))
                                              _ (= c/UnknownType (.type-number reified-c))]
                                          (map (get-type-info (.type-symbol reified-c))
                                               (fn [type-info]
                                                 (let [result-type (c/intersect result-type
                                                                                type-info)]
                                                   (map print-info?
                                                        (fn [_]
                                                          (status 'call-site _LINE_ loc (.call-target ast)
                                                                  lf 'reified-c reified-c
                                                                  lflf 'type-info type-info
                                                                  lflf 'inter result-type)))
                                                   result-type))))

                                        (se/state-error result-type))
                    new-args (either (map (= c/bottom-type result-type)
                                          (fn [_]
                                            (compilation-error ;; 'site _LINE_ loc
                                                               ;; lf old-ast
                                                               ;; lflf 'target-c target-c
                                                               ;; lflf 'arg-cs arg-cs
                                                               ;; lflf 'result-type result-type
                                                               ;; lflf
                                                               (conf-ass _LINE_ result-type loc))))
                                     (se/traverse
                                      (zip-lists (.args ast) param-cs)
                                      (fn [[ast arg-c]]
                                        (either (map print-info?
                                                     (fn [_]
                                                       (for [new-ast (update-constraint ast arg-c loc)
                                                             _ (se-debug 'updating-arg _LINE_ loc
                                                                         lflf 'ast ast
                                                                         lflf 'ast-c (.constraint ast)
                                                                         lflf 'arg-c arg-c
                                                                         lflf 'new-c
                                                                         (.constraint new-ast))]
                                                         new-ast)))
                                                (update-constraint ast arg-c loc)))))
                    _ (cond (instance? c/TypeOp result-type)
                            (update-constraint (.call-target ast)
                                               (c/fn-c [arg-count]
                                                       {c/variadic (c/fn-arity (c/tag 'arity-id)
                                                                               (c/seq-c arg-cs)
                                                                               ;; TODO: probably more
                                                                               ;; right
                                                                               ;; result-type
                                                                               c/top-type)})
                                               loc)
                            se-nop)]
                (-> ast
                    (.args (vec new-args))
                    (.constraint result-type))))))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(defn start-clock []
  (let [start (sys/clock_gettime)]
    (send start-time (fn [_] start))))

(defn stop-clock [ast]
  (let [end (sys/clock_gettime)]
    (send start-time (fn [start]
                       (let [delta (sys/time-delta start end)]
                         (send max-time (fn [prev-max]
                                          (cond (< prev-max delta)
                                                (do
                                                  (status 'slow _LINE_
                                                          (div delta 1000)
                                                          (ast/location ast)
                                                          lflf ast)
                                                  delta)
                                                prev-max)))
                         start)))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (set-value-type (.sym ast) c/top-type)]
      (.value-exprs ast (-> (.value-exprs ast)
                            (remove (partial instance? ast/block-comment-ast))
                            (map (fn [inner-ast]
                                   (cond (instance? ast/fn-ast inner-ast)
                                         (.fn-sym inner-ast (.sym ast))

                                         (instance? c/SymbolConstraints inner-ast)
                                         (c/update-sym inner-ast (.sym ast))

                                         inner-ast)))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))
          sym (.sym old-ast)]
      (for [_ (pop-types)
            c (either (map (last (.value-exprs ast))
                           (fn [val]
                             (cond (instance? c/Constraints val)
                                   ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                   ;; the updated version. Possibly a bug in assoc-in*

                                   ;; TODO: this version produces a very cryptic error message
                                   ;; (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                   ;;           (set-value-type (.sym old-ast) val))

                                   (let [val (c/trim val)]
                                     (flat-map (se/assoc-in-val [.types sym] val)
                                               (fn [_]
                                                 (set-value-type sym val))))

                                   (and (= c/top-type (.constraint val))
                                        (or (= sym 'empty-list)
                                            (= sym 'empty-vector)
                                            (= sym 'int-max)
                                            (= sym 'int-min)
                                            (= sym 'nothing)))
                                   (flat-map (get-value-type sym)
                                             (fn [c]
                                               (set-value-type sym (c/update-path c loc))))

                                   (set-value-type sym (c/trim (.constraint val))))))
                      (set-value-type (.sym old-ast) c/top-type))]
        (do
          ;; (status 'defed _LINE_ loc (.sym old-ast)
          ;;            lflf c)
          ast)))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (c/tag (gensym "fn-arity"))
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (start-clock)]

            ;; :let [_ (or (= (.line loc) 0)
            ;;             (= core (.file loc))
            ;;             (and (= (.fn-sym ast) 'f)
            ;;                  (do
            ;;                    (status 'pre-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                            lf 'params (.params ast)
            ;;                            lflf 'body "[" (to-str (interpose (.body ast) lflf)) "]"
            ;;                            lflf 'const (.constraint ast))
            ;;                    nothing)))]
            _ (set-value-type curr-arity
                              (c/fn-c []
                                      {c/variadic (c/fn-arity arity-id c/list-constraint c/top-type)}))
            _ (set-value-type ast/result-sym c/top-type)
            _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                      (set-value-type sym c/top-type)))
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   se-nop

                                   (append-value-type sym
                                                      (c/param arity-id index)
                                                      loc))))
            _ (append-value-type (.variadic (.params ast))
                                 (c/param arity-id arg-count)
                                 loc)
            ;; TODO: should use cata to make all the variadic syms be lists
            ]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast)))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (get-value-type ast/result-sym)
            ;; :let [_ (stop-clock ast)]
            _ (recover-val-type ast/result-sym)
            _ (recover-val-type curr-arity)
            pts (map (get-param-types (.params old-ast))
                     (fn [pts]
                       (cond (= c/no-symbol (.variadic (.params old-ast)))
                             (c/set-seq-tail pts c/no-tail)
                             pts)))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            :let [body-c (either (map (last (.body ast)) .constraint)
                                 c/top-type)
                  final-c (c/intersect result-c body-c)
                  checked-fnl (either (c/is-bottom pts)
                                      (elgot c/skip-protoimpls
                                             (fn [c]
                                               (c/reify-const c (.fn-var ast)
                                                              (-> pts c/get-items count
                                                                  (repeat c/top-type))))
                                             final-c))]
            ;; :let [_ (or (= core (.file loc))
            ;;             (= (.line loc) 0)
            ;;             (and (= (.fn-sym ast) 'f)
            ;;                  (do
            ;;                    (status 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                            lf 'pts pts
            ;;                            lflf 'result-c result-c
            ;;                            lflf 'body-c body-c
            ;;                            lflf 'final-c final-c
            ;;                            lflf 'checked-fnl checked-fnl
            ;;                            lflf 'ast-c (.constraint ast)
            ;;                            lflf 'body-exprs (str "[" (to-str (interpose (.body ast) lf))
            ;;                                                  "]"))
            ;;                    nothing)))]
            _ (either (map (= c/bottom-type checked-fnl)
                           (fn [failure-c]
                             (compilation-error ;; 'arity _LINE_ loc (.fn-sym old-ast) (.fn-var ast)
                                                ;; lflf 'pts pts
                                                ;; lflf 'result-c result-c
                                                ;; lflf 'body-c body-c
                                                ;; lflf 'final-c final-c
                                                ;; ;; lflf 'body (either (map (last (.body ast))
                                                ;; ;;                         .constraint)
                                                ;; ;;                    c/top-type)
                                                ;; lflf 'failure-c failure-c
                                                ;; lflf
                                                (conf-ass _LINE_ failure-c loc)
                              )))
                      se-nop)]
        ;; TODO: use update-constraint here
        (cond (= c/bottom-type pts)
              '_

              (.constraint ast (c/intersect (.constraint ast)
                                            (c/fn-arity (.fn-var ast) pts final-c))))))))

(extend-type ast/fn-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          sym (.fn-sym ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  lf ast)
      ;;       nothing))
      (for [_ (push-types)
            _ (set-value-type sym (-> c/fn-constraint
                                      ;; TODO: worry about recursion later
                                      ;; (c/intersect (c/coll-of-c c/empty-reified))
                                      (c/update-path loc)
                                      (c/update-sym sym)))]
        (.arities ast (map (.arities ast)
                           (fn [arity]
                             (.fn-sym arity sym)))))))

  (type-check [ast old-ast]
    (let [sym (.fn-sym ast)
          fn-c (-> c/fn-constraint
                   (c/update-path (ast/location sym))
                   (c/update-sym sym))
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (map (get-in arity-c [.param-consts])
                                                       c/seq-tail)
                                         :when (= c/no-tail variadic)
                                         fixed-params (map (get-in arity-c [.param-consts])
                                                           c/get-items)]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) lf fn-c)
      ;;         nothLing)))
      (flat-map (nip-types)
                (fn [_]
                  (se/state-error (.constraint ast fn-c)))))))

(extend-type Symbol
  TypeChecker
  (pre-check [s]
    (print-err 'wut _LINE_ s)
    (se/state-error (abort))))

(extend-type c/TaggedSymbol
  TypeChecker
  (param-types [sym]
    (get-value-type sym))

  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (all-symbols [ast]
    [ast])

  (recover-val-type [sym]
    (flat-map (se/get-in-val [.value-types])
              (fn [types-list]
                (assert (instance? List types-list))
                (map (either (for [value-types (nth types-list 1)
                                   prev-constraint (get value-types sym)]
                               (set-value-type sym prev-constraint))
                             (remove-value-type sym))
                     RecurseFinal))))

  (type-check [s old-s]
    (map (get-value-type s)
         (partial .constraint s))))

(extend-type ast/params-ast
  TypeChecker
  (recover-val-type [x]
    (se/state-error (RecurseWith x)))

  (update-constraint [ast constraint loc]
    (let [new-c (-> (.constraint ast)
                    (c/intersect c/seq-constraint)
                    (c/intersect (c/update-path constraint loc)))]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c loc))))
              (let [tail-item-cs (-> (c/get-items new-c)
                                     (drop (count (.fixed ast))))
                    item-cs (map (range (count (.fixed ast)))
                                 (fn [idx]
                                   (c/do-get-from new-c [idx] (list loc))))
                    tail-c (-> (c/seq-c tail-item-cs (c/get-tail new-c))
                               (c/replace-path (.path new-c)))]
                ;; TODO: these are possibly redundant intersects
                (for [_ (se/traverse (zip-lists (seq (.fixed ast)) item-cs)
                                     (fn [[ast c]]
                                       (update-constraint ast c loc)))
                      _ (update-constraint (.variadic ast) tail-c loc)]
                  (.constraint ast new-c))))))

  (all-symbols [params]
    (comp* (.variadic params)
           (seq (.fixed params))))

  (param-types [params]
    (-> (c/seq-c (.fixed params) (cond (= c/no-symbol (.variadic params))
                                       c/no-tail
                                       (.variadic params)))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> (c/seq-c (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (map (append-value-type (.variadic ast) c/list-constraint
                              (ast/location (.variadic ast)))
           (fn [appended-var]
             (-> ast
                 (.constraint (c/set-seq-tail c c/coll-of-any))
                 (.variadic (either (= c/no-symbol (.variadic ast))
                                    (.constraint (.variadic ast)
                                                 appended-var)))))))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (let [type-sym (.type ast)]
      (for [_ (push-types)
            ;; _ (map se-nop (fn [_]
            ;;                 (print-err 'extending _LINE_ (ast/location ast) (.type ast))))
            type-info (get-type-info type-sym)
            ;; TODO: don't allow extension of refined types
            :let [type-infos (cond (instance? c/SumConstraint type-info)
                                   (.alts type-info)
                                   [type-info])]
            new-ast (map ast
                         (fn [arity]
                           (assert (instance? ast/fn-arity-ast arity))
                           (either (-> (.params arity)
                                       .fixed
                                       first 
                                       (map (fn [first-param]
                                              ;; (print-err 'params _LINE_ (ast/location first-param)
                                              ;; first-param)
                                              (-> type-infos
                                                  (map (fn [type-info]
                                                         (let [type-info (c/update-sym type-info
                                                                                       first-param)
                                                               new-bod (comp [type-info] (.body arity))]
                                                           (ProtoArity (c/type-num type-info)
                                                                       (.body arity new-bod)))))
                                                  se/state-error))))
                                   (compilation-error "Prototype implentation for "
                                                      (str "'" (.fn-sym arity) "'")
                                                      "must have at least one parameter at"
                                                      (ast/location (.fn-sym arity)))))
                         se/state-error)]
        (-> (either (get new-ast .impls)
                    {})
            vals
            vec
            (map vals)
            (map vec)
            (conj (reify
                    Type
                    (type-name [_]
                      (str "reified at " (c/Location _FILE_ _LINE_)))

                    Stringable
                    (string-list [_]
                      (list (str "reified at " (c/Location _FILE_ _LINE_))))

                    Container
                    (map [y f embed]
                      (embed y))

                    TypeChecker
                    (pre-check [x]
                      (flat-map (pop-types)
                                (fn [_]
                                  (se/state-error (ast/block-comment-ast [] c/no-loc
                                                                         c/top-type))))))))))))

(extend-type ast/string-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (-> (.constraint ast (assoc-in c/strbuff-constraint [.fields c/static-value] str-val))
          se/state-error ))))

(extend-type ast/integer-ast
  TypeChecker
  (type-check [ast old-ast]
    (-> (.constraint ast (-> (assoc-in c/int-constraint [.fields c/static-value] (.int old-ast))
                             (c/update-path (ast/location old-ast))))
        se/state-error)))

(deftype PushTypes [expr]
  Stringable
  (string-list [pt]
    (list (str "(PushTypes " expr ")")))

  TypeChecker
  (pre-check [_]
    (flat-map (push-types)
              (fn [_]
                (pre-check expr)))))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.alt (PushTypes (.alt ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          new-clause (update-constraint (.clause ast) c/maybe-constraint (ast/location old-ast))]
      (.constraint ast (-> (c/sum-c [(.base c/inner-type-of (.constraint new-clause))
                                     (.constraint (.alt ast))])
                           (c/update-path (ast/location old-ast)))))))

(deftype Binder [binding val]
  Stringable
  (string-list [_]
    (list "(Binder " (str binding) " " (str val) ")"))

  Container
  (map [x f]
    (.val x (f val)))

  (map [x f embed]
    (map (f val)
         (partial .val x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location binding))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (let [loc (ast/location val)]
      (for [_ (push-types)
            _ (se/traverse (all-syms (.binding ast))
                           (fn [sym]
                             (set-value-type sym c/top-type)))]
        val))))

(extend-type ast/do-ast
  TypeChecker
  (type-check [ast old-ast]
    (-> ast
        (.constraint (either (map (last (.body ast)) .constraint)
                             c/top-type))
        se/state-error)))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location (.cont ast))]
    ;;   (or ;; (= (.line loc) 0)
    ;;       ;; (= (.file loc) core)
    ;;    (and (or (= (.binding ast) 'xtrap)
    ;;             (= (.binding ast) 'flopper))
    ;;         (do
    ;;           (status 'checking-binding _LINE_ loc
    ;;                   lf 'binding (.binding ast)
    ;;                   lflf 'val (.val ast)
    ;;                   lflf 'cont (.cont ast))
    ;;           nothing))))
    (se/state-error (.val ast (Binder (.binding ast) (.val ast)))))

  (type-check [ast old-ast]
    (let [binding (.binding ast)
          val (.val ast)
          val-c (.constraint val)
          cont (.cont ast)
          cont-cs (map cont (fn [ast]
                              (cond (instance? c/ValueConstraint ast)
                                    ast

                                    (.constraint ast))))
          loc (ast/location old-ast)]
      (for [binding-c (map (get-param-types binding)
                           (fn [orig-binding-c]
                             (cata (fn [c]
                                     (cond (= c c/no-tail)
                                           c/top-type
                                           c))
                                   orig-binding-c)))
            _ (se/traverse (all-syms binding) recover-val-type)
            _ (nip-types)
            val (update-constraint val binding-c loc)]
        (let [val-c (.constraint val)]
          ;; (or ;; (= (.line loc) 0)
          ;;     ;; (= (.file loc) core)
          ;;     (and (or (= (.binding ast) 'xtrap)
          ;;              (= (.binding ast) 'flopper))
          ;;          (do
          ;;            (status 'let _LINE_ loc
          ;;                    lflf 'binding (type-name binding) binding
          ;;                    lflf 'binding-c binding-c
          ;;                    lflf 'val val
          ;;                    lflf 'val-c val-c)
          ;;            nothing)))
          (-> ast
              ;; TODO: this assumes that the last expression in 'cont' has a .constraint
              ;; field, but it might also be a constraint
              (.constraint (either (map (last cont) .constraint)
                                   c/top-type))
              (.val val)))))))

(extend-type ast/or-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)
            new-ast (update-constraint (-> ast
                                           (.clause new-clause)
                                           (.cont new-cont))
                                       (c/sum-type [(.constraint new-clause)
                                                    (.constraint new-cont)])
                                       loc)]
        new-ast))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)
            new-ast (update-constraint (-> ast
                                           (.clause new-clause)
                                           (.cont new-cont))
                                       (.constraint new-cont)
                                       loc)]
        new-ast))))

(extend-type ast/cond-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.value ast (PushTypes (.value ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          val (.value ast)
          cont (.cont ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-c (update-constraint clause c/maybe-constraint (ast/location old-ast))]
        (-> ast
            (.clause new-c)
            (.constraint (c/sum-c [(.constraint val)
                                   (.constraint cont)])))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      ;; TODO: remove ones no longer used
                      'ResultConstraint c/ResultConstraintType
                      'InferredInner c/InferredInnerType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? c/TaggedSymbol type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract type-counter)))

(deftype DestructFields [fields loc]
  (assert (instance? c/Location loc))
  (assert (instance? (vector-of c/TaggedSymbol) fields))

  Stringable
  (string-list [_]
    (list "(DestructFields " (to-str fields) " " (str loc) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))
  
  (type-check [ast old-ast]
    (for [arity (get-value-type curr-arity)
          :let [param (c/param (either (get-in arity [.arities c/variadic .arity-id])
                                       (c/tag ""))
                               0)]
          _ (se/traverse fields
                         (fn [fld]
                           (append-value-type fld
                                              (c/type-op c/get-from-op param
                                                         [(c/Field (c/tag (str "." fld) loc))]) 
                                              loc)))]
      '_)))

(def x* (c/tag "#x"))
(def y* (c/tag "#y"))
(def field* (c/tag "#field"))
(def ctxt* (c/tag "#ctxt"))

;; TODO: every place that calls this needs to refactored
(defn constrain-first-param [type-info c]
  (assert (instance? c/ReifiedConstraint type-info))

  (cond (instance? ast/fn-arity-ast c)
        (either (-> (.params c)
                    .fixed
                    first
                    (map (fn [first-param]
                           ;; (print-err 'params _LINE_ (ast/location first-param)
                           ;; first-param)
                           (let [type-info (c/update-sym type-info first-param)
                                 ;; TODO: wut is type-info updated with the first-param
                                 new-bod (comp [type-info] (.body c))]
                             (ProtoArity (c/type-num type-info)
                                         (.body c new-bod))))))

                (do
                  ;; (compilation-error "Prototype implentation for "
                  ;;                    (str "'" (.fn-sym c) "'")
                  ;;                    "must have at least one parameter at"
                  ;;                    (ast/location (.fn-sym c)))
                  (print-err 'BOOOMMMM _LINE_ c)
                  (abort)
                  c))

        (instance? List c)
        (vec c)

        c))

(extend-type ast/rec-type-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)]
      (se/state-error (comp (map (.types ast) (fn [type]
                                                (ast/type-ast (.sym type) c/no-fields [])))
                            [(ast/definition (.sym ast)
                               [(c/SumConstraint
                                 (map (.types ast) (fn [type]
                                                     (.type-symbol c/empty-reified
                                                                   (.sym type))))
                                 (list loc)
                                 c/no-symbol "")])]
                            (.types ast)
                            [(ast/definition (.sym ast)
                               [(c/SumConstraint
                                 (map (.types ast) (fn [type]
                                                     (.type-symbol c/empty-reified
                                                                   (.sym type))))
                                 (list loc)
                                 c/no-symbol "")])])))))

(extend-type ast/quoted-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (reify
                      Type
                      (type-name [_]
                        (str "reified at " _LINE_))

                      Stringable
                      (string-list [_]
                        (list (str "'" (.q-val ast))))

                      Eq
                      (=* [_ y]
                        (= y (.q-val ast)))

                      Container
                      (map [x f]
                        x)

                      (map [x f embed]
                        (embed x))

                      ast/FileLoc
                      (ast/location [_]
                        (ast/location ast))

                      TypeChecker
                      (type-check [_ old-ast]
                        (se/state-error (.constraint ast (-> c/sym-constraint
                                                             (assoc-in [.fields  c/static-value]
                                                                       (c/tag (rest (str ast))))
                                                             (c/update-path (ast/location ast))))))))))

(extend-type ast/main-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                    (set-value-type sym c/top-type)))]
      (.body ast (remove (.body ast) (partial instance? ast/block-comment-ast)))))

  (type-check [ast old-ast]
    (se/state-error ast)))

(def _ (print-err 'creating-parser))
(def t1 (sys/clock_gettime))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(defn type-check-ast [ast]
  (cond (instance? c/Constraints ast)
        (cond (instance? c/SymbolConstraints ast)
              (cond (instance? c/TypeOfConstraint ast)
                    (type-check ast ast)
                    (flat-map (map ast type-check-ast se/state-error)
                              (fn [r]
                                (type-check r ast))))

              (instance? c/ProtoImpls ast)
              (se/state-error ast)
        
              (se/state-error ast))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (= (.file loc) "assertion-tests/closure-param.toc")
              ;;              (do
              ;;                (status 'type-checking _LINE_ loc
              ;;                        lflf 'ast ast
              ;;                        lflf 'new-ast new-ast)
              ;;                nothing))]
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and ;; (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                             lflf 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and ;; (extract flag)
            ;;        (maybe (status 'final-ast _LINE_ loc
            ;;                          lflf final-ast))))
            final-ast))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (cond (= (.fields ast) c/no-fields)
          (let [sym (.sym ast)
                loc (ast/location sym)]
            (se/assoc-in-val [.types sym]
                             (-> (c/ReifiedConstraint (new-type-number sym)
                                                      sym {} {c/contents c/top-type}
                                                      c/fn-constraint
                                                      empty-list c/no-symbol "")
                                 (c/update-path loc))))
          (let [sym (.sym ast)
                loc (ast/location sym)
                type-num (new-type-number sym)
                fields (-> ast .fields .fixed)
                field-count (count fields)]
            (for [_ (push-types)
                  ;; clear previous constraints for the fields
                  _ (se/traverse fields (fn [sym]
                                          (set-value-type sym c/top-type)))

                  ;; then add all the explicit constraints for the fields
                  ;; and collect them in in 'field-cs'
                  _ (-> (.impls ast)
                        (filter (partial instance? c/SymbolConstraints))
                        (se/traverse (fn [field-c]
                                       (cond (some fields (partial = (.sym field-c)))
                                             (type-check-ast field-c)

                                             (compilation-error
                                              (conf-ass _LINE_
                                                        (c/NoValues [field-c
                                                                     (.type-symbol c/empty-reified
                                                                                   (c/tag (str "Field '" (.sym field-c) "' doesn't exist")))])
                                                        loc))))))
                  field-cs (se/traverse fields get-value-type)
                  :let [field-pairs (map (zip-lists fields field-cs)
                                         (fn [[fld-name fld-c]]
                                           [(c/Field (c/tag (str "." fld-name))) fld-c]))
                        fields-map (reduce field-pairs {} conj)
                        new-type-constraint (-> (c/ReifiedConstraint type-num sym
                                                                     fields-map
                                                                     (assoc fields-map
                                                                       c/contents c/top-type)
                                                                     c/fn-constraint
                                                                     empty-list c/no-symbol "")
                                                (c/update-path loc))
                        ctor-sym (c/tag (str "* " sym " constructor at " loc" *") loc)
                        ctor-arity (c/fn-arity
                                    ctor-sym
                                    (c/seq-c (comp [c/top-type] field-cs))
                                    (-> c/empty-reified
                                        (.type-symbol sym)
                                        (.fields (reduce (zip-lists field-pairs
                                                                    (range field-count))
                                                         {}
                                                         (fn [fields-map [[fld fld-c] idx]]
                                                           (assoc fields-map
                                                             fld
                                                             (c/intersect (c/param ctor-sym (inc idx))
                                                                          fld-c)))))
                                        (assoc-in [.fields c/contents] c/top-type)))
                        ctor-type-num (extract type-counter)
                        constructor (c/ReifiedConstraint ctor-type-num ctor-sym
                                                         {} {}
                                                         (.arities c/fn-constraint
                                                                   {(inc field-count) ctor-arity})
                                                         empty-list c/no-symbol "")
                        ctor-apply-id (c/tag (str "apply-" sym "-constructor") loc)
                        ctor-apply-fields (c/seq-c field-cs)
                        ctor-apply (c/fn-arity ctor-apply-id
                                               (c/seq-c [(c/multi [(c/param ctor-apply-id 0)
                                                                   constructor])
                                                         (c/multi [(c/param ctor-apply-id 1)
                                                                   ctor-apply-fields])])
                                               (c/type-op c/apply-op constructor
                                                          (c/multi [(c/param ctor-apply-id 1)
                                                                    ctor-apply-fields])))]
                  _ (se/assoc-in-val [.types ctor-sym] constructor)
                  _ (add-proto-impl ctor-type-num invoke-sym (inc field-count) ctor-arity)
                  _ (add-proto-impl ctor-type-num apply-sym 2 ctor-apply)
                  ;; TODO: need instance? impl constraint
                  _ (se/assoc-in-val [.types sym] new-type-constraint)
                  _ (set-value-type sym constructor)

                  _ (se/traverse (vec fields-map)
                                 (fn [[field fld-c]]
                                   (let [fld-sym (.sym field)
                                         getter-id (c/tag (str sym "-" fld-sym "-getter"))
                                         getter-param (c/param getter-id 0)
                                         setter-id (c/tag (str sym "-" fld-sym "-setter"))
                                         setter-param-0 (c/param setter-id 0)
                                         setter-param-1 (c/param setter-id 1)]
                                     (for [;; this 'get-value-type' creates the getter/setter
                                           ;; entry if needed
                                           ;; TODO: how long does it take to add each getter/setter
                                           _ (get-value-type fld-sym)
                                           _ (add-proto-impl type-num fld-sym 1
                                                             (c/fn-arity
                                                              getter-id
                                                              (c/seq-c [(c/multi [new-type-constraint
                                                                                  getter-param])])
                                                              (-> (c/type-op c/get-from-op getter-param
                                                                             [field])
                                                                  (c/intersect fld-c))))
                                           _ (add-proto-impl type-num fld-sym 2
                                                             (c/fn-arity
                                                              setter-id
                                                              (c/seq-c [(c/multi [new-type-constraint
                                                                                  setter-param-0])
                                                                        (c/multi [setter-param-1
                                                                                  fld-c])])
                                                              (c/type-op c/set-to-op setter-param-0
                                                                         [[field] setter-param-1])))]
                                       '_))))]
              (let [impls (elgot (fn [ast]
                                   (cond (instance? HashMap ast)
                                         (RecurseWith (vec (vals ast)))

                                         (instance? ast/fn-arity-ast ast)
                                         (RecurseFinal
                                          (constrain-first-param
                                           new-type-constraint
                                           (.body ast (comp [(DestructFields fields loc)]
                                                            (.body ast)))))

                                         (RecurseWith ast)))
                                 (fn [v]
                                   (cond (instance? Vector v)
                                         (reduce v []
                                                 (fn [new-v inner]
                                                   (cond (instance? Vector inner)
                                                         (comp new-v inner)
                                                         (conj new-v inner))))

                                         v))
                                 (.impls ast))
                    ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
                    ;; and parameter, respectively
                    ]
                [(reduce impls [[] []] (fn [[invoke-fns others] pa]
                                         (cond (flat-map (get-in pa [.arity .fn-sym])
                                                         (partial = invoke-sym))
                                               [(conj invoke-fns pa) others]
                                               [invoke-fns (conj others pa)])))
                 (reify
                   Type
                   (type-name [_]
                     (str "reified at " (c/Location _FILE_ _LINE_)))

                   Container
                   (map [y f embed]
                     (embed y))

                   TypeChecker
                   (pre-check [x]
                     (se/state-error x))

                   (type-check [_ _]
                     (for [_ (pop-types)
                           _ (push-types)
                           _ (comp (se/get-in-val [.value-types 0 get-symb .impl-fns type-num
                                                   .arities 2])
                                   (add-proto-impl type-num (c/tag get-symb loc) 2
                                                   (let [get-id (c/tag (str sym "_get") loc)]
                                                     (c/fn-arity
                                                      get-id
                                                      (c/seq-c [(c/multi [new-type-constraint
                                                                          (c/param get-id 0)])
                                                                (c/param get-id 1)])
                                                      (c/MaybeConstraint
                                                       (c/type-op c/get-from-op (c/param get-id 0)
                                                                  [(c/param get-id 1)]))))))
                           _ (comp (se/get-in-val [.value-types 0 assoc-sym .impl-fns type-num
                                                   .arities 3])
                                   (add-proto-impl type-num (c/tag assoc-sym loc) 3
                                                   (let [get-id (c/tag (str sym "_get") loc)]
                                                     (c/fn-arity
                                                      get-id
                                                      (c/seq-c [(c/multi [new-type-constraint
                                                                          (c/param get-id 0)])
                                                                (c/param get-id 1)
                                                                (c/param get-id 2)])
                                                      (c/type-op c/set-to-op (c/param get-id 0)
                                                                 [[(c/param get-id 1)]
                                                                  (c/param get-id 2)])))))
                           _ (set-value-type sym constructor)]
                       (ast/block-comment-ast [] c/no-loc c/top-type))))

                 ;; (reify
                 ;;   Container
                 ;;   (map [y f embed]
                 ;;     (embed y))

                 ;;   TypeChecker
                 ;;   (pre-check [ast]
                 ;;  report-type-stack
                 ;;     (for [ft (se/get-val .value-types)
                 ;;           mby (get-value-type maybe-sym)]
                 ;;       (do
                 ;;         (status 'vts _LINE_ sym (count ft)
                 ;;                 lflf 'maybe mby)
                 ;;         (ast/block-comment-ast [] c/no-loc c/top-type)))))
                 ]))))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (grmr/any (reify
                Type
                (type-name [_]
                  (str "Reified at: " _FILE_ ": " _LINE_))

                Container
                (map [x f]
                  x)

                (map [x f embed]
                  (embed x))

                rd/Parser
                (rd/parse [p s]
                  (either (for [result-prom (get-in s [.values 'result-prom])
                                :when (delivered result-prom)]
                            (extract result-prom))
                          rd/parser-fail)))
              (apply-to (fn [type-checker result-prom ast]
                          ;; (status 'ast _LINE_ ast)
                          (send type-checker update-context
                                (flat-map se-nop
                                          (fn [_]
                                            ;; (status 'checking _LINE_ (ast/location ast))
                                            (se/try
                                              (comp (type-check-ast ast)
                                                    (compilation-error "Could not type check code for expression at "
                                                                       lflf ast
                                                                       (ast/location ast)))
                                              (fn [err]
                                                (deliver result-prom err)
                                                (se/throw (.val err)))))))
                          ast)
                        (grmr/get-value 'type-checker)
                        (grmr/get-value 'result-prom)
                        rdr/top-level)))
   ;; (grmr/all
    
   ;;  (apply-to (fn [file-name]
   ;;              (status 'parsing-time file-name (div (sys/time-delta (extract core-start)
   ;;                                                                   (sys/clock_gettime))
   ;;                                                   1000))
   ;;              file-name)
   ;;            (grmr/get-value 'file-name)))
   ))
(def _ (print-err 'parser-created (div (sys/time-delta t1 (sys/clock_gettime))
                                       1000)))

(defn compile-module [file-name root-dir proj-dir module-index core-mod]
  ;; kick off a thread to load and check the module
  (status "Loading" file-name)
  ;; try to open file for reading
  (either (map (fio/file-in (c/file-name file-name))
               (fn [file-in]
                 ;; if opened, parse and type check it
                 (let [ast-checker (agent (new-module file-name module-index core-mod))
                       loading (promise)
                       parse-result (parse-forms {'file-name file-name
                                                  'root-directory root-dir
                                                  'project-directory proj-dir
                                                  'line-number 1
                                                  'type-checker ast-checker
                                                  'result-prom loading}
                                                 (lazy-list file-in))]
                   (cond (instance? rd/ParserError parse-result)
                         (do
                           (send output (fn [_]
                                            (print-err (.msg parse-result))
                                            (abort)))
                           (wait-for-output))

                         ;; after all expressions have been checked,
                         ;; deliver the resulting Module
                         (send ast-checker (partial deliver loading)))
                   loading)))

          ;; or tell everyone it couldn't be
          (do
            (send output (fn [_]
                           (print-err "Could not find/open " file-name)
                           (abort)))
            (wait-for-output))))

(extend-type ast/IsType
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (either (map (= (.ast ast) '_)
                         (fn [_]
                           (status "Type at:" (ast/location (.ast ast))
                                   (.expected ast))
                           se-nop))
                    (flat-map (se/try
                                (type-check-ast (.ast ast))
                                (fn [err]
                                  (status (.val err))
                                  (se/state-error (.constraint (.ast ast) c/bottom-type))))
                              (fn [c]
                                (either (map (= (c/trim (.constraint c)) (.expected ast))
                                             se/state-error)
                                        (compilation-error "Type Error:" (ast/location (.ast ast))
                                                           lf 'ast (.ast ast)
                                                           lflf 'expected (.expected ast)
                                                           lflf 'actual (either (get c .constraint)
                                                                                  c))))))
          _ (pop-types)]
      (ast/block-comment-ast [] c/no-loc c/top-type))))

(extend-type ast/GetImpl
  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (cond (= c/no-symbol (.type-sym ast))
          (se/state-error (.constraint ast (-> ast .impl-sym .constraint .default-impl)))

          (flat-map (get-type-info (.type-sym ast))
                    (fn [c]
                      (let [type-num (c/type-num c)]
                        (either (map (get-in ast [.impl-sym .constraint .impl-fns type-num])
                                     (fn [impl-c]
                                       (se/state-error (.constraint ast impl-c))))
                                (compilation-error "Could not find impl for" (str "'" (.type-sym ast)
                                                                                  "' (" type-num ")")
                                                   "at" (ast/location (.type-sym ast))))))))))

(main [params]
  (deliver core-start (sys/clock_gettime))
  (let [core-mod (extract (compile-module core toccata-dir toccata-dir 0 'no-core))]
    (cond (instance? Module core-mod)
          (status "Loaded Core")

          (do
            (either (map (instance? se/Error core-mod)
                         (fn [err]
                           (status (.val err))
                           (wait-for-output)
                           (abort)))
                    (do
                      (status "Could not load Core")
                      (wait-for-output)
                      (abort)))))
    (send modules (fn [_]
                    {core core-mod}))
    (status 'time-for-core (div (sys/time-delta (extract core-start) (sys/clock_gettime)) 1000))
    ;; (let [core-types (extract (compile-module "core-types.toc" toccata-dir toccata-dir 1 core-mod))]
    ;;   (cond (instance? Module core-types)
    ;;         (status "Loaded core-types")

    ;;         (do
    ;;           (either (map (instance? se/Error core-types)
    ;;                        (fn [err]
    ;;                          (status (.val err))
    ;;                          (wait-for-output)
    ;;                          (abort)))
    ;;                   (do
    ;;                     (status "Could not load core-types")
    ;;                     (wait-for-output)
    ;;                     (abort))))))
    (-> (rest params)
        ;; TODO: empty-defn causes mem leaks
        ;; (remove (partial = "assertion-tests/empty-defn.toc"))
        (map (fn [file-name]
               (future
                 (fn []
                   (map (sys/file-directory file-name)
                        (fn [root-dir]
                          ;; (send modules (fn [_]
                          ;;                 {core core-mod}))
                          (let [
                                ;; _ (send output (fn [_]
                                ;;                  (fio/file-out (str file-name ".err"))))
                                core-result (compile-module file-name toccata-dir toccata-dir 1
                                                            core-mod)
                                core-result (either (map (instance? Promise core-result) extract)
                                                    core-result)]
                            (cond (instance? Module core-result)
                                  (status 'Loaded file-name)

                                  (either (map (instance? se/Error core-result)
                                               (fn [err]
                                                 (status (.val err))))
                                          (status "Could not load Toccata file:"
                                                  file-name))))))))))
        (map extract)
        ))

  (wait-for-output))
