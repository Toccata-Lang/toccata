
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d0ce206"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "90d5ffb"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "d16a55a"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
;; (add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
;;                            "free.toc"
;;                            :sha "5c353f2"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(def output (agent (maybe nothing)))

(def core-start (promise))
;; (def max-time (agent 0))
;; (def start-time (agent 0))

(defn status [& msg]
  (send output (fn [out-file?]
                 ;; (assert (instance? Maybe out-file?))

                 ;; (and out-file?
                 ;;      (maybe (apply print-err msg)))

                 (apply print-err msg)
                 ;; (map out-file?
                 ;;      (fn [out-file]
                 ;;        (fio/write out-file (str (to-str (interpose msg " ")) "\n"))
                 ;;        out-file))
                 )))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(def core (c/ToccataCore path-to-core))

(def lflf "\n\n")

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(def Function-sym (ast/tag 'Function))
(def invoke-sym (ast/tag 'invoke))
(def Type-sym (ast/tag 'Type))
(def type-name-sym (ast/tag 'type-name))
(def has-field-sym (ast/tag 'has-field))
(def Eq-sym (ast/tag 'Eq))
(def =*-sym (ast/tag '=*))
(def get-symb (ast/tag 'get))
(def maybe-sym (ast/tag 'maybe))
(def assoc-sym (ast/tag 'assoc))
(def sha1-sym (ast/tag 'sha1))
(def sha1-update-sym (ast/tag 'sha1-update))
(def sha1-init-sym (ast/tag 'sha1-init))
(def sha1-finalize-sym (ast/tag 'sha1-finalize))
(def sha1-update-type-sym (ast/tag 'sha1-update-type))
(def default-type-args-sym (ast/tag 'default-type-args))
(def identical-sym (ast/tag 'identical))
(def nothing-sym (ast/tag 'nothing))
(def get-type-sym (ast/tag 'default-get-type))
(def Associative-sym (ast/tag 'Associative))
(def Hashable-sym (ast/tag 'Hashable))
(def instance?-sym (ast/tag 'instance?))
(def Container-sym (ast/tag 'Container))
(def apply-sym (ast/tag 'apply))
(def Stringable-sym (ast/tag 'Stringable))
(def string-list-sym (ast/tag 'string-list))
(def list-sym (ast/tag 'list))

(deftype ProtoArity [type-num arity]
  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (partial .arity x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location arity)))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol)
                             Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (let [core-prom (promise)]
    ;; (send modules (fn [mods]
    ;;                 (map (get mods core)
    ;;                      (partial deliver core-prom))
    ;;                 mods))
    (Module file-name module-index {}
            (cond (= module-index 0)
                  {}
                  {core core-mod})
            c/core-type-constraints
            (list {'empty-list (c/update-sym c/empty-list-constraint
                                             (c/tag 'empty-list))
                   'empty-vector (c/update-sym c/empty-vect-constraint
                                               (c/tag 'empty-vector))
                   'int-max (assoc-in c/int-constraint
                                      [.fields c/static-value] int-max)
                   'int-min (assoc-in c/int-constraint
                                      [.fields c/static-value] int-min)
                   'nothing (assoc-in c/maybe-constraint
                                      [.fields c/contents]
                                      c/no-contents)}))))

(def type-counter (int-generator c/TypeCount))

(defn report-type-stack [& msg]
  (map (se/get-val .value-types)
       (fn [vts]
         (status 'type-depth (to-str (interpose msg " "))
                 (count vts)))))

(defn get-types []
  (se/get-in-val [.value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.value-types])
            (fn [types-list]
              (se/assoc-in-val [.value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn add-getter [sym types-list]
  (assert (instance? c/TaggedSymbol sym))
  (assert (instance? (list-of HashMap) types-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [field-sym (c/Field sym)
        required-field (-> c/empty-reified
                           (.fields {field-sym c/top-type})
                           (.type-symbol (c/tag (str "field '" (rest (str sym)) "' required"))))
        getter-sym (c/tag (str sym "_getter"))
        setter-sym (c/tag (str sym "_setter"))
        arities {1 (c/fn-arity getter-sym
                               (c/ListConstraint [required-field]
                                                 c/no-tail empty-list c/no-symbol "")
                               c/top-type)
                 2 (c/fn-arity setter-sym
                               (c/ListConstraint [required-field c/top-type]
                                                 c/no-tail empty-list c/no-symbol "")
                               c/top-type)}
        getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? types-list)
          (list {sym getter})

          (get-in types-list [0 sym])
          types-list

          (map types-list (fn [value-types]
                            (assoc value-types sym getter))))))

(defn get-core-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))

  (se/new-se (fn [s]
               (either (or (and (= 0 (.index s))
                                (or (map (get-in s [.value-types 0 sym])
                                         (fn [val-type]
                                           [val-type s]))
                                    (for [first-char (first (str sym))
                                          _ (= first-char ".")
                                          new-s (update-in s [.value-types]
                                                           (fn [val-types]
                                                             (add-getter sym val-types)))
                                          val-type (get-in new-s [.value-types 0 sym])]
                                      [val-type new-s])
                                    (maybe se/Failure)))
                           (map (get-in s [.namespaces core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           (for [first-char (first (str sym))
                                 _ (= first-char ".")
                                 new-s (update-in s [.namespaces core .value-types]
                                                  (fn [val-types]
                                                    (add-getter sym val-types)))
                                 val-type (get-in new-s [.namespaces core .value-types 0 sym])]
                             (do
                               ;; (send modules
                               ;;       (fn [mods]
                               ;;         (assert-result r (instance? HashMap r))
                               ;;         (either (or (get-in mods [core .value-types 0 sym])
                               ;;                     (update-in mods [core .value-types]
                               ;;                                (fn [val-types]
                               ;;                                  (add-getter sym val-types))))
                               ;;                 mods)))
                               [val-type new-s]))
                           ;; last ditch effort
                           ;; (let [core-prom (promise)]
                           ;;   ;; (status 'sending sym _LINE_)
                           ;;   (send modules (fn [mods]
                           ;;                   (assert-result r (instance? HashMap r))
                           ;;                   (either (or (map (get-in mods [core .value-types 0 sym])
                           ;;                                    (fn [val-type]
                           ;;                                      (deliver core-prom (maybe val-type))
                           ;;                                      mods))
                           ;;                               (for [first-char (first (str sym))
                           ;;                                     _ (= first-char ".")
                           ;;                                     new-mods (update-in mods [core .value-types]
                           ;;                                                         (fn [val-types]
                           ;;                                                           (add-getter sym val-types)))
                           ;;                                     val-type (get-in new-mods [core .value-types 0 sym])]
                           ;;                                 (do
                           ;;                                   (deliver core-prom (maybe val-type))
                           ;;                                   new-mods)))
                           ;;                           (do
                           ;;                             (deliver core-prom nothing)
                           ;;                             mods))))
                           ;;   (map (extract core-prom)
                           ;;        (fn [expr]
                           ;;          [expr s])))
                           )
                       se/Failure))))

(defn get-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (= sym c/no-symbol)
        c/top-type

        (let [loc (ast/location sym)]
          ;; TODO: this does not look up namespaced symbols
          (comp (se/get-in-val [.value-types 0 sym])
                (get-core-value-type sym)
                (compilation-error "Could not find type constraint for" (str "'" sym "'") "at" loc)))))

(defn set-value-type [sym constraint]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? c/Constraints constraint))

  (cond (= c/no-symbol sym)
        (se/state-error constraint)

        (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ constraint)
          se-nop)

        (map (se/update-in-val [.value-types]
                               (fn [types-list]
                                 (either (map (first types-list)
                                              (fn [value-types]
                                                (-> value-types
                                                    (dissoc sym)
                                                    (assoc sym constraint)
                                                    (cons (rest types-list)))))
                                         (list {sym constraint}))))
             (fn [_]
               constraint))))

(defn append-value-type [sym constraint loc]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? c/Constraints constraint))

  (cond (= sym c/no-symbol)
        (se/state-error constraint)

        (= (str sym) "")
        (map se-nop (fn [_]
                      (status "Bad call to append-value-type" _LINE_ loc sym "\n" constraint)
                      '_))

        (= constraint c/top-type)
        (se/try
          (get-value-type sym)
          (fn [_]
            (se/state-error c/top-type)))

        (= constraint c/bottom-type)
        (compilation-error 'site _LINE_ loc 'appending sym
                           lflf 'constraint constraint
                           lflf (conf-ass _LINE_ constraint loc))

        (flat-map (se/try
                    (get-value-type sym)
                    (fn [_]
                      (se/state-error c/top-type)))
                  (fn [curr-const]
                    (cond (= curr-const c/top-type)
                          (set-value-type sym (c/update-path constraint loc))

                          (let [new-const (c/intersect (c/update-path constraint loc)
                                                       curr-const)]
                            ;; (let [loc (ast/location sym)]
                            ;;   (or ;; (= (.file loc) core)
                            ;;       ;; (= (.line loc) 0)
                            ;;       (do
                            ;;         (status 'appending _LINE_ loc (str "\"" sym "\"")
                            ;;                 "\n" 'constraint constraint
                            ;;                 lflf 'curr curr-const
                            ;;                 lflf 'untrimmed (c/intersect curr-const constraint)
                            ;;                 lflf 'new-const new-const)
                            ;;         nothing)))

                            (cond (= new-const c/bottom-type)
                                  (compilation-error ;; 'site _LINE_ loc 'appending sym
                                                     ;; "\n" 'curr curr-const
                                                     ;; lflf 'constraint constraint
                                                     ;; lflf 'new-const new-const
                                                     ;; lflf
                                                     (conf-ass _LINE_ new-const loc))

                                  (instance? c/ProtoImpls curr-const)
                                  se-nop

                                  (set-value-type sym (c/update-path new-const loc)))))))))

(defn remove-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))
  (se/update-in-val [.value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types sym)
                                           (rest types-list))))
                              types-list))))

(defn add-impl [proto-impls type-num arg-count arity-c loc]
  (instance? c/ProtoImpls proto-impls)

  (either (map (get-in proto-impls [.default-impl .arities arg-count])
               (fn [dflt-arity]
                 (let [new-params (-> (.param-consts dflt-arity)
                                      .items
                                      count
                                      range
                                      vec
                                      (map (fn [n]
                                             (c/ParamConstraint (.arity-id arity-c) n
                                                                empty-list c/no-symbol ""))))
                       dflt-arity (cond (= (str (.arity-id dflt-arity)) "")
                                           dflt-arity

                                           (let [def-ar (c/reify-type-constraint dflt-arity
                                                                                 (.arity-id dflt-arity)
                                                                                 new-params loc)]
                                             (cond (= c/bottom-type def-ar)
                                                   (do
                                                     (print-err 'site _LINE_ loc type-num arg-count
                                                                "\n\n" 'dflt-arity dflt-arity
                                                                "\n\n" 'params new-params
                                                                "\n\n" (conf-ass _LINE_ def-ar loc))
                                                     (abort))
                                                   def-ar)))
                       new-arity-c (c/intersect arity-c dflt-arity)]
                   ;; (cond (and (= c/ListType type-num)
                   ;;            (= (.fn-sym proto-impls) 'filter))
                   ;;       (status 'proto-result _LINE_ loc
                   ;;               "\n\n" 'def dflt-arity
                   ;;               "\n\n" 'arity arity-c
                   ;;               "\n\n" 'new new-arity-c)

                   ;;       '_)
                   (cond (= new-arity-c c/bottom-type)
                         (compilation-error ;; 'impl _LINE_
                                            ;; "\n" 'def dflt-arity
                                            ;; lflf 'arity arity-c
                                            ;; lflf 'new new-arity-c
                                            ;; lflf
                                            (conf-ass _LINE_ new-arity-c loc))

                         ;; happy path
                         (either (update-in proto-impls [.impl-fns type-num]
                                            (fn [fn-c]
                                              (assert (instance? c/FnConstraint fn-c))

                                              (assoc-in fn-c [.arities arg-count] new-arity-c)))
                                 (assoc-in proto-impls [.impl-fns type-num]
                                           (.arities c/fn-constraint {arg-count new-arity-c})))))))
          (compilation-error "No prototype for" (str "'" (.fn-sym proto-impls) "'") "with" (str arg-count)
                             "arguments at" loc)))

(defn add-ns-impl [ns sym type-num arg-count arity-c loc]
  (fn [mods]
    (assert (instance? HashMap mods))
    (assert-result r (instance? HashMap r))

    (either (for [val-types-list (get-in mods [ns .value-types])
                  val-types (first val-types-list)
                  proto-impls (get val-types sym)]
              (let [new-proto (add-impl proto-impls type-num
                                        arg-count arity-c loc)
                    val-types-list (map val-types-list
                                        (fn [m]
                                          (assoc m sym new-proto)))]
                (cond (instance? c/ProtoImpls new-proto)
                      (assoc-in mods [ns .value-types]
                                val-types-list)

                      ;; add-impl might return a compilation error
                      (do
                        (status (.val new-proto))
                        (wait-for-output)
                        (abort)))))
            mods)))

(defn add-proto-impl [type-num fn-sym arg-count arity-c]
  (assert (instance? Integer type-num))
  (assert (instance? c/fn-arity arity-c))

  (let [loc (ast/location fn-sym)]
    (cond (> 1 type-num)
          (compilation-error "Invalide prototype implementation type-num for"
                             (str "'" fn-sym "'") "at" loc)

          (= (str fn-sym) "")
          (do
            (print-err 'compiler-error _LINE_ (str "'" fn-sym "'") (ast/location fn-sym)
                       "\n\n" arity-c)
            (abort))

          (comp (flat-map (se/get-in-val [.value-types 0 fn-sym])
                          (fn [proto-impls]
                            (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                                  (compilation-error "An implementation for" (str "'" fn-sym "'")
                                                     "already exists\n"
                                                     "Redefinition attempted at" loc)
                                  (let [new-proto (add-impl proto-impls type-num
                                                            arg-count arity-c loc)]
                                    (cond (instance? c/ProtoImpls new-proto)
                                          (for [vts (se/get-val .value-types)
                                                _ (se/set-val .value-types
                                                              (map vts (fn [m]
                                                                         (assoc m fn-sym new-proto))))]
                                            new-proto)

                                          ;; add-impl might return a compilation error
                                          new-proto)))))
                ;; TODO: test for namespaced fn-sym
                (let [ns core]
                  (flat-map (se/get-in-val [.namespaces core .value-types 0 fn-sym])
                            (fn [proto-impls]
                              (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                                    (compilation-error "An implementation for" (str "'" fn-sym "'")
                                                       "already exists\n"
                                                       "Redefinition attempted at" loc)
                                    (let [new-proto (add-impl proto-impls type-num
                                                              arg-count arity-c loc)]
                                      (cond (instance? c/ProtoImpls new-proto)
                                            (for [vts (se/get-in-val [.namespaces core .value-types])
                                                  :let [new-vts (map vts
                                                                     (fn [m]
                                                                       (assoc m fn-sym new-proto)))]
                                                  _ (se/assoc-in-val [.namespaces core .value-types]
                                                                     new-vts)]
                                              (do
                                                ;; (send modules (add-ns-impl fn-sym core type-num
                                                ;;                            arg-count arity-c loc))
                                                new-proto))
                                            new-proto))))))
                (for [nss (se/get-in-val [.namespaces core .value-types 0])
                      _ (se-debug 'ns-keys (keys nss)
                                  lflf 'untagged (map (get nss fn-sym)
                                                      (fn [p]
                                                        (.impl-fns p {})))
                                  lflf 'tagged (map (get nss fn-sym)
                                                    (fn [p]
                                                      (.impl-fns p {}))))
                      _ (compilation-error 'wth _LINE_ fn-sym loc)]
                  '_)))))

(defn get-type-info [type-sym loc]
  ;; TODO: needs to handled namespaced type-sym
  ;; (or ;; (= (.file loc) core)
  ;;     ;; (= (.line loc) 0)
  ;;  (and ( = type-sym 'BitmapIndexedNode)
  ;;       (do
  ;;         (status 'get-type _LINE_ loc type-sym)
  ;;         (maybe '_))))
  (comp (se/get-in-val [.types type-sym])
        (se/get-in-val [.namespaces core .types type-sym])
        ;; (flat-map se-nop
        ;;           (fn [_]
        ;;             ;; Look in the core module
        ;;             (let [core-prom (promise)]
        ;;               (send modules (fn [mods]
        ;;                               ;; (or ;; (= (.file loc) core)
        ;;                               ;;  ;; (= (.line loc) 0)
        ;;                               ;;  (and ( = type-sym 'BitmapIndexedNode)
        ;;                               ;;       (do
        ;;                               ;;         (status 'get-type _LINE_ loc type-sym "\n"
        ;;                               ;;                 (get-in mods [core .types (ast/untag type-sym)]))
        ;;                               ;;         (maybe '_))))
        ;;                               (either (or (for [core-mod (get mods core)
        ;;                                                 _ (instance? Promise core-mod)]
        ;;                                             (deliver core-prom se/zero-se))
        ;;                                           (map (get-in mods [core .types (ast/untag type-sym)])
        ;;                                                (fn [type-inf]
        ;;                                                  (deliver core-prom (se/state-error type-inf)))))
        ;;                                       (deliver core-prom se/zero-se))
        ;;                               mods))
        ;;               (extract core-prom))))
        (compilation-error "No type named" (str "'" type-sym "'")
                           "was found. Used at" loc)))

(defprotocol TypeChecker
  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       "\n" (type-name ast) ast
                       lflf constraint))

  (recover-val-type [x]
    (assert-result r (instance? se/StateError r))

    (se/state-error (RecurseFinal x)))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    ;; TODO: put back in when done
    ;; (se/state-error ast)
    )

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       "\n" (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(def ConstrainedAST (any-of ast/call-ast
                            ;; ast/params-ast
                            ast/fn-ast
                            ;; ast/fn-arity-ast
                            ;; ast/let-ast
                            ast/or-ast
                            ast/and-ast
                            ;; ast/either-ast
                            ast/string-ast
                            ast/integer-ast
                            ;; ast/cond-ast
                            ast/binding-ast
                            ast/quoted-ast
                            ;; c/TaggedSymbol
                            ;; ast/prototype-ast
                            ;; ast/reify-ast
                            ast/block-comment-ast))

(extend-type Opaque
  Eq
  (=* [x y]
    nothing))

(extend-type ConstrainedAST
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error ;; 'site _LINE_ loc
                                        ;; "\n" 'ast ast
                                        ;; lflf 'ast-constraint (.constraint ast)
                                        ;; lflf 'constraint constraint
                                        ;; lflf 'new-c new-c
                                        ;; lflf
                                        (conf-ass _LINE_ new-c loc))))
              (se/state-error (.constraint ast (c/update-path new-c loc)))))))

(defn all-syms [params]
  (assert (instance? ast/ParamType params))

  (cata all-symbols params))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (apo recover-val-type params se/state-error))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (map (cata param-types params se/state-error)
       (fn [c]
         (c/intersect c c/list-constraint))))

;; TODO: remove when done
(def DefaultPreCheck (any-of Vector
                             ProtoArity
                             c/AllValues
                             c/NoSymbol
                             c/ReifiedConstraint
                             c/SumConstraint
                             c/VectorConstraint
                             c/ListConstraint
                             c/CollectionOf
                             c/TypeOfConstraint
                             c/FnConstraint
                             c/TypeOp
                             c/MultiConstraint
                             c/fn-arity
                             c/Field
                             c/NoTail
                             c/ParamConstraint
                             c/Contents
                             c/StaticValue
                             c/Min
                             c/Max
                             ast/string-ast
                             ast/integer-ast
                             ast/call-ast
                             ast/inline-ast
                             c/TaggedSymbol
                             ast/protocol-ast
                             ast/params-ast))

;; TODO: remove when done
(def DefaultTypeCheck (any-of Vector
                              c/AllValues
                              c/NoSymbol
                              c/NoTail
                              c/Contents
                              c/StaticValue
                              c/Min
                              c/Max
                              c/fn-arity
                              ast/protocol-ast
                              ast/inline-ast
                              ast/block-comment-ast))

;; TODO: remove when done
(extend-type DefaultPreCheck
  TypeChecker
  (pre-check [ast]
    (se/state-error ast)))

;; TODO: remove when done
(extend-type DefaultTypeCheck
  TypeChecker
  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast)))

(def DefaultConst (any-of c/AllValues
                          c/ParamConstraint
                          c/FnConstraint
                          c/ReifiedConstraint
                          c/MultiConstraint
                          c/CollectionOf
                          c/ListConstraint
                          c/VectorConstraint
                          c/SumConstraint
                          c/NoSymbol))

(extend-type DefaultConst ;; c/Constraints
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(def DefaultSymConst (any-of c/ReifiedConstraint
                             c/CollectionOf
                             c/ListConstraint
                             c/VectorConstraint
                             c/SumConstraint
                             c/MultiConstraint
                             c/TypeOp
                             c/FnConstraint))

(extend-type DefaultSymConst ;; c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (append-value-type (ast/tag (.sym c) loc) c loc))))

(extend-type c/NoSymbol
  TypeChecker
  (update-constraint [x _ _]
    (se/state-error x)))

(extend-type c/NoValues
  TypeChecker
  (type-check [c old-c]
    (compilation-error (conf-ass _LINE_ c (ast/location c)))))

(extend-type c/Field
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c))

  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/ReifiedConstraint
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (flat-map (cond (= c/UnknownType (c/type-num c))
                      (get-type-info (c/type-sym c) loc)
                      (se/state-error c))
                (fn [type-c]
                  (append-value-type (ast/tag (.sym c) loc)
                                     type-c loc))))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    ;; TODO: restrict use to fn params only
    (flat-map (get-value-type (.param-sym old-c))
              (fn [type-c]
                (let [loc (ast/location c)]
                  (append-value-type (ast/tag (.sym c) loc) type-c loc))))))

(extend-type ProtoArity
  TypeChecker
  (type-check [ast old-ast]
    (for [_ (add-proto-impl (.type-num ast)
                            (-> old-ast .arity .fn-sym)
                            (-> old-ast .arity .params .fixed count)
                            (-> ast .arity .constraint))]
      ast)))

(extend-type ast/reify-ast
  TypeChecker
  (pre-check [ast]
    (let [reified-type-num (either (instance? Integer (.type-num ast))
                                   (extract type-counter))]
      (flat-map (push-types)
                (fn [_]
                  (-> ast
                      (.type-num reified-type-num)
                      (.impls (map-vals (.impls ast)
                                        (fn [impl-fns]
                                          (map-vals impl-fns
                                                    (fn [arities]
                                                      (map arities
                                                           (partial ProtoArity reified-type-num)))))))
                      se/state-error)))))

  (type-check [ast old-ast]
    (let [invoke-arities (either (map (get-in ast [.impls Function-sym invoke-sym])
                                      (fn [arities]
                                        (reduce arities {}
                                                (fn [m arity]
                                                  (assoc m (count (.fixed (.params (.arity arity))))
                                                         (.constraint (.arity arity)))))))
                                 {})
          new-c (c/ReifiedConstraint (.type-num ast) (c/tag (str "reified value at "
                                                                  (ast/location ast)))
                                     {} {}
                                     (.arities c/fn-constraint invoke-arities)
                                     empty-list c/no-symbol "")]
      (flat-map (pop-types)
                (fn [_]
                  (-> ast
                      (.impls (map-vals (.impls ast)
                                        (fn [impl-fns]
                                          (map-vals impl-fns
                                                    (fn [arities]
                                                      (map arities .arity))))))
                      (.constraint new-c)
                      se/state-error))))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          fixed-params (-> ast .params .fixed)
          arg-count (count fixed-params)
          all-param-syms (remove (all-syms (.params ast))
                                 (partial = (ast/tag '_)))]
      (cond (< (count (set all-param-syms)) (count all-param-syms))
            (compilation-error "Duplicate parameter names in prototype at" loc)

            (for [_ (comp (se/get-in-val [.value-types 0 (.fn-name ast) .default-impl])
                          (set-value-type (.fn-name ast)
                                          (c/ProtoImpls (.fn-name ast)
                                                      (.arities c/fn-constraint {}) {})))
                  _ (push-types)
                  _ (set-value-type ast/result-sym c/top-type)
                  ;; :let [_ (or ;; (= (.line loc) 0)
                  ;;             ;; (= (.file loc) core)
                  ;;          (and (= (.fn-name ast) 'first)
                  ;;               (do
                  ;;                 (send output (fn [_] (maybe nothing)))
                  ;;                 (status 'pre-prototype _LINE_ (.fn-name ast) (ast/location ast)
                  ;;                         "\n" 'body (.default-body ast))
                  ;;                 nothing)))]
                  _ (se/traverse all-param-syms
                                 (fn [sym]
                                   (set-value-type sym c/top-type)))
                  _ (se/traverse (zip-lists fixed-params (range arg-count))
                                 (fn [[sym index]]
                                   (cond (instance? ast/params-ast sym)
                                         ;; TODO: this probably needs expanding
                                         se-nop

                                         (= sym '_)
                                         (set-value-type sym c/top-type) 

                                         (append-value-type sym
                                                            (c/ParamConstraint (.fn-name ast) index
                                                                               empty-list sym "")
                                                            loc))))]
              ast))))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))]
      (for [pts (get-param-types (.params old-ast))
            result-c (se/try
                       (get-value-type ast/result-sym)
                       (fn [_]
                         (se/state-error c/top-type)))
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) core)
            ;;          (and (= (.fn-name ast) 'first)
            ;;               (do
            ;;                 (status 'check-prototype _LINE_ (.fn-name ast) (ast/location ast)
            ;;                         "\n" ast
            ;;                         lflf 'pts pts
            ;;                         lflf 'result result-c)
            ;;                 (send output (fn [_] nothing))
            ;;                 nothing)))]
            :let [pts (.tail-c pts c/no-tail)
                  impl-c (c/fn-arity (.fn-name old-ast) pts result-c)]
            _ (remove-value-type ast/result-sym)
            _ (recover-types (.params old-ast))
            _ (nip-types)
            _ (se/update-in-val [.value-types]
                                (fn [types-list]
                                  (let [sym (.fn-name ast)]
                                    (either (map (first types-list)
                                                 (fn [value-types]
                                                   (cons (assoc-in value-types
                                                                   [sym .default-impl .arities arg-count]
                                                                   impl-c)
                                                         (rest types-list))))
                                            (list {sym (c/ProtoImpls sym
                                                                   (.arities c/fn-constraint {arg-count impl-c})
                                                                   {})})))))]
        (.constraint ast impl-c)))))

(extend-type ast/call-ast
  TypeChecker
  (type-check [ast old-ast]
    (either (and (= (.call-target old-ast) 'show-type)
                 (map (first (.args ast))
                      (fn [arg]
                        (status 'showing (ast/location (.call-target old-ast)) arg
                                "\n" (c/trim (.constraint arg)))
                        (se/state-error arg))))

          (let [loc (ast/location (.call-target old-ast))
                target-c (.constraint (.call-target ast))
                arg-cs (map (.args ast) .constraint)
                arg-count (count arg-cs)]
            ;; (for [_ (and (instance? c/ProtoImpls target-c)
            ;;              (< 1968 (.line loc)))
            ;;       disp-arg (map (first (.args ast)) .constraint)
            ;;       :let [val-num (c/type-num disp-arg)]
            ;;       :when-not (or (instance? c/ParamConstraint disp-arg)
            ;;                     (= c/UnknownType val-num)
            ;;                     (get-in target-c [.impl-fns val-num .arities arg-count]))]
            ;;   (status 'call-proto _LINE_ loc
            ;;           "\n" ast
            ;;           "\n\n" 'disp val-num disp-arg))
            (let [print-info? (and (= (.call-target old-ast) '.extract)
                                   ;; (= (.file loc) "assertion-tests/bad-constructor-param-2.toc")
                                   (= (.line loc) 2958)
                                   ;; nothing
                                   )]
              (for [
                    ;; TODO: attempting to replace a ProtoImpls target-c using this code fails dramatically
                    ;; No idea why.
                    ;; target-c (cond (instance? c/ProtoImpls target-c)
                    ;;                (get-value-type (.fn-sym target-c))
                    ;;                (se/state-error target-c))

                    ;; _ (map se-nop (fn [_]
                    ;;                 (cond print-info?
                    ;;                       (print-err 'call-site _LINE_ loc (.call-target old-ast)
                    ;;                        ;; "\n" 'target-c target-c
                    ;;                                  )
                    ;;                       '_)))

                    ;; TODO: this might have a perf hit. Check after all assertion tests pass
                    target-c (cond (or (instance? c/FnConstraint target-c)
                                       (instance? c/ReifiedConstraint target-c))
                                   (cata (fn [inner]
                                           ;; Get the current type info for any proto impls
                                           (cond (instance? c/ProtoImpls inner)
                                                 (get-value-type (ast/tag (.fn-sym inner) loc))

                                                 (se/state-error inner)))
                                         target-c
                                         se/state-error)

                                   (se/state-error target-c))
                    :let [
                          _ (map print-info?
                                 (fn [_]
                                   (status 'call-site _LINE_ loc (.call-target old-ast)
                                           "\n" 'target-c target-c
                                           "\n\n" 'args (str "[" (-> arg-cs
                                                                     (interpose "\n ")
                                                                     to-str)
                                                             "]")
                                           )))

                          [result-type arg-cs] (c/do-call-value target-c arg-cs (list loc))
                          ;; result-type (c/trim result-type)

                          _ (map print-info?
                                 (fn [_]
                                   (status 'call-site _LINE_ loc (.call-target ast)
                                           "\n" 'result (c/trim result-type)
                                           )))
                          ]
                    _ (update-constraint (.call-target ast)
                                         (.required-arities c/fn-constraint [(count arg-cs)])
                                         loc)
                    new-args (either (map (= c/bottom-type result-type)
                                          (fn [_]
                                            (compilation-error ;; 'site _LINE_ loc
                                                               ;; "\n" old-ast
                                                               ;; "\n\n" 'target-c target-c
                                                               ;; "\n\n" 'arg-cs (map (.args ast)
                                                               ;;                     .constraint)
                                                               ;; "\n\n" 'result-type result-type
                                                               ;; "\n\n"
                                                               (conf-ass _LINE_ result-type loc))))
                                     (se/traverse (zip-lists (.args ast) arg-cs)
                                                  (fn [[ast arg-c]]
                                                    ;; (map print-info?
                                                    ;;      (fn [_]
                                                    ;;        (status 'updating-arg _LINE_ loc
                                                    ;;                lflf 'ast ast
                                                    ;;                lflf 'ast-c (.constraint ast)
                                                    ;;                lflf 'arg-c arg-c)))
                                                    (update-constraint ast arg-c loc))))]
                (-> ast
                    (.args (vec new-args))
                    (.constraint result-type))))))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

;; (defn start-clock []
;;   (let [start (sys/clock_gettime)]
;;     (send start-time (fn [_] start))))

;; (defn stop-clock [ast]
;;   (let [end (sys/clock_gettime)]
;;     (send start-time (fn [start]
;;                        (let [delta (sys/time-delta start end)]
;;                          (send max-time (fn [prev-max]
;;                                           (cond (< prev-max delta)
;;                                                 (do
;;                                                   (status 'slow _LINE_
;;                                                           (div delta 1000)
;;                                                           (ast/location ast)
;;                                                           lflf ast)
;;                                                   delta)
;;                                                 prev-max)))
;;                          start)))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (set-value-type (.sym ast) c/top-type)]
      (.value-exprs ast (-> (.value-exprs ast)
                            (remove (partial instance? ast/block-comment-ast))
                            (map (fn [inner-ast]
                                   (cond (instance? ast/fn-ast inner-ast)
                                         (.fn-sym inner-ast (.sym ast))

                                         (instance? c/SymbolConstraints inner-ast)
                                         (c/update-sym inner-ast (.sym ast))

                                         inner-ast)))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))
          sym (.sym old-ast)]
      (for [_ (pop-types)
            c (either (map (last (.value-exprs ast))
                           (fn [val]
                             (cond (instance? c/Constraints val)
                                   ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                   ;; the updated version. Possibly a bug in assoc-in*

                                   ;; TODO: this version produces a very cryptic error message
                                   ;; (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                   ;;           (set-value-type (.sym old-ast) val))

                                   (let [val (c/trim val)]
                                     (flat-map (se/assoc-in-val [.types sym] val)
                                               (fn [_]
                                                 (set-value-type sym val))))

                                   (and (= c/top-type (.constraint val))
                                        (or (= sym 'empty-list)
                                            (= sym 'empty-vector)
                                            (= sym 'int-max)
                                            (= sym 'int-min)
                                            (= sym 'nothing)))
                                   (flat-map (get-value-type sym)
                                             (fn [c]
                                               (set-value-type sym (c/update-path c loc))))

                                   (set-value-type sym (c/trim (.constraint val))))))
                      (set-value-type (.sym old-ast) c/top-type))]
        (do
          ;; (status 'defed _LINE_ loc (.sym old-ast)
          ;;            lflf c)
          ast)))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (c/tag (gensym "fn-arity"))
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (start-clock)]

            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) core)
            ;;          (and (= (.fn-sym ast) 'fogity)
            ;;               (do
            ;;                 (status 'pre-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'params (.params ast)
            ;;                         lflf 'body "[" (to-str (interpose (.body ast) lflf)) "]"
            ;;                         lflf 'const (.constraint ast))
            ;;                 nothing)))]
            _ (set-value-type ast/result-sym c/top-type)
            _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                      (set-value-type sym c/top-type)))
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   se-nop

                                   (append-value-type sym
                                                      (c/ParamConstraint arity-id index
                                                                         empty-list
                                                                         sym "")
                                                      loc))))
            _ (append-value-type (.variadic (.params ast))
                                 (c/ParamConstraint arity-id arg-count empty-list
                                                    (.variadic (.params ast)) "")
                                 loc)
            ;; TODO: should use cata to make all the variadic syms be lists
            ]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast)))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (get-value-type ast/result-sym)
            ;; :let [_ (stop-clock ast)]
            _ (recover-val-type ast/result-sym)
            pts (get-param-types (.params old-ast))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            :let [body-c (either (map (last (.body ast)) .constraint)
                                 c/top-type)
                  final-c (c/intersect result-c body-c)]
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;          ;; (= (.file loc) core)
            ;;          (and (= (.fn-sym ast) 'fogity)
            ;;               (do
            ;;                 (status 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'pts pts
            ;;                         lflf 'result-c result-c
            ;;                         lflf 'body-c body-c
            ;;                         lflf 'final-c final-c
            ;;                         lflf 'ast-c (.constraint ast)
            ;;                         lflf 'body-exprs (str "[" (to-str (interpose (.body ast) "\n")) "]"))
            ;;                 nothing)))]
            _ (either (map (or (= c/bottom-type pts)
                               (= c/bottom-type final-c))
                           (fn [failure-c]
                             (compilation-error ;; 'arity _LINE_ loc (.fn-sym old-ast)
                                                ;; lflf 'pts pts
                                                ;; lflf 'result-c result-c
                                                ;; lflf 'body-c body-c
                                                ;; lflf 'final-c final-c
                                                ;; lflf 'body (either (map (last (.body ast)) .constraint)
                                                ;;                    c/top-type)
                                                ;; lflf
                                                (conf-ass _LINE_ failure-c loc)
                              )))
                      se-nop)]
        ;; TODO: use update-constraint here
        (cond (= c/bottom-type pts)
              '_

              (.constraint ast (c/intersect (.constraint ast)
                                            (c/fn-arity (.fn-var ast) pts final-c))))))))

(extend-type ast/fn-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          sym (.fn-sym ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  "\n" ast)
      ;;       nothing))
      (for [_ (push-types)
            _ (set-value-type sym (-> c/fn-constraint
                                      (c/intersect (c/coll-of-c c/empty-reified))
                                      (c/update-path loc)
                                      (c/update-sym sym)))]
        (.arities ast (map (.arities ast)
                           (fn [arity]
                             (.fn-sym arity sym)))))))

  (type-check [ast old-ast]
    (let [sym (.fn-sym ast)
          fn-c (-> c/fn-constraint
                   (c/update-path (ast/location sym))
                   (c/update-sym sym))
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (get-in arity-c [.param-consts .tail-c])
                                         :when (= c/no-tail variadic)
                                         fixed-params (get-in arity-c [.param-consts .items])]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) "\n" fn-c)
      ;;         nothLing)))
      (flat-map (nip-types)
                (fn [_]
                  (se/state-error (.constraint ast fn-c)))))))

(extend-type Symbol
  TypeChecker
  (pre-check [s]
    (print-err 'wut _LINE_ s)
    (se/state-error (abort))))

(extend-type c/TaggedSymbol
  TypeChecker
  (param-types [sym]
    (get-value-type sym))

  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (all-symbols [ast]
    [ast])

  (recover-val-type [sym]
    (flat-map (se/get-in-val [.value-types])
              (fn [types-list]
                (assert (instance? List types-list))
                (map (either (for [value-types (nth types-list 1)
                                   prev-constraint (get value-types sym)]
                               (set-value-type sym prev-constraint))
                             (remove-value-type sym))
                     RecurseFinal))))

  (type-check [s old-s]
    (map (get-value-type s)
         (partial .constraint s))))

(extend-type ast/params-ast
  TypeChecker
  (recover-val-type [x]
    (se/state-error (RecurseWith x)))

  (update-constraint [ast constraint loc]
    (either (map (instance? c/ListConstraint (.variadic ast))
                 (fn [_]
                   (status "Compiler error:" _FILE_ _LINE_ "\n" 'variadic (.variadic ast))))
            '_)
    (let [new-c (-> (.constraint ast)
                    (c/intersect c/seq-constraint)
                    (c/intersect (c/update-path constraint loc)))]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c loc))))
              ;; TODO: rather than use c/get-items, implement an ItemOf type-op
              ;; and use that to get each of the item-cs as needed
              (let [[item-cs tail-item-cs] (-> (c/get-items new-c)
                                               (split (count (.fixed ast))))
                    tail-c (-> c/list-constraint
                               (c/set-items tail-item-cs)
                               (c/set-tail (c/get-tail new-c))
                               (c/replace-path (.path new-c)))]
                ;; TODO: these are possibly redundant intersects
                (for [_ (se/traverse (zip-lists (seq (.fixed ast)) item-cs)
                                     (fn [[ast c]]
                                       (update-constraint ast c loc)))
                      _ (update-constraint (.variadic ast) tail-c loc)]
                  (.constraint ast new-c))))))

  (all-symbols [params]
    (comp* (.variadic params)
           (seq (.fixed params))))

  (param-types [params]
    (-> c/seq-constraint
        (c/set-tail (cond (= c/no-symbol (.variadic params))
                          c/no-tail
                          (.variadic params)))
        (c/set-items (.fixed params))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> c/seq-constraint
                (c/set-items (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (map (append-value-type (.variadic ast) c/list-constraint
                              (ast/location (.variadic ast)))
           (fn [appended-var]
             (-> ast
                 (.constraint (c/set-tail c c/coll-of-any))
                 (.variadic (either (= c/no-symbol (.variadic ast))
                                    (.constraint (ast/tag (.variadic ast))
                                                 appended-var)))))))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          ;; _ (map se-nop (fn [_]
          ;;                 (print-err 'extending _LINE_ (ast/location ast) (.type ast))))
          type-info (get-type-info (.type ast) (ast/location ast))
          ;; TODO: don't allow extension of refined types
          :let [type-infos (cond (instance? c/SumConstraint type-info)
                                 (.alts type-info)
                                 [type-info])]
          new-ast (map ast
                       (fn [arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (either (-> (.params arity)
                                     .fixed
                                     first 
                                     (map (fn [first-param]
                                            ;; (print-err 'params _LINE_ (ast/location first-param)
                                            ;; first-param)
                                            (-> type-infos
                                                (map (fn [type-info]
                                                       (let [type-info (c/update-sym type-info first-param)
                                                             new-bod (comp [type-info] (.body arity))]
                                                         (ProtoArity (c/type-num type-info)
                                                                     (.body arity new-bod)))))
                                                se/state-error))))
                                 (compilation-error "Prototype implentation for "
                                                    (str "'" (.fn-sym arity) "'")
                                                    "must have at least one parameter at"
                                                    (ast/location (.fn-sym arity)))))
                       se/state-error)]
      (-> (either (get new-ast .impls)
                  {})
          vals
          vec
          (map vals)
          (map vec)
          (conj (reify
                  Type
                  (type-name [_]
                    (str "reified at " (c/Location _FILE_ _LINE_)))

                  Container
                  (map [y f embed]
                    (embed y))

                  TypeChecker
                  (pre-check [x]
                    (flat-map (pop-types)
                              (fn [_]
                                (se/state-error (ast/block-comment-ast [] c/no-loc
                                                                       c/top-type)))))))))))

(extend-type ast/string-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (-> (.constraint ast (assoc-in c/strbuff-constraint [.fields c/static-value] str-val))
          se/state-error ))))

(extend-type ast/integer-ast
  TypeChecker
  (type-check [ast old-ast]
    (-> (.constraint ast (-> (assoc-in c/int-constraint [.fields c/static-value] (.int old-ast))
                             (c/update-path (ast/location old-ast))))
        se/state-error)))

(deftype PushTypes [expr]
  TypeChecker
  (pre-check [_]
    (flat-map (push-types)
              (fn [_]
                (pre-check expr)))))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.alt (PushTypes (.alt ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          new-clause (update-constraint (.clause ast) c/maybe-constraint (ast/location old-ast))]
      (.constraint ast (-> (c/sum-c [(.base c/inner-type-of (.constraint new-clause))
                                     (.constraint (.alt ast))])
                           (c/update-path (ast/location old-ast)))))))

(deftype Binder [binding val]
  Container
  (map [x f]
    (.val x (f val)))

  (map [x f embed]
    (map (f val)
         (partial .val x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location binding))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [_ (update-constraint binding (.constraint val) (ast/location val))]
      val)))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          ;; _ (map se-nop
          ;;        (fn [_]
          ;;          (let [loc (ast/location ast)]
          ;;            (or (= (.line loc) 0)
          ;;                (= (.file loc) 'core)
          ;;                (do
          ;;                  (status 'checking-binding _LINE_ loc
          ;;                             "\n" 'ast ast)
          ;;                  nothing)))))
          _ (se/traverse (all-syms (.binding ast)) (fn [sym]
                                                     (set-value-type sym c/top-type)))]
      (.val ast (Binder (.binding ast) (.val ast)))))

  (type-check [ast old-ast]
    (let [binding (.binding ast)
          val (.val ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [binding-c (cata param-types binding se/state-error)
            _ (se/traverse (all-syms binding) recover-val-type)
            ;; val-c (map (update-constraint val binding-c loc) .constraint)
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             (= (.file loc) 'core)
            ;;          (do
            ;;            (status 'let _LINE_ loc
            ;;                    lflf 'binding (type-name binding) binding
            ;;                    lflf 'binding-c binding-c
            ;;                    lflf 'val val
            ;;                    lflf 'orig-val-c (.constraint val)
            ;;                    lflf 'val-c val-c)
            ;;            nothing))]
            _ (nip-types)]
        (.constraint ast (either (and (instance? Vector cont)
                                      (map (last cont) .constraint))
                                 (.constraint (.cont ast))))))))

(extend-type ast/or-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)
            new-ast (update-constraint (-> ast
                                           (.clause new-clause)
                                           (.cont new-cont))
                                       c/maybe-constraint loc)]
        new-ast))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)
            new-ast (update-constraint (-> ast
                                           (.clause new-clause)
                                           (.cont new-cont))
                                       c/maybe-constraint loc)]
        new-ast))))

(extend-type ast/cond-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.value ast (PushTypes (.value ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          val (.value ast)
          cont (.cont ast)]
      (for [_ (pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-c (update-constraint clause c/maybe-constraint (ast/location old-ast))]
        (-> ast
            (.clause new-c)
            (.constraint (c/sum-c [(.constraint val)
                                   (.constraint cont)])))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      ;; TODO: remove ones no longer used
                      'ResultConstraint c/ResultConstraintType
                      'InferredInner c/InferredInnerType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? c/TaggedSymbol type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract type-counter)))

(deftype DestructFields [fields]
  (assert (instance? (vector-of c/TaggedSymbol) fields))

  Stringable
  (string-list [_]
    (list "(DestructFields " (to-str fields) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))
  
  (type-check [ast old-ast]
    ;; TODO: need to destructure the fields here
    (se/state-error ast)))

(def x* (ast/tag "#x"))
(def y* (ast/tag "#y"))
(def field* (ast/tag "#field"))
(def ctxt* (ast/tag "#ctxt"))

(defn default-type-impls [type-sym fields]
  (let [loc (ast/location type-sym)]
    ;; TODO: make sure the constraints on all these fn's are as specific as possible
    {Type-sym
     {type-name-sym
      {1 (ast/fn-arity
          (ast/tag type-name-sym loc)
          (ast/params [x*]) ""
          [(ast/string-ast (str type-sym) loc c/string-constraint)])}

      ;; has-field-sym
      ;; {2 (ast/fn-arity
      ;;     (ast/tag has-field-sym loc)
      ;;     (ast/params [x* field*]) ""
      ;;     [(ast/and-expr
      ;;       [(ast/or-expr
      ;;          (conj (map fields
      ;;                     (fn [field]
      ;;                       (ast/call-expr [identical-sym
      ;;                                       (ast/tag (str "." field) loc)
      ;;                                       field*])))
      ;;                nothing-sym))
      ;;        (ast/call-expr [maybe-sym x*])])])}
      }

     ;; Eq-sym
     ;; {=*-sym
     ;;  {2 (ast/fn-arity
     ;;      (ast/tag =*-sym loc)
     ;;      (ast/params [x* y*]) ""
     ;;      [(ast/and-expr
     ;;        [(ast/call-expr [=*-sym (ast/call-expr [get-type-sym x*])
     ;;                         (ast/call-expr [get-type-sym y*])])
     ;;         (ast/call-expr [=*-sym (ast/call-expr [default-type-args-sym x*])
     ;;                         (ast/call-expr [default-type-args-sym y*])])
     ;;         (ast/call-expr [maybe-sym x*])])])}}

     ;; Associative-sym
     ;; {get-symb
     ;;  {2 (ast/fn-arity
     ;;      (ast/tag get-symb loc)
     ;;      (ast/params [x* field*]) ""
     ;;      [ ;; (c-code "" ["// TODO: this seems to do runtime checks for 'has-field' result\n// and the result returned\n"]
     ;;       ;;         {} c/top-type)
     ;;       (ast/and-expr
     ;;        [(ast/call-expr [(ast/tag has-field-sym loc) x* field*])
     ;;         (ast/call-expr [maybe-sym
     ;;                         (ast/call-expr [field* x*])])])])}

     ;;  assoc-sym
     ;;  {3 (ast/fn-arity
     ;;      (ast/tag assoc-sym loc)
     ;;      (ast/params [x* field* (ast/tag 'new-value)]) ""
     ;;      [(ast/cond-expr
     ;;        [(ast/cond-val-expr (ast/call-expr [(ast/tag has-field-sym loc) x* field*])
     ;;                            (ast/call-expr [field* x* (ast/tag 'new-value)]))]
     ;;        x*)])}}

     ;; Hashable-sym
     ;; {sha1-update-sym
     ;;  {2 (ast/fn-arity
     ;;      (ast/tag sha1-update-sym loc)
     ;;      (ast/params [x* ctxt*]) ""
     ;;      [(ast/call-expr [sha1-update-type-sym x* ctxt*])
     ;;       (ast/call-expr [sha1-update-sym (ast/call-expr [default-type-args-sym x*]) ctxt*])])}

     ;;  sha1-sym
     ;;  {1 (ast/fn-arity
     ;;      (ast/tag sha1-sym loc)
     ;;      (ast/params [x*]) ""
     ;;      [(ast/call-expr
     ;;        [sha1-finalize-sym
     ;;         (ast/call-expr
     ;;          [sha1-update-sym x*
     ;;           (ast/call-expr [sha1-init-sym])])])])}}
     }))

(defn create-getters [sym type-num new-type-constraint fields field-constraints]
  (let [type-value (ast/tag "#value")
        field-arg (ast/tag "#field")
        loc (ast/location sym)]
    ;; TODO: make sure the constraints on all these fn's are as specific as possible
    {Type-sym
     (-> (zip-lists (seq fields) (range (count fields)) field-constraints)
         (map (fn [[field field-index field-constraint]]
                (let [field-sym (-> (str "." field) c/tag c/Field)]
                  [(ast/tag (.sym field-sym) loc)
                   [;; setter arity
                    (let [arity-id (c/tag (str sym "-" field "-setter"))
                          field-constraint (c/update-path field-constraint loc)]
                      (ast/fn-arity-ast
                       (ast/tag (str "." field) loc)
                       arity-id (ast/params [type-value field-arg]) ""
                       [(ast/inline-ast (ast/tag 'C) c/top-type
                                        (str "return(updateField(value_0, field_1, "
                                             field-index "));\n")
                                        c/no-loc)]
                       (c/fn-arity
                        arity-id
                        (-> c/list-constraint
                            (c/set-items [new-type-constraint field-constraint]))
                        (c/type-op c/set-to-op
                                   (c/ParamConstraint arity-id 0 empty-list c/no-symbol "")
                                   [[field-sym]
                                    (c/ParamConstraint arity-id 1 empty-list c/no-symbol "")]))))

                    ;; getter arity
                    (let [arity-id (c/tag (str sym "-" field "-getter"))
                          field-constraint (-> (c/type-op c/get-from-op
                                                          (c/ParamConstraint arity-id 0 empty-list c/no-symbol "")
                                                          [field-sym])
                                               (c/intersect field-constraint))]
                      (ast/fn-arity-ast
                       (ast/tag (str "." field) loc)
                       arity-id (ast/params [type-value]) ""
                       [(ast/inline-ast (ast/tag 'C) field-constraint
                                        (str "
  Value *result = incRef(((ReifiedVal *)value_0)->impls[" field-index "], 1);
  dec_and_free(value_0, 1);
  return(result);
")
                                        c/no-loc)]
                       (c/fn-arity
                        arity-id
                        (-> c/empty-list-constraint
                            (c/set-items [new-type-constraint]))
                        field-constraint)))]])))
         (reduce {} (fn [m [k v]]
                      (assoc m k v))))}))

;; TODO: every place that calls this needs to refactored
(defn constrain-first-param [type-info c]
  (cond (instance? ast/fn-arity-ast c)
        (either (-> (.params c)
                    .fixed
                    first
                    (map (fn [first-param]
                           ;; (print-err 'params _LINE_ (ast/location first-param)
                           ;; first-param)
                           (let [type-info (c/update-sym type-info first-param)
                                 ;; TODO: wut is type-info updated with the first-param
                                 new-bod (comp [type-info] (.body c))]
                             (ProtoArity (c/type-num type-info)
                                         (.body c new-bod))))))

                (do
                  ;; (compilation-error "Prototype implentation for "
                  ;;                    (str "'" (.fn-sym c) "'")
                  ;;                    "must have at least one parameter at"
                  ;;                    (ast/location (.fn-sym c)))
                  (print-err 'BOOOMMMM _LINE_ c)
                  (abort)
                  c))

        (instance? List c)
        (vec c)

        c))

(deftype CreateGetters [sym type-num new-type-constraint fields loc]
  Stringable
  (string-list [_]
    (list "(CreateGetters " (str sym) " " (to-str fields) " " (str loc) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (map (se/traverse fields (fn [field]
                               (for [_ (get-value-type (ast/tag (str "." field) loc))
                                     field-info (get-value-type field)]
                                 field-info)))
         (fn [field-cs]
           (let [impls (-> (create-getters sym type-num new-type-constraint
                                           fields field-cs)
                           vals
                           (map vals))]
             (cata (fn [c]
                     (constrain-first-param new-type-constraint c))
                   impls))))))

(defn constructor-constraints [new-type-constraint new-type-sym const-fn]
  (assert (instance? c/ReifiedConstraint new-type-constraint))
  (assert (instance? c/TaggedSymbol new-type-sym))
  (assert (instance? c/FnConstraint const-fn))

  (let [reified-type-num (extract type-counter)
        field-count (count (.fields new-type-constraint))
        const-arity (either (get-in const-fn [.arities field-count])
                            (do
                              (status 'compiler-error _LINE_ new-type-sym
                                      lflf new-type-constraint
                                      lflf const-fn)
                              (wait-for-output)
                              (abort)))
        const-fn (.arities const-fn (reduce (vec (.arities const-fn)) {}
                                            (fn [arities [rank arity]]
                                              (either (map (update-in arity [.param-consts .items]
                                                                      (fn [cs]
                                                                        (comp [c/top-type] cs)))
                                                           (partial assoc arities (inc rank)))
                                                      arities))))
        const-name (str "* " new-type-sym " constructor at " (ast/location new-type-sym)" *")
        reified-c (c/ReifiedConstraint reified-type-num
                                       (c/tag const-name)
                                       {} {} const-fn
                                       empty-list c/no-symbol "")]
    (for [_ (se/assoc-in-val [.types new-type-sym] new-type-constraint)
          _ (set-value-type new-type-sym reified-c)
          ;; TODO: need instance? constraint
          _ (add-proto-impl reified-type-num
                            apply-sym
                            2
                            (c/fn-arity (c/tag (str new-type-sym "_apply"))
                                        (.items c/list-constraint
                                                [reified-c (.param-consts const-arity)])
                                        new-type-constraint))
          _ (se/traverse (vec (.field-consts new-type-constraint))
                         (fn [[field fld-c]]
                           (let [sym (.sym field)
                                 type-num (.type-number new-type-constraint)
                                 getter-id (c/tag (str new-type-sym "-" sym "-getter"))
                                 getter-param (c/ParamConstraint getter-id 0
                                                                 empty-list c/no-symbol "")
                                 setter-id (c/tag (str new-type-sym "-" sym "-setter"))
                                 setter-param-0 (c/ParamConstraint setter-id 0
                                                                   empty-list c/no-symbol "")
                                 setter-param-1 (c/ParamConstraint setter-id 1
                                                                   empty-list c/no-symbol "")]
                             (for [_ (get-value-type (ast/tag sym))
                                   _ (add-proto-impl type-num sym 1
                                                     (c/fn-arity
                                                      getter-id
                                                      (-> c/empty-list-constraint
                                                          (c/set-items [new-type-constraint]))
                                                      (-> (c/type-op c/get-from-op getter-param
                                                                     [field])
                                                          (c/intersect fld-c))))
                                   _ (add-proto-impl type-num sym 2
                                                     (c/fn-arity
                                                      setter-id
                                                      (-> c/empty-list-constraint
                                                          (c/set-items [new-type-constraint fld-c]))
                                                      (c/type-op c/set-to-op setter-param-0
                                                                 [[field] setter-param-1])))]
                               '_))))]
      '_)))

(defn create-constructor [new-type-name type-num new-type-constraint field-constraints fields]
  (assert (instance? c/TaggedSymbol new-type-name))
  (assert (instance? c/ReifiedConstraint new-type-constraint))
  (assert (instance? c/ListConstraint field-constraints))
  (assert (instance? (vector-of Symbol) fields))

  (let [loc (ast/location new-type-name)
        field-count (count fields)
        reified-type-num (extract type-counter)
        field-params (-> (comp ['_]
                               (map (range field-count)
                                    (fn [n]
                                      (ast/tag (str "arg" n)))))
                         (map (fn [arg]
                                (ast/tag arg loc)))
                         ast/params)]
    ;; TODO: this causes a parsing error
    ;; (ast/reified (maybe reified-type-num)
    ;;              {
    ;;               })

    ;; TODO: make sure the constraints on all these fn's are as specific as possible

    ;; TODO: add 'comp*' implementation
    (ast/reified reified-type-num
                 {Eq-sym
                  {(ast/tag =*-sym loc)
                   [(ast/fn-arity
                     (ast/tag =*-sym loc)
                     (ast/params [x* y*]) ""
                     [(ast/and-expr
                       [(ast/call-expr [=*-sym (ast/integer-ast type-num c/no-loc
                                                                (-> c/int-constraint
                                                                    (assoc-in [.fields c/static-value]
                                                                              type-num)
                                                                    (c/update-path loc)))
                                        (ast/call-expr [get-type-sym y*])])
                        (ast/call-expr [maybe-sym y*])])])]}

                  Type-sym
                  {type-name-sym
                   [(ast/fn-arity
                     (ast/tag type-name-sym loc)
                     (ast/params [(ast/tag '_)]) ""
                     (let [s (str "* " new-type-name " constructor at " (.file loc) ": " (.line loc) " *")]
                       [(ast/string-ast s c/no-loc
                                        (cata (fn [c]
                                                (cond (or (instance? StringBuffer c)
                                                          (instance? SubString c))
                                                      (assoc-in c [.fields c/static-value] s)

                                                      c))
                                              c/string-constraint))]))]

                   ;; TODO: put back in
                   ;; type-mapping-sym
                   ;; [(ast/fn-arity
                   ;;   (ast/tag (str new-type-name "_const_type_map") loc)
                   ;;   (ast/params [(ast/tag '_)]) ""
                   ;;   [(map-vals (.type-maps new-type-constraint)
                   ;;              (fn [field-set]
                   ;;                (map (keys field-set) ast/quoted-ast)))])]

                   instance?-sym
                   [(ast/fn-arity-ast
                     (ast/tag instance?-sym loc) ""
                     (ast/params [x* y*]) ""
                     [;; TODO: remove all inline assertions
                      ;; add constraints to arity struct
                      (ast/and-expr
                       [(ast/call-expr [=*-sym
                                        (ast/integer-ast type-num c/no-loc
                                                         (-> c/int-constraint
                                                             (assoc-in [.fields c/static-value]
                                                                       type-num)
                                                             (c/update-path loc)))
                                        (ast/call-expr [get-type-sym y*])])
                        (ast/call-expr [maybe-sym y*])])]
                     (let [arity-id (c/tag (str new-type-name "_instance_QM_"))]
                       (c/fn-arity
                        arity-id
                        (.items field-constraints [c/top-type c/top-type])
                        (-> new-type-constraint
                            (c/intersect (c/ParamConstraint arity-id 1
                                                     empty-list c/no-symbol ""))
                            (c/CollectionOf empty-list c/no-symbol "")
                            (c/intersect c/maybe-constraint)))))]}

                  Function-sym
                  {invoke-sym
                   (let [arity-id (c/tag (str new-type-name "_invoke"))]
                     [(ast/fn-arity-ast
                       (ast/tag invoke-sym loc)
                       arity-id field-params ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "ReifiedVal *rv = malloc_reified("
                                             field-count ");\n"
                                             "#ifdef SINGLE_THREADED\n"
                                             "rv->refs = refsInit;\n#else\n"
                                             " __atomic_store(&rv->refs,"
                                             " &refsInit, __ATOMIC_RELAXED);\n"
                                             "#endif\n"
                                             "rv->type = " type-num ";\n"
                                             (to-str (map (range field-count)
                                                          (fn [idx]
                                                            (str "rv->impls[" idx "] = arg" idx
                                                                 "_" (inc idx) ";\n"))))
                                             "return((Value *)rv);\n")
                                        c/no-loc)]
                       (c/fn-arity
                        arity-id
                        (.items field-constraints (comp [c/top-type]
                                                        (.items field-constraints)))
                        (.fields new-type-constraint
                                 (merge-with c/intersect
                                             (.fields new-type-constraint)
                                             (-> (zip-lists fields (range (count fields)))
                                                 (reduce {} (fn [m [fld idx]]
                                                              (assoc m (c/Field (c/tag (str "." fld)))
                                                                     (c/ParamConstraint
                                                                      arity-id (inc idx)
                                                                      empty-list c/no-symbol "")))))))))])}

                  Container-sym
                  {apply-sym
                   (let [arity-id (c/tag (str new-type-name "_apply"))]
                     [(ast/fn-arity-ast
                       (ast/tag apply-sym loc)
                       arity-id (ast/params [(ast/tag '_ loc)
                                             (ast/tag 'fields loc)])
                       ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "return(newTypeValue(" type-num ", (Vector *)fields_1));")
                                        c/no-loc)]
                       (c/fn-arity
                        arity-id
                        (-> c/list-constraint
                            (c/set-items [c/top-type field-constraints]))
                        (.fields new-type-constraint
                                 (merge-with c/intersect
                                             (.fields new-type-constraint)
                                             (-> (zip-lists fields (range (count fields)))
                                                 (reduce {} (fn [m [fld idx]]
                                                              (assoc m (c/Field (c/tag (str "." fld)))
                                                                     (c/type-op c/get-from-op
                                                                                (c/param arity-id 1)
                                                                                [idx])))))))))])}

                  Stringable-sym
                  (let [s (str "<ValueConstructor " new-type-name " ["
                               (to-str (interpose fields ", "))
                               "]>")]
                    {string-list-sym
                     [(ast/fn-arity
                       (ast/tag string-list-sym loc)
                       (ast/params [(ast/tag 'z)]) ""
                       [(ast/call-expr [list-sym
                                        (ast/string-ast s c/no-loc
                                                        (cata (fn [c]
                                                                (cond (or (instance? StringBuffer c)
                                                                          (instance? SubString c))
                                                                      (assoc-in c [.fields c/static-value] s)

                                                                      c))
                                                              c/string-constraint))])])]})})))

(deftype CheckedTypeAST [sym type-num new-type-constraint const-fn-c fields impls]
  Stringable
  (string-list [_]
    (list "(CheckedTypeAST " (str sym) " " (str fields) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  TypeChecker
  (pre-check [ast]
    (for [field-types (get-param-types (ast/params fields c/no-symbol))
          _ (se/traverse fields recover-val-type)
          invoke-impls (get-value-type invoke-sym)
          _ (pop-types)
          _ (push-types)
          _ (-> new-type-constraint
                (.invoke-fn (either (get-in invoke-impls [.impl-fns type-num])
                                    c/empty-fn-constraint))
                (constructor-constraints sym const-fn-c))]
      ;; (let [invoke-fn (either (get-in invoke-impls [.impl-fns type-num])
      ;;                         c/empty-fn-constraint)
      ;;       constr-c (create-constructor sym type-num
      ;;                                    (.invoke-fn new-type-constraint invoke-fn)
      ;;                                    field-types fields)]
      ;;   (ast/definition-ast sym [constr-c]))
      (ast/block-comment-ast [] c/no-loc c/top-type)
      )))

(extend-type ast/rec-type-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)]
      (se/state-error (comp (map (.types ast) (fn [type]
                                                (ast/type-ast (.sym type) c/no-fields [])))
                            [(ast/definition (.sym ast)
                               [(c/SumConstraint
                                 (map (.types ast) (fn [type]
                                                     (.type-symbol c/empty-reified
                                                                   (.sym type))))
                                 (list loc)
                                 c/no-symbol "")])]
                            (.types ast))))))

(extend-type ast/quoted-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (reify
                      Type
                      (type-name [_]
                        (str "reified at " _LINE_))

                      Stringable
                      (string-list [_]
                        (list (str "'" (.q-val ast))))

                      Eq
                      (=* [_ y]
                        (= y (.q-val ast)))

                      Container
                      (map [x f]
                        x)

                      (map [x f embed]
                        (embed x))

                      ast/FileLoc
                      (ast/location [_]
                        (ast/location ast))

                      TypeChecker
                      (type-check [_ old-ast]
                        (se/state-error (.constraint ast (-> c/sym-constraint
                                                             (assoc-in [.fields  c/static-value]
                                                                       (c/tag (rest (str ast))))
                                                             (c/update-path (ast/location ast))))))))))

(extend-type ast/main-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                    (set-value-type sym c/top-type)))]
      (.body ast (remove (.body ast) (partial instance? ast/block-comment-ast)))))

  (type-check [ast old-ast]
    (se/state-error ast)))

(def _ (print-err 'creating-parser))
(def t1 (sys/clock_gettime))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(defn type-check-ast [ast]
  (cond (instance? c/Constraints ast)
        (cond (instance? c/SymbolConstraints ast)
              (cond (instance? c/TypeOfConstraint ast)
                    (type-check ast ast)
                    (flat-map (map ast type-check-ast se/state-error)
                              (fn [r]
                                (type-check r ast))))

              (instance? c/ProtoImpls ast)
              (se/state-error ast)
        
              (se/state-error ast))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (status 'type-checking _LINE_ loc
              ;;                 lflf 'ast ast
              ;;                 lflf 'new-ast new-ast)]
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and ;; (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                             lflf 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and ;; (extract flag)
            ;;        (maybe (status 'final-ast _LINE_ loc
            ;;                          lflf final-ast))))
            final-ast))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (cond (= (.fields ast) c/no-fields)
          (let [sym (.sym ast)
                loc (ast/location sym)]
            (se/assoc-in-val [.types sym]
                             (-> (c/ReifiedConstraint (new-type-number sym)
                                                      sym {} {c/contents c/top-type}
                                                      c/fn-constraint
                                                      empty-list c/no-symbol "")
                                 (c/update-path loc))))
          (let [sym (.sym ast)
                loc (ast/location sym)
                type-num (new-type-number sym)
                fields (-> ast .fields .fixed)
                field-destruct (DestructFields fields)]
            (for [_ (push-types)
                  ;; clear previous constraints for the fields
                  _ (se/traverse fields (fn [sym]
                                          (set-value-type sym c/top-type)))

                  _ (-> (.impls ast)
                        (filter (partial instance? c/SymbolConstraints))
                        (se/traverse type-check-ast))
                  field-cs (se/traverse fields get-value-type)
                  :let [fields-map (-> (zip-lists fields field-cs)
                                       (reduce {}
                                               (fn [m [name c]]
                                                 (assoc m
                                                   (c/Field (c/tag (str "." name))) c))))
                        new-type-constraint (-> (c/ReifiedConstraint type-num sym
                                                                     fields-map fields-map
                                                                     c/empty-fn-constraint
                                                                     empty-list c/no-symbol "")
                                                (c/update-path loc))
                        const-fn-c (-> c/fn-constraint
                                       (.arities {(count fields)
                                                  (c/fn-arity c/no-symbol
                                                              (.items c/list-constraint field-cs)
                                                              new-type-constraint)})
                                       (c/update-sym sym)
                                       (c/update-path loc))]
                  _ (se/assoc-in-val [.types sym] new-type-constraint)
                  _ (set-value-type sym const-fn-c)]
              (let [impls (apo (fn [ast]
                                 (cond (instance? HashMap ast)
                                       (RecurseWith (vec (vals ast)))

                                       (instance? ast/fn-arity-ast ast)
                                       (RecurseFinal
                                        (constrain-first-param new-type-constraint
                                                               (.body ast (comp [field-destruct]
                                                                                (.body ast)))))

                                       (RecurseWith ast)))
                                (.impls ast))
                    ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
                    ;; and parameter, respectively
                    ]
                [impls
                 ;; (CreateGetters (.sym ast) type-num new-type-constraint fields loc)
                 ;; TODO: why are the hash-map-impls done twice?
                 ;; (cond (empty? hash-map-impls)
                 ;;       (ast/block-comment "" 0 [])
                 ;;       (b/TypeExtension new-type-constraint hash-map-impls))
                 (CheckedTypeAST (.sym ast) type-num new-type-constraint const-fn-c fields impls)
                 (reify
                   Type
                   (type-name [_]
                     (str "reified at " (c/Location _FILE_ _LINE_)))

                   Container
                   (map [y f embed]
                     (embed y))

                   TypeChecker
                   (pre-check [x]
                     (se/state-error x))

                   (type-check [_ _]
                     (for [const-c (get-value-type (.sym ast))
                           :let [const-c (-> const-c
                                             (.type-symbol (c/tag (str (.sym ast) " constructor")))
                                             (c/update-path loc))]
                           _ (set-value-type (.sym ast) const-c)]
                       (ast/block-comment-ast [] c/no-loc c/top-type))))

                 ;; (reify
                 ;;   Container
                 ;;   (map [y f embed]
                 ;;     (embed y))

                 ;;   TypeChecker
                 ;;   (pre-check [ast]
                 ;;  report-type-stack
                 ;;     (for [ft (se/get-val .value-types)
                 ;;           mby (get-value-type maybe-sym)]
                 ;;       (do
                 ;;         (status 'vts _LINE_ sym (count ft)
                 ;;                 lflf 'maybe mby)
                 ;;         (ast/block-comment-ast [] c/no-loc c/top-type)))))
                 ]))))))

;; (extend-type ast/type-ast
;;   TypeChecker
;;   (pre-check [ast]
;;     (cond (= (.fields ast) c/no-fields)
;;           (let [sym (.sym ast)
;;                 loc (ast/location sym)]
;;             (se/assoc-in-val [.types (ast/untag sym)]
;;                              (-> (c/ReifiedConstraint (new-type-number sym)
;;                                                       (ast/untag sym)
;;                                                       {} {c/contents c/top-type}
;;                                                       c/fn-constraint
;;                                                       empty-list c/no-symbol "")
;;                                  (c/update-path loc))))
;;           (let [loc (ast/location (.sym ast))
;;                 type-num (new-type-number (.sym ast))
;;                 sym (.sym ast)
;;                 fields (-> ast .fields .fixed)
;;                 field-destruct (DestructFields fields)
;;                 fields-map (reduce fields {}
;;                                    (fn [m name]
;;                                      (assoc m
;;                                        (c/Field (symbol (str "." name))) c/top-type)))]
;;             (for [_ (push-types)
;;                   _ (se/traverse fields (fn [sym]
;;                                           (set-value-type sym c/top-type)))
;;                   field-assertions (-> (.impls ast)
;;                                        (filter (partial instance? c/SymbolConstraints))
;;                                        (se/traverse
;;                                         (fn [c]
;;                                           (let [sym (c/extract-sym c)]
;;                                             (cond (= sym c/no-symbol)
;;                                                   c/top-type

;;                                                   (flat-map (type-check-ast c)
;;                                                             (fn [new-c]
;;                                                               (update-constraint (ast/tag sym loc)
;;                                                                                  new-c loc))))))))
;;                   field-cs (se/traverse fields get-value-type)
;;                   :let [const-arity-map (-> (.arities c/fn-constraint)
;;                                             (select-keys [(count fields)])
;;                                             (map-vals (fn [arity]
;;                                                         (assoc-in arity [.param-consts .items] field-cs))))
;;                         new-type-constraint (-> (c/ReifiedConstraint type-num
;;                                                                      (ast/untag sym)
;;                                                                      fields-map fields-map
;;                                                                      (.arities c/fn-constraint
;;                                                                                const-arity-map)
;;                                                                      empty-list c/no-symbol "")
;;                                                 (c/update-path loc))]
;;                   _ (se/assoc-in-val [.types (ast/untag sym)] new-type-constraint)

;;                   _ (set-value-type sym (-> c/fn-constraint
;;                                             (.arities const-arity-map)
;;                                             (c/update-sym (ast/untag sym))
;;                                             (c/update-path loc)))]
;;               (let [impls (apo (fn [ast]
;;                                  (cond (instance? HashMap ast)
;;                                        (RecurseWith (vec (vals ast)))

;;                                        (instance? ast/fn-arity-ast ast)
;;                                        (RecurseFinal
;;                                         (constrain-first-param new-type-constraint
;;                                                                (.body ast (comp [field-destruct]
;;                                                                                 (.body ast)))))

;;                                        ;; (instance? Sequence ast)
;;                                        ;; (RecurseWith (reduce ast []
;;                                        ;;                      (fn [result inner]
;;                                        ;;                        (cond (instance? Sequence inner)
;;                                        ;;                              (reduce inner result conj)

;;                                        ;;                              (conj result inner)))))

;;                                        (RecurseWith ast)))
;;                                 (.impls ast))

;;                     ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
;;                     ;; and parameter, respectively
;;                     ]
;;                 (comp field-assertions
;;                       [impls
;;                        (CreateGetters (.sym ast) type-num new-type-constraint fields loc)
;;                        ;; TODO: why are the hash-map-impls done twice?
;;                        ;; (cond (empty? hash-map-impls)
;;                        ;;       (ast/block-comment "" 0 [])
;;                        ;;       (b/TypeExtension new-type-constraint hash-map-impls))
;;                        (CheckedTypeAST (.sym ast) type-num new-type-constraint
;;                                        c/fn-constraint fields impls)
;;                        (reify
;;                          Type
;;                          (type-name [_]
;;                            (str "reified at " (c/Location _FILE_ _LINE_)))

;;                          Container
;;                          (map [y f embed]
;;                            (embed y))

;;                          TypeChecker
;;                          (pre-check [x]
;;                            (se/state-error x))

;;                          (type-check [_ _]
;;                            (for [const-c (get-value-type (.sym ast))
;;                                  :let [const-c (-> const-c
;;                                                    (.type-symbol (symbol (str (.sym ast) " constructor")))
;;                                                    (c/update-path loc))]
;;                                  _ (set-value-type (.sym ast) const-c)]
;;                              (ast/block-comment-ast [] c/no-loc c/top-type))))

;;                        ;; (reify
;;                        ;;   Container
;;                        ;;   (map [y f embed]
;;                        ;;     (embed y))

;;                        ;;   TypeChecker
;;                        ;;   (pre-check [ast]
;;                        ;;  report-type-stack
;;                        ;;     (for [ft (se/get-val .value-types)
;;                        ;;           mby (get-value-type maybe-sym)]
;;                        ;;       (do
;;                        ;;         (status 'vts _LINE_ sym (count ft)
;;                        ;;                 lflf 'maybe mby)
;;                        ;;         (ast/block-comment-ast [] c/no-loc c/top-type)))))
;;                        ])))))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (grmr/any (reify
                Type
                (type-name [_]
                  (str "Reified at: " _FILE_ ": " _LINE_))

                Container
                (map [x f]
                  x)

                (map [x f embed]
                  (embed x))

                rd/Parser
                (rd/parse [p s]
                  (either (for [result-prom (get-in s [.values 'result-prom])
                                :when (delivered result-prom)]
                            (extract result-prom))
                          rd/parser-fail)))
              (apply-to (fn [type-checker result-prom ast]
                          ;; (status 'ast _LINE_ ast)
                          (send type-checker update-context
                                (flat-map se-nop
                                          (fn [_]
                                            ;; (status 'checking _LINE_ ast)
                                            (se/try
                                              (comp (type-check-ast ast)
                                                    (compilation-error "Could not type check code for expression at "
                                                                       lflf ast
                                                                       (ast/location ast)))
                                              (fn [err]
                                                (deliver result-prom err)
                                                (se/throw (.val err)))))))
                          ast)
                        (grmr/get-value 'type-checker)
                        (grmr/get-value 'result-prom)
                        rdr/top-level)))
   ;; (grmr/all
    
   ;;  (apply-to (fn [file-name]
   ;;              (status 'parsing-time file-name (div (sys/time-delta (extract core-start)
   ;;                                                                   (sys/clock_gettime))
   ;;                                                   1000))
   ;;              file-name)
   ;;            (grmr/get-value 'file-name)))
   ))
(def _ (print-err 'parser-created (div (sys/time-delta t1 (sys/clock_gettime))
                                       1000)))

(defn compile-module [file-name root-dir proj-dir module-index core-mod]
  ;; kick off a thread to load and check the module
  (status "Loading" file-name)
  ;; try to open file for reading
  (either (map (fio/file-in (c/file-name file-name))
               (fn [file-in]
                 ;; if opened, parse and type check it
                 (let [ast-checker (agent (new-module file-name module-index core-mod))
                       loading (promise)
                       parse-result (parse-forms {'file-name file-name
                                                  'root-directory root-dir
                                                  'project-directory proj-dir
                                                  'line-number 1
                                                  'type-checker ast-checker
                                                  'result-prom loading}
                                                 (lazy-list file-in))]
                   (cond (instance? rd/ParserError parse-result)
                         (do
                           (send output (fn [_]
                                            (print-err (.msg parse-result))
                                            (abort)))
                           (wait-for-output))

                         ;; after all expressions have been checked,
                         ;; deliver the resulting Module
                         (send ast-checker (partial deliver loading)))
                   loading)))

          ;; or tell everyone it couldn't be
          (do
            (send output (fn [_]
                           (print-err "Could not find/open " file-name)
                           (abort)))
            (wait-for-output))))

(extend-type ast/IsType
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (either (map (= (.ast ast) '_)
                         (fn [_]
                           (status "Type at:" (ast/location (.ast ast))
                                   (.expected ast))
                           se-nop))
                    (flat-map (se/try
                                (type-check-ast (.ast ast))
                                (fn [err]
                                  (status (.val err))
                                  (se/state-error (.constraint (.ast ast) c/bottom-type))))
                              (fn [c]
                                (either (map (= (c/trim (.constraint c)) (.expected ast))
                                             se/state-error)
                                        (compilation-error "Type Error:" (ast/location (.ast ast))
                                                           "\n" 'ast (.ast ast)
                                                           "\n\n" 'expected (.expected ast)
                                                           "\n\n" 'actual (either (get c .constraint)
                                                                                  c))))))
          _ (pop-types)]
      (ast/block-comment-ast [] c/no-loc c/top-type))))

(extend-type ast/GetImpl
  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (cond (= c/no-symbol (.type-sym ast))
          (se/state-error (.constraint ast (-> ast .impl-sym .constraint .default-impl)))

          (flat-map (get-type-info (.type-sym ast) (ast/location (.type-sym ast)))
                    (fn [c]
                      (let [type-num (c/type-num c)]
                        (either (map (get-in ast [.impl-sym .constraint .impl-fns type-num])
                                     (fn [impl-c]
                                       (se/state-error (.constraint ast impl-c))))
                                (compilation-error "Could not find impl for" (str "'" (.type-sym ast)
                                                                                  "' (" type-num ")")
                                                   "at" (ast/location (.type-sym ast))))))))))

(main [params]
  (deliver core-start (sys/clock_gettime))
  (let [core-mod (extract (compile-module core toccata-dir toccata-dir 0 'no-core))]
    (cond (instance? Module core-mod)
          (status "Loaded Core")

          (do
            (either (map (instance? se/Error core-mod)
                         (fn [err]
                           (status (.val err))
                           (wait-for-output)
                           (abort)))
                    (do
                      (status "Could not load Core")
                      (wait-for-output)
                      (abort)))))
    (send modules (fn [_]
                    {core core-mod}))
    (status 'time-for-core (div (sys/time-delta (extract core-start) (sys/clock_gettime)) 1000))
    ;; (let [core-types (extract (compile-module "core-types.toc" toccata-dir toccata-dir 1 core-mod))]
    ;;   (cond (instance? Module core-types)
    ;;         (status "Loaded core-types")

    ;;         (do
    ;;           (either (map (instance? se/Error core-types)
    ;;                        (fn [err]
    ;;                          (status (.val err))
    ;;                          (wait-for-output)
    ;;                          (abort)))
    ;;                   (do
    ;;                     (status "Could not load core-types")
    ;;                     (wait-for-output)
    ;;                     (abort))))))
    (-> (rest params)
        ;; TODO: empty-defn causes mem leaks
        ;; (remove (partial = "assertion-tests/empty-defn.toc"))
        (map (fn [file-name]
               (map (sys/file-directory file-name)
                    (fn [root-dir]
                      ;; (send modules (fn [_]
                      ;;                 {core core-mod}))
                      (let [
                            ;; _ (send output (fn [_]
                            ;;                  (fio/file-out (str file-name ".err"))))
                            core-result (compile-module file-name toccata-dir toccata-dir 1
                                                        core-mod)
                            core-result (either (map (instance? Promise core-result) extract)
                                                core-result)]
                        (cond (instance? Module core-result)
                              (status 'Loaded file-name)

                              (either (map (instance? se/Error core-result)
                                           (fn [err]
                                             (status (.val err))))
                                      (status "Could not load Toccata file:"
                                              file-name))))))))
        ;; (map extract)
        ))

  (wait-for-output))
