
(add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
                           "free.toc"
                           :sha "5c353f2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "f3a18dc"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "36fa952"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "13097ff"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "b1ec78a"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "1c19a8e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "4846add"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "ff13fae"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "a0c4886"))
(add-ns b (module "base.toc"))

(def symbols-sym (ast/tag "#symbols"))
(def protocols-sym (ast/tag "#protocols"))
(def invoke-sym (ast/tag 'invoke 'core 0))
(def Type-sym (ast/tag 'Type 'core 0))
(def Function-sym (ast/tag 'Function 'core 0))
(def Container-sym (ast/tag 'Container 'core 0))
(def Stringable-sym (ast/tag 'Stringable 'core 0))
(def type-name-sym (ast/tag 'type-name 'core 0))
(def type-mapping-sym (ast/tag 'type-mapping 'core 0))
(def =*-sym (ast/tag '=* 'core 0))
(def apply-sym (ast/tag 'apply 'core 0))
(def get-type-sym (ast/tag 'default-get-type 'core 0))
(def extract-sym (ast/tag 'extract 'core 0))
(def instance?-sym (ast/tag 'instance? 'core 0))
(def string-list-sym (ast/tag 'string-list 'core 0))
(def list-sym (ast/tag 'list 'core 0))
(def has-field-sym (ast/tag 'has-field 'core 0))
(def identical-sym (ast/tag 'identical 'core 0))
(def Eq-sym (ast/tag 'Eq 'core 0))
(def Associative-sym (ast/tag 'Associative 'core 0))
(def get-symb (ast/tag 'get 'core 0))
(def maybe-sym (ast/tag 'maybe 'core 0))
(def HashMapNode-sym (ast/tag 'HashMapNode 'core 0))
(def Hashable-sym (ast/tag 'Hashable 'core 0))
(def sha1-sym (ast/tag 'sha1 'core 0))
(def sha1-update-sym (ast/tag 'sha1-update 'core 0))
(def sha1-init-sym (ast/tag 'sha1-init 'core 0))
(def sha1-finalize-sym (ast/tag 'sha1-finalize 'core 0))
(def sha1-update-type-sym (ast/tag 'sha1-update-type 'core 0))
(def assoc-sym (ast/tag 'assoc 'core 0))
(def update-field-sym (ast/tag 'update-field 'core 0))
(def store-sym (ast/tag 'store 'core 0))
(def default-type-args-sym (ast/tag 'default-type-args 'core 0))
(def nth-sym (ast/tag 'nth 'core 0))
(def partial-sym (ast/tag 'partial 'core 0))
(def some-sym (ast/tag 'some 'core 0))
(def nothing-sym (ast/tag 'nothing 'core 0))
(def Tagged (any-of Symbol
                    ast/tagged-symbol))

(def flag (agent nothing))

(def output (agent nothing))

(defn status [& msg]
  (send output (fn [out-file?]
                 (assert (instance? Maybe out-file?))

                 (apply print-err msg)
                 (map out-file?
                      (fn [out-file]
                        (fio/write out-file (str (to-str (interpose msg " ")) "\n"))
                        out-file)))))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn update-context [context update]
  (assert (instance? se/StateError update))

  (let [new (update context)]
    ;; either the update succeeds, so get the new context
    (either (flat-map (instance? Vector new) second)
            ;; or keep the existing context
            context)))

(def type-counter (int-generator c/TypeCount))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

;; TODO: use 'either' here
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))

(def path-to-core (str toccata-dir "/new-core.toc"))

(defn compilation-error [& msg]
  (let [msg (to-str (interpose msg " "))]
    (se/throw msg)))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 "\n"
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype ProtoArity [type-num arity]
  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (partial .arity x))))

(deftype ProtoImpls [fn-sym default-impl impl-fns]
  (assert (instance? Symbol fn-sym))
  (assert (instance? c/FnConstraint default-impl))
  (assert (instance? (map-of Integer c/FnConstraint) impl-fns))

  Stringable
  (string-list [_]
    (list "(ProtoImpls '" (str fn-sym) "\n" (str default-impl) "\n\n" (str impl-fns) ")"))

  Container
  (map [x f]
    (ProtoImpls fn-sym
                (map default-impl f)
                (map-vals impl-fns f)))

  (map [x f embed]
    (for [def-impl (map default-impl f embed)
          impl-fns (contextual-map-vals impl-fns f embed)]
      (ProtoImpls fn-sym def-impl impl-fns)))

  c/Constraint
  (c/is-bottom [c]
    (either (or (= c/bottom-type (c/is-bottom default-impl))
                (-> (vals impl-fns)
                    (map c/is-bottom)
                    (some (partial = c/bottom-type))))
            c))

  (c/show-full [c]
    (comp (list (str "prototype " fn-sym))
          (c/show-full (.default-impl c))
          (list (str (map-vals impl-fns (fn [x]
                                          (to-str (interpose x "\n"))))))))

  (c/format-path [_ n]
    (c/format-path default-impl n))

  (c/assertion-path [_]
    (c/assertion-path default-impl))

  (c/intersect [x y]
    (cond (instance? ProtoImpls y)
          (c/intersect default-impl (.default-impl y))

          (c/intersect default-impl y))))

(def ConstraintOrProto (any-of c/Constraints
                               ProtoImpls))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of Symbol Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include ProtoImpls
  (assert (instance? (map-of Symbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

(defn get-types []
  (se/get-in-val [.value-types 0]))

(defn push-types
  ([]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (either (map (first types-list)
                                             (fn [value-types]
                                               (conj types-list value-types)))
                                        (conj types-list {}))))))
  ([value-types]
   (flat-map (se/get-in-val [.value-types])
             (fn [types-list]
               (se/assoc-in-val [.value-types]
                                (conj types-list value-types))))))

(defn pop-types []
  (for [curr-types (get-types)
        _ (se/update-in-val [.value-types] rest)]
    curr-types))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (flat-map (se/get-in-val [.value-types])
            (fn [types-list]
              (se/assoc-in-val [.value-types]
                               (either (map (first types-list)
                                            (fn [value-types]
                                              (cons value-types (drop types-list 2))))
                                       types-list)))))

(defn add-getter [sym types-list]
  (assert (instance? Symbol sym))
  (assert (instance? (list-of HashMap) types-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [required-field (c/ReifiedConstraint c/UnknownType {(c/Field sym) c/top-type}
                                            (symbol (str "field '" (rest (str sym)) "' required"))
                                            (.arities c/fn-constraint {}) empty-list c/no-symbol "")
        arities {1 (c/fn-arity (symbol (str sym "_getter"))
                               (c/ListConstraint [required-field]
                                                 c/no-tail empty-list c/no-symbol "")
                             c/top-type)
                 2 (c/fn-arity (symbol (str sym "_setter"))
                               (c/ListConstraint [required-field c/top-type]
                                                 c/no-tail empty-list c/no-symbol "")
                             c/top-type)}
        getter (ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? types-list)
          (list {sym getter})

          (get-in types-list [0 sym])
          types-list

          (map types-list (fn [value-types]
                            (assoc value-types sym getter))))))

(defn get-core-value-type [sym]
  (assert (instance? Symbol sym))

  (se/new-se (fn [s]
               (either (or (and (= 0 (.index s))
                                (or (map (get-in s [.value-types 0 sym])
                                         (fn [val-type]
                                           [val-type s]))
                                    (for [first-char (first (str sym))
                                          _ (= first-char ".")
                                          new-s (update-in s [.value-types]
                                                           (fn [val-types]
                                                             (add-getter sym val-types)))
                                          val-type  (get-in new-s [.value-types 0 sym])]
                                      [val-type new-s])
                                    (maybe se/Failure)))
                           (map (get-in (extract modules) ['core .value-types 0 sym])
                                (fn [expr]
                                  [expr s]))
                           ;; last ditch effort
                           (let [core-prom (promise)]
                             ;; (status 'sending sym _LINE_)
                             (send modules (fn [mods]
                                             (assert-result r (instance? HashMap r))
                                             (either (or (map (get-in mods ['core .value-types 0 sym])
                                                              (fn [val-type]
                                                                (deliver core-prom (maybe val-type))
                                                                mods))
                                                         (for [first-char (first (str sym))
                                                               _ (= first-char ".")
                                                               new-mods (update-in mods ['core .value-types]
                                                                                   (fn [val-types]
                                                                                     (add-getter sym val-types)))
                                                               val-type (get-in new-mods ['core .value-types 0 sym])]
                                                           (do
                                                             (deliver core-prom (maybe val-type))
                                                             new-mods)))
                                                     (do
                                                       (deliver core-prom nothing)
                                                       mods))))
                             (map (extract core-prom)
                                  (fn [expr]
                                    [expr s]))))
                       se/Failure))))

(defn get-value-type [sym]
  (assert (instance? Tagged sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (let [loc (ast/location sym)
              sym (ast/untag sym)]
          ;; TODO: this does not look up namespaced symbols
          (comp (se/get-in-val [.value-types 0 sym])
                (get-core-value-type sym)
                (compilation-error "Could not find type constraint for '" sym "' at " loc)))))

(defn set-value-type [sym constraint]
  (assert (instance? Tagged sym))
  (assert (instance? ConstraintOrProto constraint))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ constraint)
          se-nop)

        (map (se/update-in-val [.value-types]
                               (fn [types-list]
                                 (let [sym (ast/untag sym)]
                                   (either (map (first types-list)
                                                (fn [value-types]
                                                  (-> value-types
                                                      (dissoc sym)
                                                      (assoc sym constraint)
                                                      (cons (rest types-list)))))
                                           (list {sym constraint})))))
             (fn [_]
               constraint))))

(defn append-value-type [sym constraint loc]
  (assert (instance? Tagged sym))
  (assert (instance? ConstraintOrProto constraint))

  (cond (= (str sym) "")
        se-nop

        (let [curr-const (se/try
                           (get-value-type sym)
                           (fn [_]
                             (se/state-error c/top-type)))]

          (cond (= constraint c/top-type)
                curr-const

                (flat-map curr-const
                          (fn [curr-const]
                            (let [new-const (c/trim (c/intersect curr-const constraint))]
                              ;; (let [loc (ast/location sym)]
                              ;;   (or ;; (= (.file loc) 'core)
                              ;;    ;; (= (.line loc) 0)
                              ;;    (and (instance? ProtoImpls curr-const)
                              ;;         (do
                              ;;           (status 'appending _LINE_ loc (str "\"" sym "\"")
                              ;;                      "\n" 'constraint constraint
                              ;;                      "\n\n" 'curr curr-const
                              ;;                      "\n\n" 'new-const new-const)
                              ;;           nothing))))

                              (cond (= new-const c/bottom-type)
                                    (compilation-error (conf-ass _LINE_ new-const loc))

                                    (instance? ProtoImpls curr-const)
                                    se-nop

                                    (set-value-type sym (c/update-path new-const loc))))))))))

(defn remove-value-type [sym]
  (assert (instance? Tagged sym))
  (se/update-in-val [.value-types]
                    (fn [types-list]
                      (either (map (first types-list)
                                   (fn [value-types]
                                     (cons (dissoc value-types (ast/untag sym))
                                           (rest types-list))))
                              types-list))))

(defn merge-constraints [[c1 c2]]
  (cond (and (instance? c/ComputedConstraint c1)
             (instance? c/ComputedConstraint c2))
        (c/merge-mods (.mods c2)
                      (.mods c1)
                      (.mods c2 []))

        (c/intersect c1 c2)))

(defn add-impl [proto-impls type-num arg-count arity-c loc]
  (instance? ProtoImpls proto-impls)

  (either (map (get-in proto-impls [.default-impl .arities arg-count])
               (fn [default-arity]
                 (let [new-params (->  (.param-consts default-arity)
                                       .items
                                       count
                                       range
                                       vec
                                       (map (fn [n]
                                              (c/ParamConstraint (.arity-id arity-c) n
                                                                 empty-list c/no-symbol ""))))
                       default-arity (cond (= (str (.arity-id default-arity)) "")
                                           default-arity

                                           (c/reify-type-constraint default-arity (.arity-id default-arity)
                                                                    new-params loc))
                       new-params (map (zip-lists (c/extract-items-constraints (.param-consts default-arity))
                                                  (c/extract-items-constraints (.param-consts arity-c)))
                                       merge-constraints)
                       new-result (merge-constraints [(.result-const default-arity)
                                                      (.result-const arity-c)])
                       new-arity-c (-> arity-c
                                       (assoc-in [.param-consts .items] (vec new-params))
                                       (.result-const (c/clear-sym new-result)))
                       new-proto (either (or (some new-params (partial = c/bottom-type))
                                             (= new-result c/bottom-type)
                                             (update-in proto-impls [.impl-fns type-num]
                                                        (fn [fn-c]
                                                          (assert (instance? c/FnConstraint fn-c))

                                                          (assoc-in fn-c [.arities arg-count] new-arity-c))))
                                         (assoc-in proto-impls [.impl-fns type-num]
                                                   (.arities c/fn-constraint {arg-count new-arity-c})))]
                   (cond (= new-proto c/bottom-type)
                         (do
                           ;; (status 'impl _LINE_
                           ;;         "\n" 'def default-arity
                           ;;         "\n\n" 'arity arity-c
                           ;;         "\n\n" 'new new-arity-c)
                           (compilation-error (conf-ass _LINE_ new-proto loc)))

                         ;; happy path
                         new-proto))))
          (compilation-error "No prototype for" (str "'" (.fn-sym proto-impls) "'") "with" (str arg-count)
                             "arguments at" loc)))

(defn add-proto-impl [type-num fn-sym arg-count arity-c]
  (assert (instance? Integer type-num))
  (assert (instance? c/fn-arity arity-c))

  (let [loc (ast/location fn-sym)]
    (cond (> 1 type-num)
          (compilation-error "Invalide prototype implementation type-num for" (str "'" fn-sym "'") "at"
                             (ast/location fn-sym))

          (= (str fn-sym) "")
          (do
            (print-err 'compiler-error _LINE_ (str "'" fn-sym "'") (ast/location fn-sym)
                       "\n\n" arity-c)
            (abort))

          ;; TODO: test for namespaced fn-sym
          (comp  (flat-map (se/get-in-val [.value-types 0 (ast/untag fn-sym)])
                           (fn [proto-impls]
                             (let [new-proto (add-impl proto-impls type-num arg-count arity-c loc)]
                               (cond (instance? ProtoImpls new-proto)
                                     (for [vts (se/get-val .value-types)
                                           _ (se/set-val .value-types
                                                         (map vts (fn [m]
                                                                    (assoc m (ast/untag fn-sym) new-proto))))]
                                       new-proto)

                                     ;; add-impl might return a compilation error
                                     new-proto))))

                 (flat-map se-nop
                           (fn [x]
                             (let [core-prom (promise)]
                               (send modules (fn [mods]
                                               (assert (instance? HashMap mods))
                                               (assert-result r (instance? HashMap r))

                                               (let [sym (ast/untag fn-sym)]
                                                 (either (for [val-types-list (get-in mods ['core .value-types])
                                                               val-types (first val-types-list)
                                                               proto-impls (get val-types sym)]
                                                           (let [new-proto (add-impl proto-impls type-num
                                                                                     arg-count arity-c loc)
                                                                 val-types-list (map val-types-list
                                                                                     (fn [m]
                                                                                       (assoc m sym new-proto)))]
                                                             (cond (instance? ProtoImpls new-proto)
                                                                   (do
                                                                     (deliver core-prom se-nop)
                                                                     (assoc-in mods ['core .value-types]
                                                                               val-types-list))

                                                                   (do
                                                                     (deliver core-prom new-proto)
                                                                     mods))))
                                                         (do
                                                           (deliver core-prom 
                                                                    (compilation-error "Could not find protocol for"
                                                                                       (str "'" fn-sym "'")
                                                                                       "at" (ast/location fn-sym)))
                                                           mods)))))
                               (extract core-prom))))))))

(defn get-type-info [type-sym loc]
  ;; TODO: needs to handled namespaced type-sym
  ;; (or (= (.file loc) 'core)
  ;;     (= (.line loc) 0)
  ;;     (do
  ;;       (status 'get-type _LINE_ loc type-sym)
  ;;       (maybe '_)))
  (comp (se/get-in-val [.types (ast/untag type-sym)])
        (flat-map se-nop
                  (fn [_]
                    ;; Look in the core module
                    (let [core-prom (promise)]
                      (send modules (fn [mods]
                                      ;; (or (= (.file loc) 'core)
                                      ;;     (= (.line loc) 0)
                                      ;;     (do
                                      ;;       (status 'get-type _LINE_ loc type-sym "\n"
                                      ;;               (get-in mods ['core .types (ast/untag type-sym)]))
                                      ;;       (maybe '_)))
                                      (either (or (for [core-mod (get mods 'core)
                                                        _ (instance? Promise core-mod)]
                                                    (deliver core-prom se/zero-se))
                                                  (map (get-in mods ['core .types (ast/untag type-sym)])
                                                       (fn [type-inf]
                                                         (deliver core-prom (se/state-error type-inf)))))
                                              (deliver core-prom se/zero-se))
                                      mods))
                      (extract core-prom))))
        (compilation-error "No type named" (str "'" type-sym "'")
                           "was found. Used at" loc)))
(defprotocol TypeChecker
  ;; Change any InferredInner constraint to a CollectionOf
  (promote-inferred [c]
    c)

  (update-constraint [ast constraint loc]
    (compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       "\n" (type-name ast) ast
                       "\n\n" constraint))

  (call-with-args [ast args target]
    (assert (instance? Vector args))
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'call-with-args' at" (ast/location target)
                       "for target:" target
                       "\n" (type-name ast) ast))

  (recover-val-type [x]
    (assert-result x (instance? se/StateError x))

    (se/state-error x))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast))

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       "\n" (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(def ConstrainedAST (any-of ast/params-ast
                            ast/fn-ast
                            ast/fn-arity-ast
                            ast/call-ast
                            ast/let-ast
                            ast/or-ast
                            ast/and-ast
                            ast/either-ast
                            ast/string-ast
                            ast/integer-ast
                            ast/cond-ast
                            ast/quoted-ast
                            ast/tagged-symbol
                            ast/prototype-ast
                            ast/reify-ast
                            ast/block-comment-ast))

(extend-type ConstrainedAST
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c loc))))
              (se/state-error (.constraint ast new-c))))))

(defn all-syms [params]
  (assert (instance? ast/ParamType params))

  (cata all-symbols params))

(defn recover-types [params]
  (assert (instance? ast/params-ast params))

  (ana recover-val-type params se/state-error))

(defn type-check-ast [ast]
  (cond (and (= c/bottom-type ast)
             (first (.constraints ast)))
        (compilation-error (conf-ass _LINE_ ast (ast/location ast)))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                                "\n" 'ast ast
              ;;                                "\n\n" 'new-ast new-ast)))]
              newer-ast (map new-ast type-check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (instance? ast/either-ast ast)
              ;;              (maybe (status 'type-checking _LINE_ loc
              ;;                             "\n\n" 'newer-ast newer-ast)))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and (extract flag)
            ;;        (maybe (print-err 'final-ast _LINE_ loc
            ;;                          "\n" final-ast))))
            final-ast))))

(extend-type Vector
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type c/Constraints
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(extend-type c/fn-arity
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error ast)))

(extend-type c/FnConstraint
  TypeChecker
  (call-with-args [fn-c args target]
    (let [loc (ast/location target)
          num-args (count args)]
      (either (map (and (= target 'show-type)
                        (first args))
                   (fn [arg]
                     (status (c/update-path (.constraint arg) loc)
                             ;; (map (cata c/show-full (c/update-path (.constraint arg) loc))
                             ;;             (partial str  "\n  "))
                             )))
              '_)
      (either (map (or (get-in fn-c [.arities (count args)])
                       (get-in fn-c [.arities c/variadic]))
                   (fn [arity]
                     (assert (instance? c/fn-arity arity))
                     (let [arity-id (.arity-id arity)
                           required-args (count (c/extract-items-constraints (.param-consts arity)))]
                       (cond (< num-args required-args)
                             (compilation-error "Insufficient arguments for call"
                                                (cond (instance? Tagged target)
                                                      (str "to '" target "' at")

                                                      "at")
                                                loc)

                             (let [[fixed-arg-cs var-arg-cs]
                                   (-> args
                                       (map (fn [arg]
                                              (either (map (get arg .constraint)
                                                           (fn [c]
                                                             (cond (instance? c/ComputedConstraint c)
                                                                   (.uses c [])

                                                                   c)))
                                                      (do
                                                        ;; TODO: just for testing.
                                                        ;; Remove
                                                        (status 'no-constraint-arg
                                                                loc _LINE_ arg)
                                                        c/top-type))))
                                       (split required-args))

                                   var-args-c (-> c/empty-list-constraint
                                                  (c/set-items var-arg-cs))
                                   all-arg-cs (conj fixed-arg-cs var-args-c)
                                   reified-arity (c/reify-type-constraint arity arity-id all-arg-cs loc)]
                               ;; (cond (= target 'cons)
                               ;;       (status 'site _LINE_ loc "\n" target arity-id
                               ;;               "\n" 'arity arity
                               ;;               "\n\n" 'all-args all-arg-cs
                               ;;               "\n\n" 'reified reified-arity)

                               ;;       '_)
                               (either (map (-> (cata (fn [c]
                                                        (cond (instance? c/ParamConstraint c)
                                                              c/top-type

                                                              (instance? c/ComputedConstraint c)
                                                              (reduce (.mods c) c/top-type c/intersect)

                                                              (c/is-bottom c)))
                                                      reified-arity)
                                                (= c/bottom-type))
                                            (fn [bad-c]
                                              ;; (status 'site _LINE_ loc arity-id
                                              ;;         "\n" (str "(" (to-str (interpose (cons target (seq args))
                                              ;;                                          " ")) ")")
                                              ;;         "\n\n" 'arity arity
                                              ;;         "\n\n" 'all-args all-arg-cs
                                              ;;         "\n\n" 'reified reified-arity)
                                              (compilation-error (conf-ass _LINE_ bad-c loc))))

                                       (map (-> (zip-lists args
                                                           (c/extract-items-constraints (.param-consts reified-arity)
                                                                                        num-args)
                                                           ;; TODO: only needed for debugging. Remove
                                                           (c/extract-items-constraints (.param-consts arity)
                                                                                        num-args))
                                                (se/traverse
                                                 (fn [[arg param orig-p]]
                                                   ;; (let [p (fn [_]
                                                   ;;          (status 'as-arg _LINE_ loc arity-id
                                                   ;;                 "\n" 'arg arg
                                                   ;;                 "\n\n" 'orig-p orig-p
                                                   ;;                 "\n\n" 'arg-c (.constraint arg)
                                                   ;;                 "\n\n" 'param param))]
                                                   ;;   (either (or (map (= target 'maybe-map) p)
                                                   ;;               (= param c/top-type)
                                                   ;;               (= param (.constraint arg))
                                                   ;;               (instance? c/ParamConstraint (.constraint arg))
                                                   ;;               (instance? c/ComputedConstraint (.constraint arg))
                                                   ;;               (instance? c/ComputedConstraint param))

                                                   ;;           '_))
                                                   (update-constraint arg param loc))))
                                            (fn [new-args]
                                              (let [result (.result-const reified-arity)]
                                                (cond (instance? c/ComputedConstraint result)
                                                      (reduce (.mods result) c/top-type c/intersect)

                                                      result))))))))))
              (compilation-error "No arity found for" (count args) "args for call"
                                 (cond (instance? Tagged target)
                                       (str "to '" target "' at")

                                       "at")
                                 loc)))))

(extend-type c/AllValues
  TypeChecker
  (call-with-args [c args target]
    (se/state-error c/top-type)))

(extend-type c/CallValue
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(extend-type c/Field
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c))

  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (map (either (map (c/extract-sym old-c)
                      (fn [sym]
                        (cond (= (str sym) "")
                              se-nop

                              (append-value-type sym c (ast/location old-c)))))
                 se-nop)
         (fn [_]
           c))))

(extend-type c/GetField
  TypeChecker
  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/DebugConstraint
  TypeChecker
  (type-check [c old-c]
    (either (map (c/extract-sym c)
                 (fn [sym]
                   (append-value-type (ast/tag sym) c (ast/location old-c))))
            (se/state-error c))))

(extend-type c/ParamConstraint
  TypeChecker
  (call-with-args [c args target]
    (-> c
        ;; will never fail
        (c/intersect (c/CallValue (map args .constraint) empty-list c/no-symbol ""))
        (c/update-path (ast/location target))
        se/state-error)))

(extend-type c/ComputedConstraint
  TypeChecker
  (call-with-args [c args target]
    (let [new-c (-> c
                    (c/intersect (c/CallValue (map args .constraint) empty-list c/no-symbol ""))
                    (c/update-path (ast/location target)))]
      (either (map (= new-c c/bottom-type)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c (ast/location target)))))
              (se/state-error new-c)))))

(extend-type c/AllValues
  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: remove this eventually
    (se/state-error ast)))

(extend-type c/NoValues
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type c/ModSeqType
  TypeChecker
  (type-check [c old-c]
    (flat-map (get-value-type (.base-sym old-c))
              (fn [base-c]
                (let [new-c (c/intersect c base-c)]
                  (cond (= c/bottom-type new-c)
                        (compilation-error (conf-ass _LINE_ new-c (ast/location old-c)))

                        (either (map (c/extract-sym old-c)
                                     (fn [sym]
                                       (append-value-type sym new-c (ast/location old-c))))
                                (se/state-error new-c))))))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    ;; TODO: restrict use to fn params only
    (get-value-type (.param-sym old-c))))

(extend-type c/InnerTypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    (cond (instance? Tagged (.param-sym old-c))
          (flat-map (get-value-type (.param-sym old-c))
                    (fn [const-c]
                      (let [new-c (c/intersect const-c c)]
                        (either (or (map (= new-c c/bottom-type)
                                         (fn [_]
                                           (compilation-error (conf-ass _LINE_ new-c (ast/location old-c)))))
                                    (map (c/extract-sym old-c)
                                         (fn [sym]
                                           (append-value-type sym new-c (ast/location old-c)))))
                                (se/state-error new-c)))))

          ;; TODO: this is wrong. This should be done in the reader or something
          (let [new-c (c/intersect (.param-sym c) c)]
            (either (map (= new-c c/bottom-type)
                         (fn [_]
                           (compilation-error (conf-ass _LINE_ new-c (ast/location old-c)))))
                    (se/state-error new-c))))))

(extend-type c/CallValue
  TypeChecker
  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/ArgOf
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location (.fn-sym old-c))]
      (flat-map (get-value-type (.fn-sym old-c))
                (fn [fn-c]
                  (let [new-c (c/intersect fn-c c)]
                    (either (or (map (= new-c c/bottom-type)
                                     (fn [_]
                                       (compilation-error (conf-ass _LINE_ new-c loc))))
                                (map (c/extract-sym c)
                                     (fn [sym]
                                       (append-value-type sym new-c loc))))
                            (se/state-error new-c))))))))

(extend-type c/ResultOf
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location (.fn-sym old-c))]
      (flat-map (get-value-type (.fn-sym old-c))
                (fn [fn-c]
                  (let [new-c (c/intersect fn-c (c/CallValue c/no-args (.path c) (.sym c) (.var c)))]
                    (either (or (map (= new-c c/bottom-type)
                                     (fn [_]
                                       (compilation-error (conf-ass _LINE_ new-c loc))))
                                (map (c/extract-sym c)
                                     (fn [sym]
                                       ;; TODO: this produces a weird runtime error
                                       ;; (let [new-c (c/update-sym new-c sym)]
                                       ;;   (map (append-value-type sym new-c loc)
                                       ;;        (fn [_]
                                       ;;          new-c)))
                                       (append-value-type sym (c/update-sym new-c sym) loc))))
                            (se/state-error new-c))))))))

(extend-type c/ReifiedConstraint
  TypeChecker
  (call-with-args [c args target]
    (flat-map (get-value-type invoke-sym)
              (fn [invoke-impls]
                (call-with-args invoke-impls (comp [target] args) target))))

  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (for [t (get-type-info (.type-sym old-c) loc)
            ;; :let [_ (or ;; (= (.file loc) 'core)
            ;;             ;; (= (.line loc) 0)
            ;;             (do
            ;;               (status 'checking _LINE_ loc (.type-sym old-c)
            ;;                       "\n" t)
            ;;               (maybe '_)))]
            :let [t (c/replace-path t (.path c))]
            t (either (map (c/extract-sym old-c)
                           (fn [sym]
                             (cond (= (str sym) "")
                                   (se/state-error t)
                                   (append-value-type sym
                                                      (c/update-sym t sym)
                                                      (ast/location old-c)))))
                      (se/state-error t))]
        t))))

(extend-type c/NoTail
  TypeChecker
  (type-check [x _]
    (se/state-error x)))

(extend-type Tagged
  TypeChecker
  (param-types [sym]
    (flat-map (get-value-type sym)
              (fn [c]
                (let [c (cond (instance? c/DebugConstraint c)
                              (do
                                (status (to-str (show c)))
                                (.constraint c))

                              c)]
                  (either (map (instance? c/ComputedConstraint c)
                               (fn [c]
                                 (let [param-c (c/full-param-constraint c)]
                                   (cond (= c/bottom-type param-c)
                                         (compilation-error (conf-ass _LINE_ param-c (ast/location sym)))

                                         (se/state-error c)))))
                          (se/state-error c)))))))

(extend-type ast/inline-ast
  TypeChecker
  (type-check [c old-c]
    (se/state-error c)))

(extend-type ast/tagged-symbol
  TypeChecker
  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (all-symbols [ast]
    [ast])

  (recover-val-type [sym]
    (let [sym (ast/untag sym)]
      (flat-map (se/get-in-val [.value-types])
                (fn [types-list]
                  (assert (instance? List types-list))
                  (either (for [value-types (nth types-list 1)
                                prev-constraint (get value-types sym)]
                            (set-value-type sym prev-constraint))
                          (remove-value-type sym))))))

  (type-check [s old-s]
    (map (get-value-type s)
         (fn [c]
           (.constraint s c)))))

(extend-type ast/params-ast
  TypeChecker
  (update-constraint [ast constraint loc]
    (either (map (flat-map (.variadic ast) (partial instance? c/ListConstraint))
                 (fn [_]
                   (status "Compiler error:" _FILE_ _LINE_ "\n" 'variadic (.variadic ast))))
            '_)
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (compilation-error (conf-ass _LINE_ new-c loc))))
              (let [item-cs (c/extract-items-constraints new-c (count (.fixed ast)))
                    tail-item-cs (-> new-c
                                     c/extract-items-constraints
                                     (drop (count (.fixed ast))))
                    tail-c (-> c/list-constraint
                               (c/set-items tail-item-cs)
                               (c/set-tail (c/extract-tail-constraint new-c))
                               (c/replace-path (.path new-c)))]
                (for [_ (se/traverse (zip-lists (seq (.fixed ast)) item-cs)
                                     (fn [[ast c]]
                                       (update-constraint ast c loc)))
                      _ (either (map (.variadic ast)
                                     (fn [v-ast]
                                       (assert (instance? ast/ParamType v-ast))
                                       (update-constraint v-ast tail-c loc)))
                                se-nop)]
                  (.constraint ast new-c))))))

  (all-symbols [params]
    (comp* (either (.variadic params)
                   [])
           (seq (.fixed params))))

  (param-types [params]
    (-> c/seq-constraint
        (c/set-tail (either (.variadic params)
                            c/no-tail))
        (c/set-items (.fixed params))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> c/seq-constraint
                (c/set-items (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (either (for [var-param (.variadic old-ast)
                    :when (instance? Tagged var-param)]
                (let [var-c (-> c/list-constraint
                                (c/update-path (ast/location var-param)))]
                  (map (append-value-type var-param var-c (ast/location var-param))
                       (fn [_]
                         (-> ast
                             (.constraint (c/set-tail c c/coll-of-any))
                             (.variadic (maybe (.constraint (ast/tag var-param) var-c))))))))
              (se/state-error (.constraint ast c))))))

(defn get-param-types [params]
  (assert (instance? ast/params-ast params))

  (map (cata param-types params se/state-error)
       (fn [c]
         (let [c (c/trim c)]
           (-> c/list-constraint
               (c/set-items (c/extract-items-constraints c))
               (c/set-tail (c/extract-tail-constraint c)))))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (gensym "fn-arity")
                         (.fn-var ast))
          loc (ast/location ast)]
      (for [_ (push-types)
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;          (and (= (.fn-sym ast) 'maybe-map)
            ;;               (do
            ;;                 (status 'pre-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'params (.params ast)
            ;;                         "\n\n" 'body "[" (to-str (interpose (.body ast) "\n\n")) "]"
            ;;                         "\n\n" 'const (.constraint ast))
            ;;                 nothing)))]
            _ (set-value-type ast/result-sym c/top-type)
            _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                      (set-value-type sym c/top-type)))
            _ (se/traverse (zip-lists fixed-params (range arg-count))
                           (fn [[sym index]]
                             (cond (instance? ast/params-ast sym)
                                   se-nop

                                   (append-value-type sym
                                                      (c/ParamConstraint arity-id index
                                                                  empty-list (ast/untag sym) "")
                                                      loc))))
            _ (either (for [variadic-sym (.variadic (.params ast))]
                        (append-value-type variadic-sym
                                           (c/ParamConstraint arity-id arg-count
                                                       empty-list (ast/untag variadic-sym) "")
                                           loc))
                      se-nop)]
        (-> ast
            (.fn-var arity-id)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (partial instance? c/Constraints))
                             (remove (partial instance? ast/block-comment-ast)))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (get-value-type ast/result-sym)
            _ (recover-val-type ast/result-sym)
            pts (get-param-types (.params old-ast))
            _ (recover-types (.params old-ast))
            _ (nip-types)
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;          (and (= (.fn-sym ast) 'drop-while)
            ;;               (do
            ;;                 (status 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                         "\n" 'pts pts
            ;;                         "\n\n" 'result result-c)
            ;;                 nothing)))]
            :let [result-c (-> (either (map (last (.body ast)) .constraint)
                                       c/top-type)
                               (c/intersect result-c))
                  result-c (either (map (instance? c/DebugConstraint result-c)
                                        (fn [c]
                                          (status (to-str (cons "Result type" (drop (show c) 2))))
                                          (.constraint c)))
                                   result-c)
                  result-c (c/clear-sym result-c)]
            _ (either (map (or (= c/bottom-type pts)
                               (= c/bottom-type result-c))
                           (fn [failure-c]
                             ;; (print-err 'arity _LINE_ loc (.fn-sym old-ast)
                             ;;            "\n" 'pts pts
                             ;;            "\n\n" 'result-c result-c
                             ;;            "\n\n" 'body (either (map (last (.body ast)) .constraint)
                             ;;                                 c/top-type)
                             ;;            "\n\n" 'rc rc)
                             (compilation-error (conf-ass _LINE_ failure-c loc))))
                      se-nop)]
        ;; TODO: use update-constraint here
        (.constraint ast (c/intersect (.constraint ast)
                                      (c/fn-arity (.fn-var ast) pts result-c)))))))

(extend-type ast/fn-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) 'core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  "\n" ast)
      ;;       nothing))
      (either (map (.fn-sym ast)
                   (fn [sym]
                     (for [_ (push-types)
                           _ (set-value-type sym (-> c/fn-constraint
                                                     (c/update-path loc)
                                                     (c/update-sym (ast/untag sym))))]
                       (.arities ast (map (.arities ast)
                                          (fn [arity]
                                            (.fn-sym arity sym)))))))
              (map (push-types)
                   (fn [_]
                     ast)))))

  (type-check [ast old-ast]
    (let [fn-c (either (map (.fn-sym ast)
                            (fn [sym]
                              (-> c/fn-constraint
                                  (c/update-path (ast/location sym))
                                  (c/update-sym (ast/untag sym)))))
                       c/fn-constraint)
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (get-in arity-c [.param-consts .tail-c])
                                         :when (= c/no-tail variadic)
                                         fixed-params (get-in arity-c [.param-consts .items])]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) 'core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) "\n" fn-c)
      ;;         nothing)))
      (flat-map (nip-types)
                (fn [_]
                  (se/state-error (.constraint ast fn-c)))))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or (= (.line loc) 0)
    ;;       ;; (= (.file loc) 'core)
    ;;       (do
    ;;         (print-err 'checking ast)
    ;;         nothing)))
    (for [_ (push-types)]
      (.value-exprs ast (-> (.value-exprs ast)
                            (remove (partial instance? ast/block-comment-ast))
                            (map (fn [inner-ast]
                                   (cond (instance? ast/fn-ast inner-ast)
                                         (.fn-sym inner-ast (maybe (.sym ast)))

                                         (instance? c/SymbolConstraints inner-ast)
                                         (c/update-sym inner-ast (ast/untag (.sym ast)))

                                         inner-ast)))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))]
      (for [_ (pop-types)
            c (either (map (last (.value-exprs ast))
                           (fn [val]
                             (let [sym (.sym old-ast)]
                               (cond (instance? c/Constraints val)
                                     ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                     ;; the updated version. Possibly a bug in assoc-in*

                                     ;; TODO: this version produces a very cryptic error message
                                     ;; (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                     ;;           (set-value-type (.sym old-ast) val))

                                     (flat-map (se/assoc-in-val [.types (ast/untag sym)] val)
                                               (fn [_]
                                                 (set-value-type sym val)))

                                     (and (= c/top-type (.constraint val))
                                          (or (= sym 'empty-list)
                                              (= sym 'empty-vector)
                                              (= sym 'int-max)
                                              (= sym 'int-min)
                                              ;; (= sym 'nothing)
                                              ))
                                     (flat-map (get-value-type sym)
                                               (fn [c]
                                                 (set-value-type sym (c/update-path c loc))))

                                     (set-value-type sym (.constraint val))))))
                      (set-value-type (.sym old-ast) c/top-type))]
        (do
          ;; (status 'def _LINE_ loc (.sym old-ast) "\n" c)
          ast)))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          fixed-params (-> ast .params .fixed)
          arg-count (count fixed-params)
          all-param-syms (remove (all-syms (.params ast))
                                 (partial = (ast/tag '_)))]
      (cond (< (count (set all-param-syms)) (count all-param-syms))
            (compilation-error "Duplicate parameter names in prototyp at" loc)

            (for [_ (comp (se/get-in-val [.value-types 0 (ast/untag (.fn-name ast)) .default-impl])
                          (set-value-type (.fn-name ast)
                                          (ProtoImpls (ast/untag (.fn-name ast))
                                                      (.arities c/fn-constraint {}) {})))
                  _ (push-types)
                  _ (set-value-type ast/result-sym c/top-type)
                  ;; :let [_ (or ;; (= (.line loc) 0)
                  ;;             ;; (= (.file loc) 'core)
                  ;;          (and (= (.fn-name ast) 'hash-seq)
                  ;;               (do
                  ;;                 (print-err 'pre-prototype _LINE_ (.fn-name ast) (ast/location ast)
                  ;;                            "\n" 'body (.default-body ast))
                  ;;                 nothing)))]
                  _ (se/traverse all-param-syms
                                 (fn [sym]
                                   (set-value-type sym c/top-type)))
                  _ (se/traverse (zip-lists fixed-params (range arg-count))
                                 (fn [[sym index]]
                                   (cond (instance? ast/params-ast sym)
                                         ;; TODO: this probably needs expanding
                                         se-nop

                                         (= sym '_)
                                         (set-value-type sym c/top-type) 

                                         (append-value-type sym
                                                            (c/ParamConstraint (.fn-name ast) index
                                                                               empty-list (ast/untag sym) "")
                                                            loc))))]
              ast))))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))]
      (for [pts (get-param-types (.params old-ast))
            result-c (se/try
                       (get-value-type ast/result-sym)
                       (fn [_]
                         (se/state-error c/top-type)))
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) 'core)
            ;;          (and (= (.fn-name ast) 'invoke)
            ;;               (= arg-count 2)
            ;;               (do
            ;;                 (print-err 'check-prototype _LINE_ (.fn-name ast) (ast/location ast)
            ;;                            "\n" 'pts pts
            ;;                            "\n\n" 'result result-c)
            ;;                 nothing)))]
            :let [impl-c (c/fn-arity (ast/untag (.fn-name old-ast)) pts (c/clear-sym result-c))]
            _ (remove-value-type ast/result-sym)
            _ (recover-types (.params old-ast))
            _ (nip-types)
            _ (se/update-in-val [.value-types]
                                (fn [types-list]
                                  (let [sym (ast/untag (.fn-name ast))]
                                    (either (map (first types-list)
                                                 (fn [value-types]
                                                   (cons (assoc-in value-types
                                                                   [sym .default-impl .arities arg-count]
                                                                   impl-c)
                                                         (rest types-list))))
                                            (list {sym (ProtoImpls sym
                                                                   (.arities c/fn-constraint {arg-count impl-c})
                                                                   {})})))))]
        (.constraint ast impl-c)))))

(extend-type ast/protocol-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/call-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [loc (ast/location (.call-target old-ast))]
      (for [
            ;; _ (se/when (or ;; (= (.line loc) 0)
            ;;                ;; (= (.file loc) 'core)
            ;;                (and (= (.call-target old-ast) 'mutate-vect-conj)
            ;;                     (do
            ;;                       (status 'calling-top _LINE_ loc
            ;;                               "\n" 'target (.call-target ast)
            ;;                               "\n\n" 'target-c (.constraint (.call-target ast))
            ;;                               "\n\n" 'args (str "[" (-> (.args ast)
            ;;                                                         (map .constraint)
            ;;                                                         (interpose  "\n")
            ;;                                                         to-str)
            ;;                                                 "]"))
            ;;                       nothing))
            ;;                (maybe '_)))

            ;; TODO: replace all this garbage using ArgOf and ResultOf
            result-type (call-with-args (-> ast .call-target .constraint) (.args ast) (.call-target ast))
            ;; _ (se/when (or ;; (= (.line loc) 0)
            ;;                ;; (= (.file loc) 'core)
            ;;                (and (= (.call-target old-ast) 'mutate-vect-conj)
            ;;                     (do
            ;;                       (status 'calling-result _LINE_ loc
            ;;                               "\n" 'result-type result-type)
            ;;                       nothing))
            ;;                (maybe '_)))
            _ (either (map (and (= c/bottom-type result-type)
                                (first (.constraints result-type)))
                           (fn [_]
                             (compilation-error (conf-ass _LINE_ result-type loc))))
                      se-nop)]
        (-> ast
            (.args (.args ast))
            (.constraint result-type))))))

(extend-type ProtoArity
  TypeChecker
  (pre-check [pa]
    (for [_ (push-types)]
      pa))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          _ (add-proto-impl (.type-num ast)
                            (-> old-ast .arity .fn-sym)
                            (-> old-ast .arity .params .fixed count)
                            (.constraint (.arity ast)))]
      ast)))

(extend-type ast/reify-ast
  TypeChecker
  (pre-check [ast]
    (let [reified-type-num (either (.type-num ast)
                                   (extract type-counter))]
      (-> ast
          (.type-num (maybe reified-type-num))
          (map (fn [arity]
                 (ProtoArity reified-type-num arity)))
          se/state-error)))

  (type-check [ast old-ast]
    (let [invoke-arities (either (map (get-in ast [.impls Function-sym invoke-sym])
                                      (fn [arities]
                                        (reduce arities {}
                                                (fn [m arity]
                                                  (assoc m (count (.fixed (.params (.arity arity))))
                                                         (.constraint (.arity arity)))))))
                                 {})]
      (-> ast
          (map .arity)
          (.constraint (c/ReifiedConstraint (extract (.type-num ast)) {}
                                            (symbol (str "reified value at "
                                                         (ast/location ast)))
                                            (.arities c/fn-constraint invoke-arities)
                                            empty-list c/no-symbol ""))
          se/state-error))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (for [type-info (get-type-info (.type ast) (ast/location ast))
          ;; TODO: for SumConstraint, don't allow re def of proto impl
          :let [type-infos (cond (instance? c/SumConstraint type-info)
                                 (.alts type-info)
                                 [type-info])]
          new-ast (map ast
                       (fn [arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (either (-> (.params arity)
                                     .fixed
                                     first 
                                     (map (fn [first-param]
                                            ;; (print-err 'params _LINE_ (ast/location first-param)
                                            ;; first-param)
                                            (let [disp-param (ast/untag first-param)]
                                              (-> type-infos
                                                  (map (fn [type-info]
                                                         (let [type-info (c/update-sym type-info disp-param)
                                                               new-bod (comp [type-info] (.body arity))]
                                                           (ProtoArity (c/get-type-num type-info)
                                                                       (.body arity new-bod)))))
                                                  se/state-error)))))
                                 (compilation-error "Prototype implentation for "
                                                    (str "'" (.fn-sym arity) "'")
                                                    "must have at least one parameter at"
                                                    (ast/location (.fn-sym arity)))))
                       se/state-error)]
      (-> (either (get new-ast .impls)
                  {})
          vals
          vec
          (map vals)
          (map vec))))

  (type-check [ast old-ast]
    (se/state-error (map ast .arity))))

(extend-type ast/binding-ast
  TypeChecker
  (pre-check [ast]
    (for [
          ;; _ (map se-nop
          ;;        (fn [_]
          ;;          (let [loc (ast/location ast)]
          ;;            (or (= (.line loc) 0)
          ;;                (= (.file loc) 'core)
          ;;                (do
          ;;                  (status 'binding-type-check _LINE_ loc
          ;;                             "\n" 'ast ast)
          ;;                  nothing)))))
          _ (se/traverse (all-syms (.binding ast)) (fn [sym]
                                                     (set-value-type sym c/top-type)))]
      ast))

  (type-check [ast old-ast]
    (for [_ (push-types)
          ;; :let [loc (ast/location ast)
          ;;       _ (or ;; (= (.line loc) 0)
          ;;             ;; (= (.file loc) 'core)
          ;;             (do
          ;;               (status 'binding-type-check _LINE_ loc
          ;;                          "\n" 'binding-ast (type-name (.binding ast)) (.binding ast)
          ;;                          "\n\n" 'val-c (.constraint (.val ast)))
          ;;               nothing))]
          new-binding (update-constraint (.binding ast) (.constraint (.val ast)) (ast/location old-ast))]
      (.binding ast new-binding))))

(extend-type ast/let-ast
  TypeChecker
  (pre-check [ast]
    ;; (let [loc (ast/location ast)]
    ;;   (or ;; (= (.line loc) 0)
    ;;       ;; (= (.file loc) 'core)
    ;;       (do
    ;;         (status 'let _LINE_ loc
    ;;                    "\n" ast)
    ;;         nothing)))
    (-> ast
        (.body (remove (.body ast)
                       (partial instance? ast/block-comment-ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (se/traverse (reverse (.bindings ast))
                         (fn [binding-ast]
                           (let [binding (.binding binding-ast)
                                 val (.val binding-ast)]
                             (for [val-c (cata param-types binding se/state-error)
                                   _ (se/traverse (all-syms binding) recover-val-type)
                                   _ (update-constraint val val-c (ast/location binding))
                                   ;; :let [loc (ast/location old-ast)
                                   ;;       _ (or ;; (= (.line loc) 0)
                                   ;;             ;; (= (.file loc) 'core)
                                   ;;          (do
                                   ;;            (status 'let _LINE_ loc
                                   ;;                    "\n" 'binding (type-name binding) binding
                                   ;;                    "\n\n" 'val val
                                   ;;                    "\n\n" 'orig-val-c (.constraint val)
                                   ;;                    "\n\n" 'val-c val-c)
                                   ;;            nothing))]
                                   _ (nip-types)]
                               '_))))]
      (let [result-c (either (map (last (.body ast)) .constraint)
                             c/top-type)]
        (.constraint ast (c/clear-sym result-c))))))

(deftype AndClause [clause types]
  Stringable
  (string-list [_]
    (list "(AndClause " (str clause) ")"))

  Container
  (map [_ f]
    (AndClause (f clause) types))

  (map [c f embed]
    (map (f clause)
         (partial .clause c)))

  ast/FileLoc
  (ast/location [_]
    (ast/location clause))

  TypeChecker
  (type-check [ast old-ast]
    (for [new-clause (update-constraint (.clause ast) c/maybe-constraint (ast/location old-ast))
          types (get-types)]
      (AndClause new-clause types))))

(deftype OrClause [clause types]
  Stringable
  (string-list [_]
    (list "(OrClause " (str clause) " {})"))

  Container
  (map [_ f]
    (OrClause (f clause) types))

  (map [c f embed]
    (map (f clause)
         (partial .clause c)))

  ast/FileLoc
  (ast/location [_]
    (ast/location clause))

  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (let [loc (ast/location old-ast)]
      (for [new-clause (update-constraint (.clause ast) c/maybe-constraint loc)
            types (pop-types)]
        (OrClause new-clause types)))))

(extend-type ast/or-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clauses (-> (.clauses ast)
                      (remove (partial instance? ast/NoCode))
                      (map (fn [clause]
                             (OrClause clause c/top-type)))))
        se/state-error))

  (type-check [ast old-ast]
    (either (map (first (.clauses ast))
                 (fn [first-clause]
                   (for [_ (pop-types)
                         _ (push-types (.types first-clause))
                         ;; TODO: when the ast of the first clause is a call to instance?,
                         ;; recover the type of the symbol in the second arg
                         ]
                     (-> ast
                         (.clauses (map (.clauses ast) .clause))
                         (.constraint (-> (.clauses ast)
                                          (map (comp .constraint .clause))
                                          c/sum-type
                                          (c/update-path (cata ast/location old-ast))))))))

            (se/state-error (.constraint ast (c/update-path c/maybe-constraint (cata ast/location old-ast)))))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clauses (-> (.clauses ast)
                      (remove (partial instance? ast/NoCode))
                      (map (fn [clause]
                             (AndClause clause c/top-type)))))
        se/state-error))

  (type-check [ast old-ast]
    (either (for [first-clause (first (.clauses ast))
                  last-clause (last (.clauses ast))]
              (for [_ (pop-types)
                    _ (push-types (.types first-clause))
                    ;; TODO: when the ast of the first clause is a call to instance?,
                    ;; recover the type of the symbol in the second arg
                    ]
                (-> ast
                    (.clauses (map (.clauses ast) .clause))
                    (.constraint (.constraint (.clause last-clause))))))
            (se/state-error (.constraint ast (-> c/maybe-constraint
                                                 (c/update-path (ast/location old-ast))))))))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.clause (OrClause (.clause ast) {}))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (pop-types)
          _ (push-types (.types (.clause ast)))]
      (let [new-clause (.clause (.clause ast))]
        (-> ast
            (.clause new-clause)
            (.constraint (-> (c/sum-type [(c/extract-contents-constraint (.constraint new-clause))
                                          (.constraint (.alt ast))])
                             (c/update-path (ast/location old-ast)))))))))
(extend-type ast/string-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (se/state-error (.constraint ast (.static-value c/strbuff-constraint str-val))))))

(extend-type ast/integer-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error (.constraint ast (-> c/int-constraint
                                         (.static-value (.int old-ast))
                                         (c/update-path (ast/location old-ast)))))))

(extend-type ast/cond-val-ast
  TypeChecker
  (pre-check [ast]
    (map (push-types)
         (fn [_]
           ast)))

  (type-check [ast old-ast]
    (for [new-condit (update-constraint (.conditional ast) c/maybe-constraint (ast/location old-ast))
          types (pop-types)]
      ;; TODO: not convinced this is right
      ;; (.conditional ast new-condit)
      (.types ast types))))

(extend-type ast/cond-ast
  TypeChecker
  (type-check [ast old-ast]
    (let [conditionals (.conditionals ast)]
      ;; TODO: will break when there's only the default clause in the cond
      (either (map (first conditionals)
                   (fn [first-cond]
                     (for [_ (pop-types)
                           _ (push-types (.types first-cond))]
                       (.constraint ast (-> (.conditionals ast)
                                            (map (fn [c]
                                                   (.constraint (.value c))))
                                            (conj (.constraint (.default ast)))
                                            c/sum-type)))))
              (se/state-error (.constraint ast (.constraint (.default ast))))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      'ResultConstraint c/ResultConstraintType
                      'InferredInner c/InferredInnerType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract type-counter)))

(deftype DestructFields [fields]
  (assert (instance? (vector-of Symbol) fields))

  Stringable
  (string-list [_]
    (list "(DestructFields " (to-str fields) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (type-check [ast old-ast]
    ;; TODO: need to destructure the fields here
    (se/state-error ast)))

(def x* (ast/tag "#x"))
(def y* (ast/tag "#y"))
(def field* (ast/tag "#field"))
(def ctxt* (ast/tag "#ctxt"))

(defn default-type-impls [type-sym fields]
  (let [loc (ast/location type-sym)]
    ;; TODO: make sure the constraints on all these fn's are as specific as possible
    {Type-sym
     {type-name-sym
      {1 (ast/fn-arity
          (ast/tag type-name-sym loc)
          (ast/params [x*]) ""
          [(ast/string-ast (str type-sym) (.file loc) (.line loc) c/string-constraint)])}

      has-field-sym
      {2 (ast/fn-arity
          (ast/tag has-field-sym loc)
          (ast/params [x* field*]) ""
          [(ast/and-expr
            [(ast/or-expr
               (conj (map fields
                          (fn [field]
                            (ast/call-expr [identical-sym
                                            (ast/tag (str "." field) loc)
                                            field*])))
                     nothing-sym))
             (ast/call-expr [maybe-sym x*])])])}}

     Eq-sym
     {=*-sym
      {2 (ast/fn-arity
          (ast/tag =*-sym loc)
          (ast/params [x* y*]) ""
          [(ast/and-expr
            [(ast/call-expr [=*-sym (ast/call-expr [get-type-sym x*])
                             (ast/call-expr [get-type-sym y*])])
             (ast/call-expr [=*-sym (ast/call-expr [default-type-args-sym x*])
                             (ast/call-expr [default-type-args-sym y*])])
             (ast/call-expr [maybe-sym x*])])])}}

     Associative-sym
     {get-symb
      {2 (ast/fn-arity
          (ast/tag get-symb loc)
          (ast/params [x* field*]) ""
          [ ;; (c-code "" ["// TODO: this seems to do runtime checks for 'has-field' result\n// and the result returned\n"]
           ;;         {} c/top-type)
           (ast/and-expr
            [(ast/call-expr [(ast/tag has-field-sym loc) x* field*])
             (ast/call-expr [maybe-sym
                             (ast/call-expr [field* x*])])])])}

      assoc-sym
      {3 (ast/fn-arity
          (ast/tag assoc-sym loc)
          (ast/params [x* field* (ast/tag 'new-value)]) ""
          [(ast/cond-expr
            [(ast/cond-val-expr (ast/call-expr [(ast/tag has-field-sym loc) x* field*])
                                (ast/call-expr [field* x* (ast/tag 'new-value)]))]
            x*)])}}

     Hashable-sym
     {sha1-update-sym
      {2 (ast/fn-arity
          (ast/tag sha1-update-sym loc)
          (ast/params [x* ctxt*]) ""
          [(ast/call-expr [sha1-update-type-sym x* ctxt*])
           (ast/call-expr [sha1-update-sym (ast/call-expr [default-type-args-sym x*]) ctxt*])])}

      sha1-sym
      {1 (ast/fn-arity
          (ast/tag sha1-sym loc)
          (ast/params [x*]) ""
          [(ast/call-expr
            [sha1-finalize-sym
             (ast/call-expr
              [sha1-update-sym x*
               (ast/call-expr [sha1-init-sym])])])])}}}))

(defn create-getters [sym type-num new-type-constraint fields field-constraints]
  (let [type-value (ast/tag "#value")
        field-arg (ast/tag "#field")
        loc (ast/location sym)]
    ;; TODO: make sure the constraints on all these fn's are as specific as possible
    {Type-sym
     (-> (zip-lists (seq fields) (range (count fields)) field-constraints)
         (map (fn [[field field-index field-constraint]]
                (let [field-sym (-> (str "." field) symbol c/Field)]
                  [(ast/tag (.sym field-sym) loc)
                   [;; setter arity
                    (let [arity-id (symbol (str sym "-" field "-setter"))
                          field-constraint (c/update-path field-constraint loc)]
                      (ast/fn-arity-ast
                       (ast/tag (str "." field) loc)
                       arity-id (ast/params [type-value field-arg]) ""
                       [(ast/inline-ast (ast/tag 'C) c/top-type
                                        (str "return(updateField(value_0, field_1, "
                                             field-index "));\n")
                                        "" 0)]
                       (c/fn-arity
                        arity-id
                        (-> c/list-constraint
                            (c/set-items [new-type-constraint field-constraint]))
                        (-> (c/ParamConstraint arity-id 0 empty-list c/no-symbol "")
                            (c/intersect (c/set-field field-sym
                                                      (c/ParamConstraint arity-id 1 empty-list c/no-symbol "")))))))

                    ;; getter arity
                    (let [arity-id (symbol (str sym "-" field "-getter"))
                          field-constraint (-> (c/ParamConstraint arity-id 0 empty-list c/no-symbol "")
                                               (c/intersect (c/get-field field-sym))
                                               (c/intersect field-constraint)
                                               c/clear-sym)]
                      (ast/fn-arity-ast
                       (ast/tag (str "." field) loc)
                       arity-id (ast/params [type-value]) ""
                       [(ast/inline-ast (ast/tag 'C) field-constraint
                                        (str "
  Value *result = incRef(((ReifiedVal *)value_0)->impls[" field-index "], 1);
  dec_and_free(value_0, 1);
  return(result);
")
                                        "" 0)]
                       (c/fn-arity
                        arity-id
                        (-> c/empty-list-constraint
                            (c/set-items [new-type-constraint]))
                        field-constraint)))]])))
         (reduce {} (fn [m [k v]]
                      (assoc m k v))))}))

;; TODO: every place that calls this needs to refactored
(defn constrain-first-param [type-info c]
  (cond (instance? ast/fn-arity-ast c)
        (either (-> (.params c)
                    .fixed
                    first
                    (map (fn [first-param]
                           ;; (print-err 'params _LINE_ (ast/location first-param)
                           ;; first-param)
                           (let [disp-param (ast/untag first-param)]
                             (let [type-info (c/update-sym type-info disp-param)
                                   new-bod (comp [type-info] (.body c))]
                               (ProtoArity (c/get-type-num type-info)
                                           (.body c new-bod)))))))

                (do
                  ;; (compilation-error "Prototype implentation for "
                  ;;                    (str "'" (.fn-sym c) "'")
                  ;;                    "must have at least one parameter at"
                  ;;                    (ast/location (.fn-sym c)))
                  (print-err 'BOOOMMMM _LINE_ c)
                  (abort)
                  c))

        (instance? List c)
        (vec c)

        c))

(deftype CreateGetters [sym type-num new-type-constraint fields loc]
  Stringable
  (string-list [_]
    (list "(CreateGetters " (str sym) " " (to-str fields) " " (str loc) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (map (se/traverse fields (fn [field]
                               (for [_ (get-value-type (ast/tag (str "." field) loc))
                                     field-info (get-value-type field)]
                                 (cata promote-inferred field-info))))
         (fn [field-cs]
           (let [impls (-> (create-getters (ast/untag sym) type-num new-type-constraint fields field-cs)
                           vals
                           (map vals))]
             (cata (fn [c]
                     (constrain-first-param new-type-constraint c))
                   impls))))))

(defn create-constructor [new-type-name type-num new-type-constraint field-constraints fields]
  (assert (instance? ast/tagged-symbol new-type-name))
  (assert (instance? c/ReifiedConstraint new-type-constraint))
  (assert (instance? c/ListConstraint field-constraints))
  (assert (instance? (vector-of Symbol) fields))

  (let [loc (ast/location new-type-name)
        field-count (count fields)
        reified-type-num (extract type-counter)
        field-params (-> (comp ['_]
                               (map (range field-count)
                                    (fn [n]
                                      (ast/tag (str "arg" n)))))
                         (map (fn [arg]
                                (ast/tag arg loc)))
                         ast/params)]
    ;; TODO: this causes a parsing error
    ;; (ast/reified (maybe reified-type-num)
    ;;              {
    ;;               })

    ;; TODO: make sure the constraints on all these fn's are as specific as possible
    (ast/reified (maybe reified-type-num)
                 {Eq-sym
                  {(ast/tag =*-sym loc)
                   [(ast/fn-arity
                     (ast/tag =*-sym loc)
                     (ast/params [x* y*]) ""
                     [(ast/and-expr
                       [(ast/call-expr [=*-sym (ast/integer-ast type-num "" 0
                                                                (-> c/int-constraint
                                                                    (.static-value type-num)
                                                                    (c/update-path loc)))
                                        (ast/call-expr [get-type-sym y*])])
                        (ast/call-expr [maybe-sym y*])])])]}

                  Type-sym
                  {type-name-sym
                   [(ast/fn-arity
                     (ast/tag type-name-sym loc)
                     (ast/params [(ast/tag '_)]) ""
                     (let [s (str "* " new-type-name " constructor at " (.file loc) ": " (.line loc) " *")]
                       [(ast/string-ast s "" 0 (cata (fn [c]
                                                       (cond (or (instance? c/StrBuffConstraint c)
                                                                 (instance? c/SubStrConstraint c))
                                                             (.static-value c s)

                                                             c))
                                                     c/string-constraint))]))]

                   ;; TODO: put back in
                   ;; type-mapping-sym
                   ;; [(ast/fn-arity
                   ;;   (ast/tag (str new-type-name "_const_type_map") loc)
                   ;;   (ast/params [(ast/tag '_)]) ""
                   ;;   [(map-vals (.type-maps new-type-constraint)
                   ;;              (fn [field-set]
                   ;;                (map (keys field-set) ast/quoted-ast)))])]

                   instance?-sym
                   [(ast/fn-arity-ast
                     (ast/tag instance?-sym loc) ""
                     (ast/params [x* y*]) ""
                     [;; TODO: remove all inline assertions
                      ;; add constraints to arity struct
                      (ast/and-expr
                       [(ast/call-expr [=*-sym
                                        (ast/integer-ast type-num "" 0
                                                         (-> c/int-constraint
                                                             (.static-value type-num)
                                                             (c/update-path loc)))
                                        (ast/call-expr [get-type-sym y*])])
                        (ast/call-expr [maybe-sym y*])])]
                     (let [arity-id (symbol (str new-type-name "_instance_QM_"))]
                       (c/fn-arity
                        arity-id
                        (.items field-constraints [c/top-type c/top-type])
                        (-> new-type-constraint
                            (c/intersect (c/ParamConstraint arity-id 1
                                                     empty-list c/no-symbol ""))
                            (c/CollectionOf empty-list c/no-symbol "")
                            (c/intersect c/maybe-constraint)))))]}

                  Function-sym
                  {invoke-sym
                   (let [arity-id (symbol (str new-type-name "_invoke"))]
                     [(ast/fn-arity-ast
                       (ast/tag invoke-sym loc)
                       arity-id field-params ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "ReifiedVal *rv = malloc_reified("
                                             field-count ");\n"
                                             "#ifdef SINGLE_THREADED\n"
                                             "rv->refs = refsInit;\n#else\n"
                                             " __atomic_store(&rv->refs,"
                                             " &refsInit, __ATOMIC_RELAXED);\n"
                                             "#endif\n"
                                             "rv->type = " type-num ";\n"
                                             (to-str (map (range field-count)
                                                          (fn [idx]
                                                            (str "rv->impls[" idx "] = arg" idx
                                                                 "_" (inc idx) ";\n"))))
                                             "return((Value *)rv);\n")
                                        "" 0)]
                       (c/fn-arity
                        arity-id
                        (.items field-constraints (comp [c/top-type]
                                                        (.items field-constraints)))
                        (.fields new-type-constraint
                                 (merge-with c/intersect
                                             (.fields new-type-constraint)
                                             (-> (zip-lists fields (range (count fields)))
                                                 (reduce {} (fn [m [fld idx]]
                                                              (assoc m (c/Field (symbol (str "." fld)))
                                                                     (c/ParamConstraint
                                                                      arity-id (inc idx)
                                                                      empty-list c/no-symbol "")))))))))])}

                  Container-sym
                  {apply-sym
                   (let [arity-id (symbol (str new-type-name "_apply"))]
                     [(ast/fn-arity-ast
                       (ast/tag apply-sym loc)
                       arity-id (ast/params [(ast/tag '_ loc)
                                             (ast/tag 'fields loc)])
                       ""
                       [(ast/inline-ast (ast/tag 'C)
                                        new-type-constraint
                                        (str "return(newTypeValue(" type-num ", (Vector *)fields_1));")
                                        "" 0)]
                       (c/fn-arity
                        arity-id
                        (-> c/list-constraint
                            (c/set-items [c/top-type field-constraints]))
                        (.fields new-type-constraint
                                 (merge-with c/intersect
                                             (.fields new-type-constraint)
                                             (-> (zip-lists fields (range (count fields)))
                                                 (reduce {} (fn [m [fld idx]]
                                                              (assoc m (c/Field (symbol (str "." fld)))
                                                                     (c/intersect
                                                                      (c/ParamConstraint arity-id 1 empty-list
                                                                                         c/no-symbol "")
                                                                      (c/GetField idx))))))))))])}

                  Stringable-sym
                  (let [s (str "<ValueConstructor " new-type-name " ["
                               (to-str (interpose fields ", "))
                               "]>")]
                    {string-list-sym
                     [(ast/fn-arity
                       (ast/tag string-list-sym loc)
                       (ast/params [(ast/tag 'z)]) ""
                       [(ast/call-expr [list-sym
                                        (ast/string-ast s "" 0 (cata (fn [c]
                                                                       (cond (or (instance? c/StrBuffConstraint c)
                                                                                 (instance? c/SubStrConstraint c))
                                                                             (.static-value c s)

                                                                             c))
                                                                     c/string-constraint))])])]})})))

(deftype CheckedTypeAST [sym type-num new-type-constraint fields impls]
  Stringable
  (string-list [_]
    (list "(CheckedTypeAST " (str sym) " " (str fields) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  TypeChecker
  (pre-check [ast]
    (for [field-types (get-param-types (ast/params fields nothing))
          ;; _ (se/traverse fields (fn [field]
          ;;                         (for [field-c (get-type-constraint field)]
          ;;                           (print-err 'field (.sym ast) field field-c))))
          _ (se/traverse fields recover-val-type)
          invoke-impls (get-value-type invoke-sym)
          _ (nip-types)
          _ (push-types)]
      (let [invoke-arities (-> (either (get-in invoke-impls [.ast .impls type-num])
                                       {})
                               vec
                               (reduce {} (fn [arities [k v]]
                                            (assoc arities k (c/fn-arity (.fn-var v)
                                                                         (.param-consts v)
                                                                         (.result-const v))))))]
        (ast/definition-ast sym [(create-constructor sym type-num
                                                     (.invoke-fn new-type-constraint
                                                                 (.arities c/fn-constraint invoke-arities))
                                                     field-types fields)])))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location (.sym ast))
          type-num (new-type-number (.sym ast))
          sym (ast/untag (.sym ast))
          fields (-> ast .fields .fixed (map ast/untag))
          field-destruct (DestructFields fields)
          fields-map (reduce fields {}
                             (fn [m name]
                               (assoc m
                                 (c/Field (symbol (str "." name))) c/top-type)))]
      (for [_ (push-types)
            _ (se/traverse fields (fn [sym]
                                    (set-value-type sym c/top-type)))
            field-assertions (-> (.impls ast)
                                 (filter (partial instance? c/SymbolConstraints))
                                 (se/traverse (fn [c]
                                                (either (map (c/extract-sym c)
                                                             (fn [sym]
                                                               (flat-map (type-check-ast c)
                                                                         (fn [new-c]
                                                                           (update-constraint
                                                                            sym (c/update-path new-c loc))))))
                                                        c/top-type))))
            field-cs (se/traverse fields get-value-type)
            :let [const-arity-map (-> (.arities c/fn-constraint)
                                      (select-keys [(count fields)])
                                      (map-vals (fn [arity]
                                                  (assoc-in arity [.param-consts .items] field-cs))))
                  new-type-constraint (-> (c/ReifiedConstraint type-num fields-map sym
                                                               (.arities c/fn-constraint const-arity-map)
                                                               empty-list c/no-symbol "")
                                          (c/update-path loc))]
            _ (se/assoc-in-val [.types sym] new-type-constraint)

            _ (set-value-type sym (-> c/fn-constraint
                                      (.arities const-arity-map)
                                      (c/update-sym sym)
                                      (c/update-path loc)))]
        (let [impls  (-> (.impls ast)
                         (remove (partial instance? c/SymbolConstraints))
                         (map (fn [proto-impls]
                                (map-vals proto-impls
                                          (fn [proto-fns]
                                            (map-vals proto-fns
                                                      (fn [proto-arities]
                                                        (reduce proto-arities {}
                                                                (fn [m arity]
                                                                  (assoc m (-> arity .params .fixed count)
                                                                         arity))))))))))
              impls (apply merge-with (comp [(partial merge-with comp)
                                             (default-type-impls (ast/tag sym loc) fields)]
                                            impls))
              impls (map-vals impls
                              (fn [protocol]
                                (map-vals protocol (fn [arities]
                                                     (map arities (fn [arity]
                                                                    ;; TODO: just doing this for testing
                                                                    ;; (assert (instance? ast/fn-arity-ast arity))
                                                                    ;; (.body arity (comp [field-destruct]
                                                                    ;;                    (.body arity)))
                                                                    (inc arity)))))))
              impls (map-vals impls (fn [protos]
                                      (map-vals protos (fn [impl-fns]
                                                         (vec (vals impl-fns))))))

              impls (-> (ast/extend-ast (.sym ast) impls)
                        (map (fn [c]
                               (constrain-first-param new-type-constraint c)))
                        .impls
                        vals
                        vec
                        (map (comp vec vals)))

              ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
              ;; and parameter, respectively
              ]
          (comp field-assertions
                [impls
                 (CreateGetters (.sym ast) type-num new-type-constraint fields loc)
                 ;; TODO: why are the hash-map-impls done twice?
                 ;; (cond (empty? hash-map-impls)
                 ;;       (ast/block-comment "" 0 [])
                 ;;       (b/TypeExtension new-type-constraint hash-map-impls))
                 (CheckedTypeAST (.sym ast) type-num new-type-constraint fields impls)
                 (reify
                   Container
                   (map [y f embed]
                     (embed y))

                   TypeChecker
                   (type-check [_ _]
                     (for [const-c (get-value-type (.sym ast))
                           :let [const-c (-> const-c
                                             (c/update-type-name (symbol (str (.sym ast)
                                                                              " constructor")))
                                             (c/update-path loc))]
                           _ (set-value-type (.sym ast) const-c)]
                       (ast/block-comment-ast [] "poop" 99 c/top-type))))

                 ;; (reify
                 ;;   Container
                 ;;   (map [y f embed]
                 ;;     (embed y))

                 ;;   TypeChecker
                 ;;   (pre-check [ast]
                 ;;     (for [ft (se/get-val .value-types)]
                 ;;       (do
                 ;;         (status 'test _LINE_ "\n" (count ft))
                 ;;         ast)))

                 ;;   (type-check [_ _]
                 ;;     (se/state-error (ast/block-comment-ast [] "poop" 99 c/top-type))))
                 ]))))))

(extend-type ast/main-ast
  TypeChecker
  (pre-check [ast]
    (for [_ (push-types)
          _ (se/traverse (all-syms (.params ast)) (fn [sym]
                                                    (set-value-type sym c/top-type)))]
      (.body ast (remove (.body ast) (partial instance? ast/block-comment-ast)))))

  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/block-comment-ast
  TypeChecker
  (type-check [ast old-ast]
    (se/state-error ast)))

(extend-type ast/quoted-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (reify
                      Type
                      (type-name [_]
                        (str "reified at " _LINE_))

                      Stringable
                      (string-list [_]
                        (list (str "'" (.q-val ast))))

                      Eq
                      (=* [_ y]
                        (= y (.q-val ast)))

                      Container
                      (map [x f]
                        x)

                      (map [x f embed]
                        (embed x))

                      ast/FileLoc
                      (ast/location [_]
                        (ast/location ast))

                      TypeChecker
                      (type-check [_ old-ast]
                        (se/state-error (.constraint ast (-> c/sym-constraint
                                                             (.static-value (symbol (rest (str ast))))
                                                             (c/update-path (ast/location ast))))))))))

(extend-type ast/IsType
  TypeChecker
  (pre-check [ast]
    (for [_ (either (map (= (.ast ast) '_)
                            (fn [_]
                              (print-err "Type at:" (ast/location (.ast ast))
                                         (.expected ast))
                              se-nop))
                    (flat-map (se/try
                                (type-check-ast (.ast ast))
                                (fn [err]
                                  (se/state-error (.constraint (.ast ast) c/bottom-type))))
                              (fn [c]
                                (either (map (= (.constraint c) (.expected ast))
                                             (fn [_]
                                               se-nop))
                                        (compilation-error "Type Error:" (ast/location (.ast ast))
                                                           "\n" 'ast (.ast ast)
                                                           "\n\n" 'expected (.expected ast)
                                                           "\n\n" 'actual (.constraint c))))))]
      (ast/block-comment "" 0 []))))

(extend-type ast/GetImpl
  TypeChecker
  (type-check [ast old-ast]
    (cond (= c/no-symbol (.type-sym ast))
          (se/state-error (.constraint ast (-> ast .impl-sym .constraint .default-impl)))

          (for [type-num (map (get-type-info (.type-sym ast) (ast/location (.type-sym ast)))
                              c/get-type-num)]
            (either (map (get-in ast [ .impl-sym .constraint type-num])
                         (fn [impl-c]
                           (se/state-error (.constraint ast impl-c))))
                    (compilation-error "Could not find impl for" (str "'" (.type-sym ast) "'")
                                       "at" (ast/location (.type-sym ast))))))))

(extend-type ProtoImpls
  TypeChecker
  (call-with-args [ast args target]
    (let [loc (ast/location target)
          disp-arg (first args)]
      (cond disp-arg
            (either (for [disp-type (map disp-arg (fn [ast]
                                                    (-> ast .constraint c/get-type-num)))
                          ;; _ (or ;; (= (.file loc) 'core)
                          ;;       ;; (= (.line loc) 0)
                          ;;    (and (= target 'Tester)
                          ;;         (do
                          ;;           (status 'call _LINE_ loc disp-type
                          ;;                   "\n\n" 'args args
                          ;;                   "\n\n" 'ast (get-in ast [.impl-fns disp-type]))
                          ;;           (maybe '_)))
                          ;;    (maybe '_))
                          f (or (get-in ast [.impl-fns disp-type])
                                (get ast .default-impl))]
                      (call-with-args f args target))
                    (compilation-error "Invalid prototype call"
                                       (cond (instance? Tagged target)
                                             (str "to '" target "' at")

                                             "at")
                                       loc))

            (compilation-error "At least one argument requred for call"
                               (cond (instance? Tagged target)
                                     (str "to '" target "' at")

                                     "at")
                               loc)))))

(def parse-forms
  (rd/parser
   (grmr/none-or-more
    (grmr/any
     (fr/pure (reify
                Type
                (type-name [_]
                  (str "Reified at: " _FILE_ ": " _LINE_))

                rd/RecursiveDescent
                (rd/recursive-descent [p]
                  (se/state-error
                   (se/new-se (fn [s]
                                (either (for [result-prom (get-in s [.values 'result-prom])
                                              :when (delivered result-prom)]
                                          (extract result-prom))
                                        se/Failure)))))))
     (apply-to (fn [type-checker result-prom ast]
                 ;; (status 'ast _LINE_ ast)
                 (send type-checker update-context
                       (se/try
                         (comp (type-check-ast ast)
                               (compilation-error "Could not type check code for expression at "
                                                  (ast/location ast)))
                         (fn [err]
                           (deliver result-prom err)
                           (se/throw (.val err)))))
                 ast)
               (grmr/get-value 'type-checker)
               (grmr/get-value 'result-prom)
               rdr/top-level)))))

(defn compile-module [file-name root-dir proj-dir]
  (let [mod-prom (promise)]
    (send modules
          (fn [mods]
            (assert-result r (instance? HashMap r))
            (either (map (get mods file-name)
                         (fn [mod]
                           (deliver mod-prom mod)
                           mods))
                    (let [module-index (count mods)
                          loading (promise)
                          ;; attach an action to 'loading' to be executed when a value is delivered to it
                          _ (map loading (fn [result]
                                           (send modules (fn [mods]
                                                           (assert-result r (instance? HashMap r))
                                                           (assoc mods file-name result)))
                                           result))
                          ;; init an agent with an empty module context
                          ast-checker (agent (Module file-name module-index {} {}
                                                     c/core-type-constraints
                                                     (list {'empty-list (c/update-sym c/empty-list-constraint
                                                                                      'empty-list)
                                                            'empty-vector (c/update-sym c/empty-vect-constraint
                                                                                        'empty-vector)
                                                            'int-max (.static-value c/int-constraint int-max)
                                                            'int-min (.static-value c/int-constraint int-min)
                                                            ;; 'nothing (c/MaybeConstraint c/bottom-type
                                                            ;;                             empty-list 'nothing "")
                                                            })))
                          ;; kick off a thread to load and check the module
                          _ (future (fn []
                                      (status "Loading" file-name)

                                      ;; try to open file for reading
                                      (either (map (fio/file-in (cond (= file-name 'core)
                                                                      path-to-core
                                                                      file-name))
                                                   (fn [file-in]
                                                     ;; if opened, parse and type check it
                                                     (let [parse-result (parse-forms {'file-name file-name
                                                                                      'root-directory root-dir
                                                                                      'project-directory proj-dir
                                                                                      'line-number 1
                                                                                      'type-checker ast-checker
                                                                                      'result-prom loading}
                                                                                     (lazy-list file-in))]
                                                       (cond (instance? se/Error parse-result)
                                                             (deliver loading
                                                                      ;; TODO: remove this after cycle catcher
                                                                      ;; is working
                                                                      (assoc-in parse-result
                                                                                [.state .values 'result-prom]
                                                                                '_))

                                                             ;; after all expressions have been checked,
                                                             ;; deliver the resulting Module
                                                             (send ast-checker
                                                                   (fn [mod]
                                                                     (send modules (fn [mods]
                                                                                     (assoc mods
                                                                                       file-name mod)))
                                                                     (send modules (fn [mods]
                                                                                     (deliver loading mod)
                                                                                     mods))))))))

                                              ;; or tell everyone it couldn't be
                                              (deliver loading (se/Error (str "Could not find/open " file-name)
                                                                         '_)))))]
                      (deliver mod-prom loading)
                      (assoc mods file-name loading)))))
    (extract mod-prom)))

(main [params]
  (let [core-result (compile-module 'core toccata-dir toccata-dir)
        core-result (either (map (instance? Promise core-result) extract)
                            core-result)
        core-mod (cond (instance? Module core-result)
                       core-result

                       (do
                         (either (map (instance? se/Error core-result)
                                      (fn [err]
                                        (status (.val err))))
                                 (status "Could not load Toccata core."))
                         (wait-for-output)
                         (abort)))]
    (-> (rest params)
        ;; TODO: empty-defn causes mem leaks
        ;; (remove (partial = "assertion-tests/empty-defn.toc"))
        (map (fn [file-name]
               (map (sys/file-directory file-name)
                    (fn [root-dir]
                      (send modules (fn [_]
                                      {'core core-mod}))
                      (let [_ (send output (fn [_]
                                             (fio/file-out (str file-name ".err"))))
                            core-result (compile-module file-name toccata-dir toccata-dir)
                            core-result (either (map (instance? Promise core-result) extract)
                                                core-result)]
                        (cond (instance? Module core-result)
                              (status 'Loaded file-name)

                              (do
                                (either (map (instance? se/Error core-result)
                                             (fn [err]
                                               (status (.val err))))
                                        (status "Could not load Toccata file:" file-name)))))))))))

  (wait-for-output))

;; (main [_]
;;   (print-err (cata c/show-full
;;                    (ProtoImpls
;;                     'wut
;;                     (.arities c/fn-constraint
;;                               (select-keys (.arities c/fn-constraint) [2]))
;;                     {}))))

