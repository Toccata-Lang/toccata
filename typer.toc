
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "cd0abb2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns b (module "base.toc"))

;; (add-ns fr (git-dependency "https://github.com/Toccata-Lang/Free.git"
;;                            "free.toc"
;;                             :sha "5c353f2"))

(def lf "\n")
(def lflf "\n\n")

(def max-time (agent 0))
(def start-time (agent empty-list))

(defn start-clock []
  (let [start (sys/clock_gettime)]
    (send start-time (fn [starts] (cons start starts)))))

(defn stop-clock [ast]
  (let [end (sys/clock_gettime)]
    (send start-time (fn [[start & starts]]
                       (let [delta (sys/time-delta start end)]
                         (send max-time (fn [prev-max]
                                          (cond (< prev-max delta)
                                                (do
                                                  (b/status 'slow _LINE_
                                                          (ast/location ast)
                                                          (div delta 1000) "ms"
                                                          lflf ast)
                                                  delta)
                                                prev-max)))
                         starts)))))

(def curr-arity (c/tag "#curr-arity"))

(deftype ProtoArity [type-num arity]
  (assert (instance? (all-of Integer (min 1))
                     type-num))
  (assert (instance? ast/fn-arity-ast arity))

  Stringable
  (string-list [_]
    (list "(ProtoArity " (str type-num) " " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (partial .arity x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location arity)))

(defn append-value-type [sym constraint loc]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? c/Constraints constraint))

  (cond (= sym c/no-symbol)
        (se/state-error constraint)

        (= (str sym) "")
        (b/compilation-error "Bad call to append-value-type" _LINE_ loc sym lf constraint)

        (= constraint c/top-type)
        (se/try
          (map (b/get-value sym) .constraint)
          (fn [_]
            (se/state-error c/top-type)))

        (= constraint c/bottom-type)
        (b/compilation-error ;; 'site _LINE_ loc 'appending sym
                             ;; lflf 'constraint constraint
                             ;; lflf
                             (b/conf-ass _LINE_ constraint loc))

        (= (.ns sym) c/no-symbol)
        (flat-map (se/try
                    (b/get-value sym)
                    (fn [_]
                      (se/state-error c/top-type)))
                  (fn [curr-val]
                    (cond (= (.constraint curr-val) c/top-type)
                          (map (b/set-value sym (.constraint curr-val
                                                             (c/update-path constraint loc)))
                               .constraint)

                          (instance? c/ProtoImpls (.constraint curr-val))
                          b/se-nop

                          (let [new-const (c/intersect (c/update-path constraint loc)
                                                       (.constraint curr-val))]
                            ;; (let [loc (ast/location sym)]
                            ;;   (or ;; (= (.file loc) b/core)
                            ;;       ;; (= (.line loc) 0)
                            ;;       (do
                            ;;         (b/status 'appending _LINE_ loc (str "\"" sym "\"")
                            ;;                 lf 'constraint constraint
                            ;;                 lflf 'curr curr-const
                            ;;                 lflf 'untrimmed (c/intersect curr-const constraint)
                            ;;                 lflf 'new-const new-const)
                            ;;         nothing)))

                            (cond (= new-const c/bottom-type)
                                  (b/compilation-error ;; 'site _LINE_ loc 'appending sym
                                   ;; lf 'curr curr-const
                                   ;; lflf 'constraint constraint
                                   ;; lflf 'new-const new-const
                                   ;; lflf
                                   (b/conf-ass _LINE_ new-const loc))

                                  (map (b/set-value sym
                                                    (.constraint curr-val
                                                                 (c/update-path new-const loc)))
                                       .constraint))))))

        (se/state-error constraint)))

;; (defn add-ns-impl [ns sym type-num arg-count arity-c loc]
;;   (fn [mods]
;;     (assert (instance? HashMap mods))
;;     (assert-result r (instance? HashMap r))

;;     (either (for [val-types-list (get-in mods [ns .value-types])
;;                   val-types (first val-types-list)
;;                   proto-impls (get val-types sym)]
;;               (let [new-proto (add-impl proto-impls type-num
;;                                         arg-count arity-c loc)
;;                     val-types-list (map val-types-list
;;                                         (fn [m]
;;                                           (assoc m sym new-proto)))]
;;                 (cond (instance? c/ProtoImpls new-proto)
;;                       (assoc-in mods [ns .value-types]
;;                                 val-types-list)

;;                       ;; add-impl might return a compilation error
;;                       (do
;;                         (b/status (.val new-proto))
;;                         (b/wait-for-err-out)
;;                         (abort)))))
;;             mods)))

;; TODO:
;; (def C-var-punct (grmr/any (map (grmr/ignore "*") (constantly "_STAR_"))
;;                            (map (grmr/ignore ".") (constantly ""))
;;                            (map (grmr/ignore "#") (constantly "_HASH_"))
;;                            (map (grmr/ignore "+") (constantly "_PLUS_"))
;;                            (map (grmr/ignore "?") (constantly "_QM_"))
;;                            (map (grmr/ignore "!") (constantly "_BANG_"))
;;                            (map (grmr/ignore "=") (constantly "_EQ_"))
;;                            (map (grmr/ignore "<") (constantly "_LT_"))
;;                            (map (grmr/ignore ">") (constantly "_GT_"))))

;; (def C-var-remaining
;;   (grmr/none-or-more (grmr/any "_"
;;                                (map (grmr/ignore "-") (constantly "_"))
;;                                grmr/alpha
;;                                grmr/digit
;;                                C-var-punct)))

;; (def C-var (apply-to (fn [start remaining]
;;                        (to-str (comp [start] remaining)))
;;                      (grmr/any grmr/alpha
;;                                (map (grmr/ignore "#") (fn [] ""))
;;                                (map (grmr/ignore "-") (fn [] "_MINUS_"))
;;                                C-var-punct)
;;                      C-var-remaining))

;; (def C-var (rd/parser C-var))

(defn check-C-var [var-name]
  ;; (let [parse-result (C-var (str var-name))]

  ;;   ;; TODO: this form doesn't work. 'instance?' fails
  ;;   ;; (either (and (instance? se/Failure parse-result)
  ;;   ;;              (maybe alt-var))

  ;;   ;;       (let [[c-var] parse-result]
  ;;   ;;         c-var))

  ;;   (either (flat-map (instance? Vector parse-result)
  ;;                     first)
  ;;           'arg))
  (cond (= "_" (str var-name))
        "arg"
        var-name)
  )

(defn local-var [prefix]
  (map (se/get-in-val [.var-count 0])
       (fn [var-count]
         (str (check-C-var prefix) "_"
              (extract var-count)))))

(defprotocol TypeChecker
  (set-local-var [ast]
    (assert-result r (instance? se/StateError r))
  
    (cond (= (.var ast) "")
          (map (local-var b/Rslt)
               (fn [new-var]
                 (.var ast new-var)))
          (se/state-error ast)))

  (set-global-var [ast])

  (update-constraint [ast constraint loc]
    (b/compilation-error "Could not find implementation of 'update-constraint' at" loc "for:"
                       lf (type-name ast) ast
                       lflf constraint))

  (all-symbols [ast]
    (assert-result l (instance? (vector-of ast/ParamType) l))
    ;; ast

    ;; how to use
    ;; (cata all-symbols (.fields ast))
    )

  (param-types [_]
    (assert-result x (instance? se/StateError x)))

  (pre-check [ast]
    (assert-result x (instance? se/StateError x))

    ;; TODO: put back in when done
    ;; (se/state-error ast)
    )

  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (b/compilation-error "Could not find implementation of 'type-check' at" (ast/location old-ast) "for:"
                       lf (type-name old-ast) old-ast)
    ;; (se/state-error ast)
    ))

(def ConstrainedAST (any-of ast/call-ast
                            ;; ast/params-ast
                            ast/fn-ast
                            ;; ast/fn-arity-ast
                            ;; ast/let-ast
                            ast/do-ast
                            ast/or-ast
                            ast/and-ast
                            ast/either-ast
                            ast/string-ast
                            ast/integer-ast
                            ast/cond-ast
                            ast/binding-ast
                            ast/quoted-ast
                            ;; c/TaggedSymbol
                            ;; ast/prototype-ast
                            ;; ast/reify-ast
                            ast/block-comment-ast))

(extend-type Opaque
  Eq
  (=* [x y]
    nothing))

(extend-type ConstrainedAST
  TypeChecker
  (update-constraint [ast constraint loc]
    (let [new-c (c/intersect (.constraint ast) constraint)]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (b/compilation-error ;; 'site _LINE_ loc
                                        ;; lf 'ast ast
                                        ;; lflf 'ast-constraint (.constraint ast)
                                        ;; lflf 'constraint constraint
                                        ;; lflf 'new-c new-c
                                        ;; lflf
                                        (b/conf-ass _LINE_ new-c loc))))
              (se/state-error (.constraint ast (c/update-path new-c loc)))))))

(defn all-syms [params]
  (assert (instance? ast/ParamType params))

  (cata all-symbols params))

(defn get-param-types [params]
  (assert (instance? (any-of c/TaggedSymbol ast/params-ast) params))

  (cata param-types params se/state-error))

;; TODO: remove when done
(def DefaultPreCheck (any-of Vector
                             ;; ProtoArity
                             ;; c/TaggedSymbol
                             c/AllValues
                             c/NoSymbol
                             c/ReifiedConstraint
                             c/SumConstraint
                             c/SeqConstraint
                             c/CollectionOf
                             c/TypeOfConstraint
                             c/FnConstraint
                             c/TypeOp
                             c/MultiConstraint
                             c/fn-arity
                             c/Field
                             c/NoTail
                             c/ParamConstraint
                             c/Contents
                             ast/declaration-ast
                             ast/string-ast
                             ast/integer-ast
                             ast/call-ast
                             ast/inline-ast
                             ast/do-ast
                             ast/protocol-ast
                             ast/params-ast))

;; TODO: remove when done
(def DefaultTypeCheck (any-of Vector
                              c/AllValues
                              c/NoSymbol
                              c/NoTail
                              c/Contents
                              c/fn-arity
                              ast/protocol-ast
                              ast/block-comment-ast))

;; TODO: remove when done
(extend-type DefaultPreCheck
  TypeChecker
  (pre-check [ast]
    (se/state-error ast)))

;; TODO: remove when done
(extend-type DefaultTypeCheck
  TypeChecker
  (type-check [ast old-ast]
    (assert-result x (instance? se/StateError x))

    (se/state-error ast)))

(def DefaultConst (any-of c/AllValues
                          c/ParamConstraint
                          c/FnConstraint
                          c/ReifiedConstraint
                          c/MultiConstraint
                          c/CollectionOf
                          c/SeqConstraint
                          c/SumConstraint
                          c/StringConstraint
                          c/NoSymbol))

(extend-type DefaultConst ;; c/Constraints
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c)))

(def DefaultSymConst (any-of c/CollectionOf
                             c/SeqConstraint
                             c/SumConstraint
                             c/MultiConstraint
                             c/TypeOp
                             c/IntegerConstraint
                             c/SymbolConstraint
                             c/StringConstraint
                             c/MaybeConstraint
                             c/FnConstraint))

(extend-type DefaultSymConst ;; c/SymbolConstraints
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (append-value-type (.sym c) c loc))))

(extend-type Integer
  TypeChecker
  (pre-check [n]
    (se/state-error (c/IntConstraint n))))

(extend-type c/NoSymbol
  TypeChecker
  (set-local-var [x]
    (se/state-error x))

  (update-constraint [x _ _]
    (se/state-error x)))

(extend-type c/NoValues
  TypeChecker
  (type-check [c old-c]
    (b/compilation-error (b/conf-ass _LINE_ c (ast/location c)))))

(extend-type c/Field
  TypeChecker
  (all-symbols [c]
    [])

  (param-types [c]
    (se/state-error c))

  (type-check [c old-c]
    (se/state-error c)))

(extend-type c/ReifiedConstraint
  TypeChecker
  (type-check [c old-c]
    (let [loc (ast/location old-c)]
      (flat-map (cond (= c/UnknownType (c/type-num c))
                      (se/try
                        (b/get-type-info (.type-symbol c))
                        (fn [_]
                          (se/state-error c)))
                      (se/state-error c))
                (fn [type-c]
                  (append-value-type (.sym c) type-c loc))))))

(extend-type c/TypeOfConstraint
  TypeChecker
  (type-check [c old-c]
    ;; TODO: restrict use to fn params only
    (flat-map (b/get-value (.param-sym old-c))
              (fn [val]
                (let [loc (ast/location c)]
                  (append-value-type (.sym c) (.constraint val) loc))))))

(extend-type ProtoArity
  TypeChecker
  (pre-check [ast]
    ;; (map (b/se-debug 'checking _LINE_ (ast/location ast)
    ;;                lflf (.arity ast))
    ;;      (fn [_]
    ;;        ast))
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [_ (b/add-proto-impl (.type-num ast)
                              (-> old-ast .arity .fn-sym)
                              (-> old-ast .arity .params .fixed count)
                              (-> ast .arity))]
      ast)))

(extend-type ast/inline-ast
  TypeChecker
  (set-global-var [ast]
    (.var ast (b/global-var 'Val)))

  (type-check [ast old-ast]
    (map (type-check (.constraint ast) (.constraint ast))
         (fn [c]
           (.constraint ast c)))))

(extend-type ast/reify-ast
  TypeChecker
  (set-global-var [ast]
    (.var ast (b/global-var 'Reified)))

  (pre-check [ast]
    (let [reified-type-num (either (instance? Integer (.type-num ast))
                                   (extract b/type-counter))
          type-sym (c/tag (str "reified value at " (ast/location ast)))]
      (for [_ (b/set-type-info type-sym
                               (c/ReifiedConstraint reified-type-num type-sym {} {}
                                                    c/fn-constraint empty-list c/no-symbol))]
        (-> ast
            (.type-num reified-type-num)
            (map (partial ProtoArity reified-type-num))))))

  (type-check [ast old-ast]
    (let [type-sym (c/tag (str "reified value at " (ast/location old-ast)))]
      (for [new-c (b/get-type-info type-sym)]
        (-> ast
            (map .arity)
            (.constraint new-c))))))

(extend-type ast/prototype-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)
          fixed-params (-> ast .params .fixed)
          arg-count (count fixed-params)
          all-param-syms (remove (all-syms (.params ast))
                                 (fn [s]
                                   (= s '_)))]
      (cond (< (count (set all-param-syms)) (count all-param-syms))
            (b/compilation-error "Duplicate parameter names in prototype at" loc)

            (for [_ (se/try
                      (b/get-value (.fn-name ast))
                      (fn [_]
                        (b/set-value (.fn-name ast)
                                     (ast/fn-ast (.fn-name ast) [] (b/global-var b/Fn)
                                                 (c/ProtoImpls (.fn-name ast)
                                                               (.arities c/fn-constraint
                                                                         {})
                                                               {})))))
                  _ (b/push-types)
                  _ (se/update-val .var-count (fn [var-counts]
                                                (cons (int-generator 0) var-counts)))
                  _ (flat-map (set-local-var ast/result-sym)
                              (fn [result-sym]
                                (b/set-value ast/result-sym result-sym)))
                  ;; :let [_ (or ;; (= (.line loc) 0)
                  ;;             ;; (= (.file loc) b/core)
                  ;;          (and (= (.fn-name ast) 'first)
                  ;;               (do
                  ;;                 (send b/err-out (fn [_] (maybe nothing)))
                  ;;                 (b/status 'pre-prototype _LINE_ (.fn-name ast) (ast/location ast)
                  ;;                         lf 'body (.default-body ast))
                  ;;                 nothing)))]
                  new-params (set-local-var (.params ast))
                  _ (se/traverse all-param-syms
                                 (fn [sym]
                                   (b/set-value sym (.constraint sym c/top-type))))
                  :let [idxs (integer-gen 1)]
                  _ (se/traverse fixed-params
                                 (fn [sym]
                                   (let [idx (- arg-count (new-int idxs))]
                                     (cond (instance? ast/params-ast sym)
                                           (se/state-error (new-int idxs))

                                           (= sym '_)
                                           (b/set-value sym (.constraint sym c/top-type))

                                           (append-value-type sym
                                                              (c/param (.fn-name ast) idx)
                                                              loc)))))]
              (-> ast
                  (.params new-params))))))

  (type-check [ast old-ast]
    (let [arg-count (count (.fixed (.params old-ast)))
          variadic (.variadic (.params old-ast))
          sym (.fn-name ast)
          ast (-> ast
                  (.params (.params old-ast))
                  (.var (b/global-var b/CFn))
                  (.default-body (remove (.default-body ast)
                                         (fn [expr]
                                           (instance? c/Constraints expr)))))]
      (for [pts (map (get-param-types (.params old-ast))
                     (fn [pts]
                       (-> pts
                           (c/set-seq-tail c/no-tail)
                           (c/intersect c/list-constraint))))
            result-c (se/try
                       (map (b/get-value ast/result-sym) .constraint)
                       (fn [_]
                         (se/state-error c/top-type)))
            ;; :let [_ (or ;; (= (.line loc) 0)
            ;;             ;; (= (.file loc) b/core)
            ;;          (and (= (.fn-name ast) 'vec)
            ;;               (do
            ;;                 (b/status 'check-prototype _LINE_ (.fn-name ast) (ast/location ast)
            ;;                         lf ast
            ;;                         lflf 'pts pts
            ;;                         lflf 'result result-c)
            ;;                 (send b/err-out (fn [_] nothing))
            ;;                 nothing)))]
            :let [pts (c/set-seq-tail pts c/no-tail)
                  impl-c (c/fn-arity (.fn-name old-ast) pts result-c)]
            _ (b/remove-value-type ast/result-sym)
            _ (se/traverse (all-syms (.params old-ast)) b/recover-val)
            _ (b/nip-types)
            _ (se/update-val .var-count rest)
            _ (se/try
                (for [val (b/get-value sym)
                      _ (b/set-value sym
                                     (-> val
                                         (.arities (conj (.arities val) ast))
                                         (.constraint (assoc-in (.constraint val)
                                                                [.default-impl .arities arg-count]
                                                                impl-c))))]
                  '_)
                (fn [_]
                  (b/status 'new-proto _LINE_ sym)
                  (b/set-value sym (ast/fn-ast sym [ast] (b/global-var b/Fn)
                                               (c/ProtoImpls sym
                                                             (.arities c/fn-constraint
                                                                       {arg-count impl-c})
                                                             {})))))]
        ast))))

(extend-type ast/call-ast
  TypeChecker
  (set-global-var [ast]
    (.var ast (b/global-var b/Rslt)))

  (type-check [ast old-ast]
    (either (and (= (.call-target old-ast) 'show-type)
                 (map (first (.args ast))
                      (fn [arg]
                        (b/status 'showing (ast/location (.call-target old-ast)) arg
                                lf (c/trim (.constraint arg)))
                        (se/state-error arg))))

            (let [loc (ast/location (.call-target old-ast))
                  target-c (.constraint (.call-target ast))
                  arg-cs (map (.args ast) .constraint)
                  arg-count (count arg-cs)
                  ;; print-info? (and (= (.call-target old-ast) 'pr*)
                  ;;              ;; (= (.line loc) 2462)
                  ;;              ;; (= (.file loc) "assertion-tests/tail-either-2.toc")
                  ;;              ;; nothing
                  ;;              )
                  ;; _ (map print-info?
                  ;;        (fn [_]
                  ;;          (b/status 'call-site _LINE_ loc (.call-target old-ast)
                  ;;                    lf 'target-c target-c
                  ;;                    lflf 'args (str "[" (-> arg-cs
                  ;;                                            (interpose "\n ")
                  ;;                                            to-str)
                  ;;                                    "]")
                  ;;                    )))
                  [result-type param-cs] (c/do-call-value target-c arg-cs (list loc))]
              ;; (map print-info?
              ;;      (fn [_]
              ;;        (b/status 'call-site _LINE_ loc (.call-target ast)
              ;;                  lf 'result result-type
              ;;                  lflf 'param-cs param-cs
              ;;                  )))

              ;; (for [_ (and (instance? c/ProtoImpls target-c)
              ;;              (< 1968 (.line loc)))
              ;;       disp-arg (map (first (.args ast)) .constraint)
              ;;       :let [val-num (c/type-num disp-arg)]
              ;;       :when-not (or (instance? c/ParamConstraint disp-arg)
              ;;                     (= c/UnknownType val-num)
              ;;                     (get-in target-c [.impl-fns val-num .arities arg-count]))]
              ;;   (b/status 'call-proto _LINE_ loc
              ;;           lf ast
              ;;           lflf 'disp val-num disp-arg))
              (for [
                    ;; This is a small perf hit
                    ;; target-c (cond (or (instance? c/FnConstraint target-c)
                    ;;                    (instance? c/ReifiedConstraint target-c))
                    ;;                (apo (fn [inner]
                    ;;                       ;; Get the current type info for any proto impls
                    ;;                       (cond (instance? c/ProtoImpls inner)
                    ;;                             (map (get-value-type (.fn-sym inner))
                    ;;                                  RecurseFinal)

                    ;;                             (se/state-error (RecurseWith inner))))
                    ;;                     target-c
                    ;;                     se/state-error)

                    ;;                (se/state-error target-c))
                    ast (set-local-var ast)
                    result-type (either (for [reified-c (instance? c/ReifiedConstraint result-type)
                                              :when-not (= c/no-symbol (.type-symbol reified-c))
                                              _ (= c/UnknownType (.type-number reified-c))]
                                          (map (se/try
                                                 (b/get-type-info (.type-symbol reified-c))
                                                 (fn [_]
                                                   (se/state-error reified-c)))
                                               (fn [type-info]
                                                 (let [result-type (c/intersect result-type
                                                                                type-info)]
                                                   ;; (map print-info?
                                                   ;;      (fn [_]
                                                   ;;        (b/status 'call-site _LINE_ loc (.call-target ast)
                                                   ;;                lf 'reified-c reified-c
                                                   ;;                lflf 'type-info type-info
                                                   ;;                lflf 'inter result-type)))
                                                   result-type))))

                                        (se/state-error result-type))
                    new-args (either (map (= c/bottom-type result-type)
                                          (fn [_]
                                            (b/compilation-error ""
                                                               'site _LINE_ loc
                                                               lf old-ast
                                                               lflf 'target-c target-c
                                                               lflf 'arg-cs arg-cs
                                                               lflf 'result-type result-type
                                                               lflf
                                                               (b/conf-ass _LINE_ result-type loc))))
                                     (se/traverse
                                      (zip-lists (.args ast) param-cs)
                                      (fn [[ast arg-c]]
                                        ;; (either (map print-info?
                                        ;;              (fn [_]
                                        ;;                (for [new-ast (update-constraint ast arg-c loc)
                                        ;;                      _ (b/se-debug 'updating-arg _LINE_ loc
                                        ;;                                  lflf 'ast ast
                                        ;;                                  lflf 'ast-c (.constraint ast)
                                        ;;                                  lflf 'arg-c arg-c
                                        ;;                                  lflf 'new-c
                                        ;;                                  (.constraint new-ast))]
                                        ;;                  new-ast))))
                                        (update-constraint ast arg-c loc))))]
                (-> ast
                    (.args (vec new-args))
                    (.constraint result-type)))))))

(extend-type ast/Annotated
  TypeChecker
  (pre-check [ast]
    (pre-check (.ast ast))))

(extend-type ast/declaration-ast
  TypeChecker
  (type-check [ast old-ast]
    (b/set-value (.sym old-ast) (-> (.sym old-ast)
                                    set-global-var
                                    (.constraint c/top-type)))))

(extend-type ast/definition-ast
  TypeChecker
  (pre-check [ast]
    (let [sym (.sym ast)]
      (for [
            ;; :let [_ (start-clock)]
            _ (cond (or (= sym 'empty-list)
                                         (= sym 'empty-vector)
                                         (= sym 'int-max)
                                         (= sym 'int-min)
                                         (= sym 'nothing))
                    b/se-nop

                    (b/set-value sym (.constraint sym c/top-type)))]
        (.value-exprs ast (-> (.value-exprs ast)
                              (remove (partial instance? ast/block-comment-ast))
                              (map (fn [inner-ast]
                                     (cond (instance? ast/fn-ast inner-ast)
                                           (-> inner-ast
                                               (map (fn [arity]
                                                      (.fn-sym arity sym)))
                                               (.fn-sym sym))

                                           (instance? c/SymbolConstraints inner-ast)
                                           (c/update-sym inner-ast sym)

                                           inner-ast))))))))

  (type-check [ast old-ast]
    (let [loc (ast/location (.sym old-ast))
          sym (.sym old-ast)]
      (for [
            ;; :let [_ (stop-clock ast)]
            val (either (map (last (.value-exprs ast))
                             (fn [val]
                               (cond (instance? c/Constraints val)
                                     ;; TODO: if (.sym old-ast) is already in the types, it won't be replaced by
                                     ;; the updated version. Possibly a bug in assoc-in*

                                     ;; TODO: this version produces a very cryptic error message
                                     ;; (flat-map (se/assoc-in-val [.types (ast/untag (.sym old-ast))] val)
                                     ;;           (set-value-type (.sym old-ast) val))

                                     (let [val (c/trim val)]
                                       (for [_ (b/set-type-info sym val)
                                             _ (b/set-value sym (.constraint sym val))]
                                         (ast/block-comment-ast [] c/no-loc c/top-type)))

                                     (or (= sym 'empty-list)
                                         (= sym 'empty-vector)
                                         (= sym 'int-max)
                                         (= sym 'int-min)
                                         (= sym 'nothing))
                                     (for [c (map (b/get-value sym) .constraint)
                                           _ (b/set-value sym (.constraint sym (c/update-path c loc)))]
                                       val)

                                     (let [val (set-global-var val)]
                                       (for [_ (b/set-value sym (.constraint val (c/trim (.constraint val))))]
                                         val)))))
                        (b/set-value (.sym old-ast) (.constraint (.sym old-ast) c/top-type)))]
        (do
          ;; (b/status 'defed _LINE_ loc (.sym old-ast)
          ;;            lflf val)
          (.value-exprs ast [val]))))))

(extend-type ast/fn-arity-ast
  TypeChecker
  (pre-check [ast]
    (let [fixed-params (.fixed (.params ast))
          arg-count (count (.params ast))
          arity-id (cond (= (.fn-var ast) "")
                         (c/tag (gensym "fn-arity"))
                         (.fn-var ast))
          loc (ast/location ast)]
      ;; TODO: what about duplicate param names (like in prototype-ast)?
      (for [_ (b/push-types)
            ;; :let [_ (start-clock)]

            ;; :let [_ (or (= (.line loc) 0)
            ;;             (= b/core (.file loc))
            ;;             (and (= (.fn-sym ast) 'tf)
            ;;                  (do
            ;;                    (b/status 'pre-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                            lf 'params (.params ast)
            ;;                            lflf 'body "[" (to-str (interpose (.body ast) lflf)) "]"
            ;;                            lflf 'body-types (map (.body ast) type-name)
            ;;                            lflf 'const (.constraint ast))
            ;;                    nothing)))]
            _ (se/update-val .var-count (fn [var-counts]
                                          (cons (int-generator 0) var-counts)))
            _ (b/set-value curr-arity (.constraint
                                       curr-arity
                                       (c/fn-c []
                                               {c/variadic (c/fn-arity arity-id
                                                                       c/list-constraint c/top-type)})))
            new-params (set-local-var (.params ast))
            _ (cata (fn [x]
                      (cond (instance? c/TaggedSymbol x)
                            (b/set-value x (.constraint x c/top-type))
                            
                            ;; TODO: should use cata to make all the variadic syms be lists
                            (se/state-error x)))
                    new-params
                    se/state-error)
            _ (flat-map (set-local-var ast/result-sym)
                        (fn [result-sym]
                          (b/set-value ast/result-sym result-sym)))
            ;; _ (b/status 'new-params _LINE_
            ;;             (interpose (map (all-syms new-params)
            ;;                             (fn [s]
            ;;                               (str "[" s " " (.var s) "]")))
            ;;                              lf))
            :let [idxs (integer-gen 1)]
            _ (se/traverse fixed-params
                           (fn [sym]
                             (cond (instance? ast/params-ast sym)
                                   (se/state-error (new-int idxs))

                                   (append-value-type sym
                                                      (c/param arity-id
                                                               (- arg-count (new-int idxs)))
                                                      loc))))
            _ (append-value-type (.variadic (.params ast))
                                 (c/param arity-id arg-count)
                                 loc)]
        (-> ast
            (.fn-var arity-id)
            (.params new-params)
            (.body (comp (filter (.body ast) (partial instance? c/Constraints))
                         (-> (.body ast)
                             (remove (fn [ast]
                                       (or (instance? c/Constraints ast)
                                           (instance? ast/block-comment-ast ast)))))))))))

  (type-check [ast old-ast]
    (assert (instance? ast/fn-arity-ast old-ast))

    (let [loc (ast/location old-ast)]
      (for [result-c (map (b/get-value ast/result-sym) .constraint)
            ;; :let [_ (stop-clock ast)]
            _ (b/recover-val ast/result-sym)
            _ (b/recover-val curr-arity)
            _ (se/update-val .var-count rest)
            args (se/traverse (all-syms (.params old-ast))
                              (fn [arg]
                                (for [final-arg (b/get-value arg)]
                                  [arg final-arg])))
            pts (map (get-param-types (.params old-ast))
                     (fn [pts]
                       (cond (= c/no-symbol (.variadic (.params old-ast)))
                             (c/set-seq-tail pts c/no-tail)
                             pts)))
            _ (se/traverse (all-syms (.params old-ast)) b/recover-val)
            _ (b/nip-types)
            :let [args (reduce args {} conj)
                  body-c (either (map (last (.body ast)) .constraint)
                                 c/top-type)
                  final-c (c/intersect result-c body-c)
                  checked-fnl (either (= c/bottom-type pts)
                                      (c/reify-type-constraint final-c (.fn-var ast)
                                                               (-> pts c/get-items count
                                                                   (repeat c/top-type))
                                                               loc))
                  arity-c (c/intersect (.constraint ast)
                                       (c/fn-arity (.fn-var ast) pts final-c))]
            ;; :let [_ (or (= b/core (.file loc))
            ;;             (= (.line loc) 0)
            ;;             (and (= (.fn-sym ast) 'tf)
            ;;                  (do
            ;;                    (b/status 'check-fn-arity _LINE_ (.fn-sym ast) loc
            ;;                            lf 'pts pts
            ;;                            lflf 'result-c result-c
            ;;                            lflf 'body-c body-c
            ;;                            lflf 'final-c final-c
            ;;                            lflf 'checked-fnl checked-fnl
            ;;                            lflf 'ast-c (.constraint ast)
            ;;                            lflf 'body-exprs (str "[" (to-str (interpose (.body ast) lf))
            ;;                                                  "]"))
            ;;                    nothing)))]
            _ (either (map (or (= c/bottom-type arity-c)
                               (= c/bottom-type final-c))
                           (fn [failure-c]
                             (b/compilation-error ""
                                                ;; 'arity _LINE_ loc (.fn-sym old-ast) (.fn-var ast)
                                                ;; lflf 'pts pts
                                                ;; lflf 'result-c result-c
                                                ;; lflf 'body-c body-c
                                                ;; lflf 'final-c final-c
                                                ;; ;; lflf 'body (either (map (last (.body ast))
                                                ;; ;;                         .constraint)
                                                ;; ;;                    c/top-type)
                                                ;; lflf 'failure-c failure-c
                                                ;; lflf
                                                (b/conf-ass _LINE_ failure-c loc)
                              )))
                      b/se-nop)]
        ;; TODO: use update-constraint here
        (cond (= c/bottom-type pts)
              (do
                ;; TODO: should never happen
                (print-err 'blewity _LINE_ loc)
                (abort))

              ;; TODO: this cata is incomplete. It needs to go through the body
              (-> (cata (fn [x]
                          (either (for [_ (instance? c/TaggedSymbol x)
                                        final-arg (get args x)
                                        _ (identical (.var x) (.var final-arg))]
                                    final-arg)

                                  x))
                        ast)
                  (.body (remove (.body ast) (fn [x]
                                               (instance? c/Constraints x))))
                  (.constraint arity-c)))))))

(extend-type ast/fn-ast
  TypeChecker
  (set-local-var [ast]
    (cond (= (.var ast) "")
          (map (local-var 'fn)
               (fn [new-var]
                 (.var ast new-var)))
          (se/state-error ast)))

  (set-global-var [ast]
    (cond (every (.arities ast) (fn [arity]
                                  (instance? b/StaticArity arity)))
          (.var ast (b/global-var (.fn-sym ast) b/Fn))

          ast))

  (pre-check [ast]
    (let [loc (ast/location ast)
          sym (.fn-sym ast)]
      ;; (or (= (.line loc) 0)
      ;;     (= (.file loc) b/core)
      ;;     (do
      ;;       (print-err 'fn-ast loc
      ;;                  lf ast)
      ;;       nothing))
      (for [_ (b/push-types)
            _ (cond (= c/no-symbol sym)
                    b/se-nop

                    (b/set-value sym (.constraint sym (-> c/fn-constraint
                                                          ;; TODO: worry about recursion later
                                                          ;; (c/intersect (c/coll-of-c c/empty-reified))
                                                          (c/update-path loc)
                                                          (c/update-sym sym)))))]
        (.arities ast (map (.arities ast)
                           (fn [arity]
                             (.fn-sym arity sym)))))))

  (type-check [ast old-ast]
    (let [sym (.fn-sym ast)
          fn-c (-> c/fn-constraint
                   (c/update-path (ast/location sym))
                   (c/update-sym sym))
          fn-c (reduce (.arities ast) (.arities fn-c {})
                       (fn [c arity]
                         (assert (instance? ast/fn-arity-ast arity))
                         (let [arity-c (.constraint arity)]
                           (either (for [variadic (map (get-in arity-c [.param-consts])
                                                       c/seq-tail)
                                         :when (= c/no-tail variadic)
                                         fixed-params (map (get-in arity-c [.param-consts])
                                                           c/get-items)]
                                     (assoc-in c [.arities (count fixed-params)] arity-c))
                                   (assoc-in c [.arities c/variadic] arity-c)))))
          fn-c (c/update-path fn-c (ast/location old-ast))]
      ;; (let [loc (ast/location ast)]
      ;;   (or ;; (= (.file loc) b/core)
      ;;       ;; (= (.line loc) 0)
      ;;       (do
      ;;         (print-err 'fn-c _LINE_ (ast/location old-ast) lf fn-c)
      ;;         nothLing)))
      (for [_ (b/nip-types)
            ast (set-local-var ast)]
        (-> ast
            (.constraint fn-c)
            (map (fn [arity]
                   ;; TODO: check for closure here
                   (-> arity
                       (.fn-var (b/global-var sym b/Arity))
                       (b/StaticArity (b/global-var sym b/CFn))))))))))

(extend-type Symbol
  TypeChecker
  (pre-check [s]
    (print-err 'wut _LINE_ s)
    (se/state-error (abort))))

(extend-type c/TaggedSymbol
  TypeChecker
  (set-local-var [ast]
    (cond (= (.var ast) "")
          (map (local-var ast)
               (fn [new-var]
                 (.var ast new-var)))
          (se/state-error ast)))

  (set-global-var [ast]
    ast)

  (param-types [sym]
    (map (b/get-value sym) .constraint))

  (update-constraint [ast constraint loc]
    (map (append-value-type ast constraint loc)
         (partial .constraint ast)))

  (all-symbols [ast]
    [ast])

  (pre-check [s]
    (se/try
      (comp (map (b/get-value s) (fn [new-s]
                                   (cond (and (instance? c/TaggedSymbol new-s)
                                              (= (.sym s) (.sym new-s)))
                                         new-s

                                         (.var s (.var new-s)))))
            (se/state-error s))
      (fn [_]
        (se/state-error s))))

  (type-check [s old-s]
    (map (b/get-value s)
         (fn [val]
           (.constraint s (.constraint val))))))

(extend-type ast/params-ast
  TypeChecker
  (set-local-var [ast]
    (flat-map (map ast set-local-var se/state-error)
              (fn [new-ast]
                (cond (= (.var new-ast) "")
                      (map (local-var 'seq)
                           (fn [new-var]
                             (.var new-ast new-var)))
                      (se/state-error new-ast)))))

  (update-constraint [ast constraint loc]
    (let [new-c (-> (.constraint ast)
                    (c/intersect c/seq-constraint)
                    (c/intersect (c/update-path constraint loc)))]
      (either (map (= c/bottom-type new-c)
                   (fn [_]
                     (b/compilation-error (b/conf-ass _LINE_ new-c loc))))
              (let [tail-item-cs (-> (c/get-items new-c)
                                     (drop (count (.fixed ast))))
                    item-cs (map (range (count (.fixed ast)))
                                 (fn [idx]
                                   (c/do-get-from new-c [idx] (list loc))))
                    tail-c (-> (c/seq-c tail-item-cs (c/get-tail new-c))
                               (c/replace-path (.path new-c)))]
                ;; TODO: these are possibly redundant intersects
                (for [_ (se/traverse (zip-lists (seq (.fixed ast)) item-cs)
                                     (fn [[ast c]]
                                       (update-constraint ast c loc)))
                      _ (update-constraint (.variadic ast) tail-c loc)]
                  (.constraint ast new-c))))))

  (all-symbols [params]
    (comp* (.variadic params)
           (seq (.fixed params))))

  (param-types [params]
    (-> (c/seq-c (.fixed params) (cond (= c/no-symbol (.variadic params))
                                       c/no-tail
                                       (.variadic params)))
        se/state-error))

  (type-check [ast old-ast]
    (let [c (-> (c/seq-c (map (.fixed ast) .constraint))
                (c/update-path (ast/location old-ast)))]
      (map (append-value-type (.variadic ast) c/list-constraint
                              (ast/location (.variadic ast)))
           (fn [appended-var]
             (-> ast
                 (.constraint (c/set-seq-tail c c/coll-of-any))
                 (.variadic (either (= c/no-symbol (.variadic ast))
                                    (.constraint (.variadic ast)
                                                 appended-var)))))))))

(deftype CheckOnly [sym c]
  Stringable
  (string-list [_]
    (list (str "(CheckOnly " sym " " c ")")))

  Container
  (map [y f embed]
    (embed y))

  TypeChecker
  (pre-check [x]
    (se/state-error x))

  (type-check [_ old-ast]
    (append-value-type sym c (ast/location sym))))

;; TODO: for extend-ast, fn-ast, type-ast, etc
;; the type checking should run recursively until the fixed point
(extend-type ast/extend-ast
  TypeChecker
  (pre-check [ast]
    (let [type-sym (.type ast)
          loc (ast/location ast)]
      (for [;; _ (map b/se-nop (fn [_]
            ;;                 (print-err 'extending _LINE_ (ast/location ast) (.type ast))))
            type-info (b/get-type-info type-sym)
            ;; TODO: don't allow extension of refined types
            :let [type-infos (cond (instance? c/SumConstraint type-info)
                                   (.alts type-info)
                                   [type-info])]
            new-ast (map ast
                         (fn [arity]
                           (assert (instance? ast/fn-arity-ast arity))
                           (either (-> (.params arity)
                                       .fixed
                                       first
                                       (map (fn [first-param]
                                              ;; (print-err 'params _LINE_ (ast/location first-param)
                                              ;; first-param)
                                              (-> type-infos
                                                  (map (fn [type-info]
                                                         (let [new-bod (comp
                                                                        [(CheckOnly first-param
                                                                                    type-info)]
                                                                        (.body arity))]
                                                           (ProtoArity (c/type-num type-info)
                                                                       (.body arity new-bod)))))
                                                  se/state-error))))
                                   (b/compilation-error "Prototype implentation for "
                                                      (str "'" (.fn-sym arity) "'")
                                                      "must have at least one parameter at"
                                                      (ast/location (.fn-sym arity)))))
                         se/state-error)]
        (-> (either (get new-ast .impls)
                    {})
            vals
            vec
            (map vals)
            (map vec)
            (conj (reify
                    Type
                    (type-name [_]
                      (str "reified at " (c/Location _FILE_ _LINE_)))

                    Stringable
                    (string-list [_]
                      (list (str "reified at " (c/Location _FILE_ _LINE_))))

                    Container
                    (map [y f embed]
                      (embed y))

                    TypeChecker
                    (pre-check [x]
                      (se/state-error (ast/block-comment-ast [] c/no-loc
                                                             c/top-type))))))))))

(extend-type ast/string-ast
  TypeChecker
  (set-global-var [ast]
    ast)

  (type-check [ast old-ast]
    (let [str-val (.string old-ast)]
      (-> ast
          (.constraint (.static c/strbuff-constraint str-val))
          (.var (b/global-var 'Str))
          se/state-error ))))

(extend-type ast/integer-ast
  TypeChecker
  (set-global-var [ast]
    ast)

  (type-check [ast old-ast]
    (-> ast
        (.constraint (-> (.static c/int-constraint (.int old-ast))
                         (c/update-path (ast/location old-ast))))
        (.var (b/global-var 'Int))
        se/state-error)))

(deftype PushTypes [expr]
  Stringable
  (string-list [pt]
    (list (str "(PushTypes " expr ")")))

  TypeChecker
  (pre-check [_]
    (flat-map (b/push-types)
              (fn [_]
                (pre-check expr)))))

(extend-type ast/either-ast
  TypeChecker
  (pre-check [ast]
    (-> ast
        (.alt (PushTypes (.alt ast)))
        se/state-error))

  (type-check [ast old-ast]
    (for [_ (b/pop-types)
          new-clause (update-constraint (.clause ast) c/maybe-constraint (ast/location old-ast))]
      (let [loc (ast/location old-ast)
            c (-> (c/sum-c [(c/type-op c/inner-type-of-op (.constraint new-clause))
                            (.constraint (.alt ast))])
                  (c/update-path (ast/location old-ast)))]
        (.constraint ast c)))))

(deftype Binder [binding val]
  Stringable
  (string-list [_]
    (list "(Binder " (str binding) " " (str val) ")"))

  Container
  (map [x f]
    (.val x (f val)))

  (map [x f embed]
    (map (f val)
         (partial .val x)))

  ast/FileLoc
  (ast/location [_]
    (ast/location binding))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (let [loc (ast/location val)]
      (for [_ (b/push-types)
            _ (se/traverse (all-syms (.binding ast))
                           (fn [sym]
                             (b/set-value sym (.constraint sym c/top-type))))]
        val))))

(extend-type ast/do-ast
  TypeChecker
  (type-check [ast old-ast]
    (-> ast
        (.constraint (either (map (last (.body ast)) .constraint)
                             c/top-type))
        se/state-error)))

(extend-type ast/binding-ast
  TypeChecker
  (set-global-var [ast]
    (.var ast (b/global-var b/Rslt)))

  (pre-check [ast]
    ;; (let [loc (ast/location (.cont ast))]
    ;;   (or ;; (= (.line loc) 0)
    ;;       ;; (= (.file loc) b/core)
    ;;    (and (or (= (.binding ast) 'xtrap)
    ;;             (= (.binding ast) 'flopper))
    ;;         (do
    ;;           (b/status 'checking-binding _LINE_ loc
    ;;                   lf 'binding (.binding ast)
    ;;                   lflf 'val (.val ast)
    ;;                   lflf 'cont (.cont ast))
    ;;           nothing))))
    (for [new-binding (set-local-var (.binding ast))]
      (let [new-val (.var (.val ast) (.var new-binding))]
        (-> ast
            (.binding new-binding)
            (.val (Binder new-binding new-val))))))

  (type-check [ast old-ast]
    (let [binding (.binding ast)
          val (.val ast)
          val-c (.constraint val)
          cont (remove (.cont ast)
                       (fn [ast]
                         (or (instance? c/Constraints ast)
                             (instance? ast/block-comment-ast ast))))
          cont-cs (map (.cont ast) (fn [ast]
                                     (cond (instance? c/ValueConstraint ast)
                                           ast

                                           (.constraint ast))))
          loc (ast/location old-ast)]
      (for [binding-c (map (get-param-types binding)
                           (fn [orig-binding-c]
                             (cata (fn [c]
                                     (cond (= c c/no-tail)
                                           c/top-type
                                           c))
                                   orig-binding-c)))
            _ (se/traverse (all-syms binding) b/recover-val)
            _ (b/nip-types)
            val (update-constraint val binding-c loc)]
        (let [val-c (.constraint val)
              last-expr (last cont)]
          ;; (or ;; (= (.line loc) 0)
          ;;     ;; (= (.file loc) b/core)
          ;;     (and (or (= (.binding ast) 'xtrap)
          ;;              (= (.binding ast) 'flopper))
          ;;          (do
          ;;            (b/status 'let _LINE_ loc
          ;;                    lflf 'binding (type-name binding) binding
          ;;                    lflf 'binding-c binding-c
          ;;                    lflf 'val val
          ;;                    lflf 'val-c val-c)
          ;;            nothing)))
          (-> ast
              (.var (either (map last-expr .var)
                            ""))
              (.constraint (either (map last-expr .constraint)
                                   c/top-type))
              (.val val)))))))

(extend-type ast/or-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (b/pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)
            new-ast (update-constraint (-> ast
                                           (.clause new-clause)
                                           (.cont new-cont))
                                       (c/sum-type [(.constraint new-clause)
                                                    (.constraint new-cont)])
                                       loc)]
        new-ast))))

(extend-type ast/and-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.cont ast (PushTypes (.cont ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          cont (.cont ast)
          loc (ast/location old-ast)]
      (for [_ (b/pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-clause (update-constraint clause c/maybe-constraint loc)
            new-cont (update-constraint cont c/maybe-constraint loc)]
        (-> ast
            (.constraint (.constraint new-cont))
            (.clause new-clause)
            (.cont new-cont))))))

(extend-type ast/cond-ast
  TypeChecker
  (pre-check [ast]
    (se/state-error (.value ast (PushTypes (.value ast)))))

  (type-check [ast old-ast]
    (let [clause (.clause ast)
          val (.value ast)
          cont (.cont ast)]
      (for [_ (b/pop-types)
            ;; TODO: when the ast of the clause is a call to instance?,
            ;; recover the type of the symbol in the second arg
            new-c (update-constraint clause c/maybe-constraint (ast/location old-ast))]
        (-> ast
            (.clause new-c)
            (.constraint (c/sum-c [(.constraint val)
                                   (.constraint cont)])))))))

(def pre-defed-types {'HashSet c/HashSetType
                      'ProtoDispatcher c/ProtoDispatcherType
                      'NoValues c/NoValuesType
                      'AllValues c/AllValuesType
                      ;; TODO: remove ones no longer used
                      'ResultConstraint c/ResultConstraintType
                      'InferredInner c/InferredInnerType
                      'ContentsConstraint c/ContentsConstraintType
                      'SumConstraint c/SumConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? c/TaggedSymbol type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract b/type-counter)))

(deftype DestructFields [type-info fields loc]
  (assert (instance? c/ReifiedConstraint type-info))
  (assert (instance? c/Location loc))
  (assert (instance? (vector-of c/TaggedSymbol) fields))

  Stringable
  (string-list [_]
    (list "(DestructFields " (to-str fields) " " (str loc) ")"))

  Container
  (map [x f] x)
  (map [x f embed] (embed x))

  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (for [arity-val (b/get-value curr-arity)
          :let [param (c/param (either (get-in arity-val [.constraint .arities c/variadic .arity-id])
                                       (c/tag ""))
                               0)]
          _ (append-value-type (.sym type-info) type-info loc)
          _ (se/traverse fields
                         (fn [fld]
                           (append-value-type fld
                                              (c/type-op c/get-from-op param
                                                         [(c/Field (c/tag (str "." fld) loc))])
                                              loc)))]
      (ast/block-comment-ast [] c/no-loc c/top-type))))

(def x* (c/tag "#x"))
(def y* (c/tag "#y"))
(def field* (c/tag "#field"))
(def ctxt* (c/tag "#ctxt"))

(defn constrain-first-param [ast type-info fields loc]
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? c/ReifiedConstraint type-info))

   (either (-> (.params ast)
              .fixed
              first
              (map (fn [first-param]
                     (ProtoArity (c/type-num type-info)
                                 (.body ast (comp [(DestructFields (.sym type-info first-param)
                                                                   fields loc)]
                                                  (.body ast)))))))

          (do
            ;; (b/compilation-error "Prototype implentation for "
            ;;                    (str "'" (.fn-sym c) "'")
            ;;                    "must have at least one parameter at"
            ;;                    (ast/location (.fn-sym c)))
            (print-err 'BOOOMMMM _LINE_ ast)
            (abort)
            ast)))

(extend-type ast/rec-type-ast
  TypeChecker
  (pre-check [ast]
    (let [loc (ast/location ast)]
      (se/state-error (comp (map (.types ast) (fn [type]
                                                (ast/type-ast (.sym type) c/no-fields [])))
                            [(ast/definition (.sym ast)
                               [(c/SumConstraint
                                 (map (.types ast) (fn [type]
                                                     (.type-symbol c/empty-reified
                                                                   (.sym type))))
                                 (list loc)
                                 c/no-symbol)])]
                            (.types ast)
                            [(ast/definition (.sym ast)
                               [(c/SumConstraint
                                 (map (.types ast) (fn [type]
                                                     (.type-symbol c/empty-reified
                                                                   (.sym type))))
                                 (list loc)
                                 c/no-symbol)])])))))

(extend-type ast/quoted-ast
  TypeChecker
  (set-global-var [ast]
    (.var ast (b/global-var 'Quoted)))

  (pre-check [ast]
    (se/state-error (reify
                      Type
                      (type-name [_]
                        (str "reified at " _LINE_))

                      Stringable
                      (string-list [_]
                        (list (str "'" (.q-val ast))))

                      Eq
                      (=* [_ y]
                        (= y (.q-val ast)))

                      Container
                      (map [x f]
                        x)

                      (map [x f embed]
                        (embed x))

                      ast/FileLoc
                      (ast/location [_]
                        (ast/location ast))

                      TypeChecker
                      (type-check [_ old-ast]
                        (se/state-error (.constraint ast (-> c/sym-constraint
                                                             (.static (c/tag (rest (str ast))))
                                                             (c/update-path (ast/location ast))))))))))

(defn check-ast [ast]
  (cond (instance? c/Constraints ast)
        (cond (instance? c/SymbolConstraints ast)
              (cond (instance? c/TypeOfConstraint ast)
                    (type-check ast ast)

                    (flat-map (map ast check-ast se/state-error)
                              (fn [r]
                                (type-check r ast))))

              (instance? c/ProtoImpls ast)
              (se/state-error ast)

              (se/state-error ast))

        (for [new-ast (pre-check ast)
              ;; :let [loc (ast/location ast)
              ;;       _ (and (= (.file loc) "assertion-tests/closure-param.toc")
              ;;              (do
              ;;                (b/status 'type-checking _LINE_ loc
              ;;                        lflf 'ast ast
              ;;                        lflf 'new-ast new-ast)
              ;;                nothing))]
              newer-ast (map new-ast check-ast se/state-error)
              ;; :let [loc (ast/location ast)
              ;;       _ (and ;; (instance? ast/either-ast ast)
              ;;          (> (.line loc) 3016)
              ;;          (do
              ;;            (b/status 'type-checking _LINE_ loc
              ;;                    lflf 'newer-ast newer-ast
              ;;                    lflf 'new-ast new-ast)
              ;;            (b/wait-for-err-out)
              ;;            nothing))]
              final-ast (type-check newer-ast new-ast)]
          (do
            ;; (let [loc (ast/location ast)]
            ;;   (and ;; (extract flag)
            ;;        (maybe (b/status 'final-ast _LINE_ loc
            ;;                          lflf final-ast))))
            final-ast))))

(extend-type ast/type-ast
  TypeChecker
  (pre-check [ast]
    (cond (= (.fields ast) c/no-fields)
          (let [sym (.sym ast)
                loc (ast/location sym)]
            (b/set-type-info sym
                             (-> (c/ReifiedConstraint (new-type-number sym)
                                                      sym {} {c/contents c/top-type}
                                                      c/fn-constraint
                                                      empty-list c/no-symbol)
                                 (c/update-path loc))))
          (let [sym (.sym ast)
                loc (ast/location sym)
                type-num (new-type-number sym)
                fields (-> ast .fields .fixed)
                field-count (count fields)]
            (for [_ (b/push-types)
                  ;; clear previous constraints for the fields
                  _ (se/traverse fields (fn [sym]
                                          (b/set-value sym (.constraint sym c/top-type))))

                  ;; then add all the explicit constraints for the fields
                  ;; and collect them in 'field-cs'
                  _ (-> (.impls ast)
                        (filter (partial instance? c/SymbolConstraints))
                        (se/traverse (fn [field-c]
                                       (cond (some fields (partial = (.sym field-c)))
                                             (check-ast field-c)

                                             (b/compilation-error
                                              (b/conf-ass _LINE_
                                                        (c/NoValues [field-c
                                                                     (.type-symbol c/empty-reified
                                                                                   (c/tag (str "Field '" (.sym field-c) "' doesn't exist")))])
                                                        loc))))))
                  field-vals (se/traverse fields b/get-value)
                  :let [field-cs (map field-vals .constraint)
                        idxs (integer-gen 1)
                        field-pairs (map (zip-lists fields field-cs)
                                         (fn [[fld-name fld-c]]
                                           [(c/Field (c/tag (str "." fld-name)))
                                            fld-c
                                            (new-int idxs)]))
                        fields-map (reduce field-pairs {} conj)
                        new-type-constraint (-> (c/ReifiedConstraint type-num sym
                                                                     fields-map
                                                                     (assoc fields-map
                                                                       c/contents c/top-type)
                                                                     c/fn-constraint
                                                                     empty-list c/no-symbol)
                                                (c/update-path loc))
                        ctor-sym (c/tag (str "* " sym " constructor at " loc" *") loc)
                        ctor-arity (c/fn-arity
                                    ctor-sym
                                    (c/seq-c (comp [c/top-type] field-cs))
                                    (-> c/empty-reified
                                        (.type-symbol sym)
                                        (.fields (reduce field-pairs {}
                                                         (fn [fields-map [fld fld-c idx]]
                                                           (assoc fields-map
                                                             fld
                                                             (c/intersect (c/param ctor-sym idx)
                                                                          fld-c)))))
                                        (assoc-in [.fields c/contents] c/top-type)))
                        ctor-type-num (extract b/type-counter)
                        constructor (c/ReifiedConstraint ctor-type-num ctor-sym
                                                         {} {}
                                                         (.arities c/fn-constraint
                                                                   {(inc field-count) ctor-arity})
                                                         empty-list c/no-symbol)
                        ctor-params (.fixed (.fields ast)
                                            (comp [(c/tag (symbol "#ctor"))]
                                                  fields))
                        ctor-apply-id (c/tag (str "apply-" sym "-constructor") loc)
                        ctor-apply-fields (c/seq-c field-cs)
                        ctor-apply (c/fn-arity ctor-apply-id
                                               (c/seq-c [(c/multi [(c/param ctor-apply-id 0)
                                                                   constructor])
                                                         (c/multi [(c/param ctor-apply-id 1)
                                                                   ctor-apply-fields])])
                                               (c/type-op c/apply-op constructor
                                                          (c/multi [(c/param ctor-apply-id 1)
                                                                    ctor-apply-fields])))]
                  _ (b/set-type-info ctor-sym constructor)
                  _ (b/add-proto-impl ctor-type-num b/invoke-sym (inc field-count)
                                      (ast/fn-arity-ast b/invoke-sym (b/global-var b/invoke-sym)
                                                        ctor-params "" [] ctor-arity))
                  _ (b/add-proto-impl ctor-type-num b/apply-sym 2
                                      (ast/fn-arity-ast b/apply-sym (b/global-var b/apply-sym)
                                                        (ast/params [(c/tag (symbol "#app"))
                                                                     (c/tag (symbol "#fields"))])
                                                        "" [] ctor-apply))
                  ;; TODO: need instance? impl constraint
                  _ (b/set-type-info sym new-type-constraint)
                  _ (b/set-value sym (.constraint sym constructor))

                  _ (se/traverse (vec fields-map)
                                 (fn [[field fld-c]]
                                   (let [fld-sym (.sym field)
                                         getter-id (c/tag (str sym "-" fld-sym "-getter"))
                                         getter-param (c/param getter-id 0)
                                         setter-id (c/tag (str sym "-" fld-sym "-setter"))
                                         setter-param-0 (c/param setter-id 0)
                                         setter-param-1 (c/param setter-id 1)]
                                     (b/add-getter-impls fld-sym type-num
                                                         (c/fn-arity
                                                          getter-id
                                                          (c/seq-c [(c/multi [new-type-constraint
                                                                              getter-param])])
                                                          (-> (c/type-op c/get-from-op getter-param
                                                                         [field])
                                                              (c/intersect fld-c)))
                                                         (c/fn-arity
                                                          setter-id
                                                          (c/seq-c [(c/multi [new-type-constraint
                                                                              setter-param-0])
                                                                    (c/multi [setter-param-1
                                                                              fld-c])])
                                                          (c/type-op c/set-to-op setter-param-0
                                                                     [[field] setter-param-1]))
                                                         loc))))]
              (let [impls (elgot (fn [ast]
                                   (cond (instance? HashMap ast)
                                         (RecurseWith (vec (vals ast)))

                                         (instance? ast/fn-arity-ast ast)
                                         (RecurseFinal
                                          (constrain-first-param ast new-type-constraint
                                                                 fields loc))

                                         (RecurseWith ast)))
                                 (fn [v]
                                   (cond (instance? Vector v)
                                         (reduce v []
                                                 (fn [new-v inner]
                                                   (cond (instance? Vector inner)
                                                         (comp new-v inner)
                                                         (conj new-v inner))))

                                         v))
                                 (remove (.impls ast)
                                         (partial instance? c/SymbolConstraints)))
                    ;; TODO: make sure the impls for 'get' and 'assoc' have constraints on their result
                    ;; and parameter, respectively
                    [invokes others] (reduce impls [[] []]
                                             (fn [[invoke-fns others] pa]
                                               (cond (flat-map (get-in pa [.arity .fn-sym])
                                                               (partial = b/invoke-sym))
                                                     [(conj invoke-fns pa) others]
                                                     [invoke-fns (conj others pa)])))]
                [invokes
                 others
                 (reify
                   Type
                   (type-name [_]
                     (str "reified at " (c/Location _FILE_ _LINE_)))

                   Container
                   (map [y f embed]
                     (embed y))

                   TypeChecker
                   (pre-check [x]
                     (se/state-error x))

                   (type-check [_ _]
                     (let [get-id (c/tag (str sym "_get") loc)
                           getter-ast (ast/fn-arity-ast b/apply-sym (b/global-var b/apply-sym)
                                                        (ast/params [(c/tag (symbol "#field") loc)
                                                                     (c/tag (symbol "#x") loc)])
                                                        "" []
                                                        (c/fn-arity
                                                         get-id
                                                         (c/seq-c [(c/multi [new-type-constraint
                                                                             (c/param get-id 0)])
                                                                   (c/param get-id 1)])
                                                         (c/MaybeConstraint
                                                          (c/type-op c/get-from-op (c/param get-id 0)
                                                                     [(c/param get-id 1)])
                                                          empty-list c/no-symbol)))
                           set-id (c/tag (str sym "_set") loc)
                           setter-ast (ast/fn-arity-ast b/apply-sym (b/global-var b/apply-sym)
                                                        (ast/params [(c/tag (symbol "#field") loc)
                                                                     (c/tag (symbol "#x") loc)
                                                                     (c/tag (symbol "#val") loc)])
                                                        "" []
                                                        (c/fn-arity
                                                         set-id
                                                         (c/seq-c [(c/multi [new-type-constraint
                                                                             (c/param set-id 0)])
                                                                   (c/param set-id 1)
                                                                   (c/param set-id 2)])
                                                         (c/type-op c/set-to-op (c/param set-id 0)
                                                                    [[(c/param set-id 1)]
                                                                     (c/param set-id 2)])))]
                       (for [_ (b/pop-types)
                             _ (comp (b/get-proto-impl (c/tag 'get) type-num 2)
                                     (b/add-proto-impl type-num (c/tag 'get loc) 2
                                                       getter-ast))
                             _ (comp (b/get-proto-impl (c/tag 'assoc) type-num 3)
                                     (b/add-proto-impl type-num (c/tag 'assoc loc) 3
                                                       setter-ast))
                             _ (b/set-value sym (.constraint sym constructor))]
                         (ast/block-comment-ast [] c/no-loc c/top-type)))))

                 ;; (reify
                 ;;   Container
                 ;;   (map [y f embed]
                 ;;     (embed y))

                 ;;   TypeChecker
                 ;;   (pre-check [ast]
                 ;;  report-type-stack
                 ;;     (for [ft (se/get-val .value-types)
                 ;;           mby (get-value-type maybe-sym)]
                 ;;       (do
                 ;;         (b/status 'vts _LINE_ sym (count ft)
                 ;;                 lflf 'maybe mby)
                 ;;         (ast/block-comment-ast [] c/no-loc c/top-type)))))
                 ]))))))


(extend-type ast/IsType
  TypeChecker
  (pre-check [ast]
    (for [_ (b/push-types)
          _ (either (map (= (.ast ast) '_)
                         (fn [_]
                           (b/status "Type at:" (ast/location (.ast ast))
                                   (.expected ast))
                           b/se-nop))
                    (flat-map (se/try
                                (check-ast (.ast ast))
                                (fn [err]
                                  (b/status (.val err))
                                  (se/state-error (.constraint (.ast ast) c/bottom-type))))
                              (fn [c]
                                (either (map (= (c/trim (.constraint c)) (.expected ast))
                                             se/state-error)
                                        (b/compilation-error "Type Error:" (ast/location (.ast ast))
                                                           lf 'ast (.ast ast)
                                                           lflf 'expected (.expected ast)
                                                           lflf 'actual (either (get c .constraint)
                                                                                  c))))))
          _ (b/pop-types)]
      (ast/block-comment-ast [] c/no-loc c/top-type))))

(extend-type ast/GetImpl
  TypeChecker
  (pre-check [ast]
    (se/state-error ast))

  (type-check [ast old-ast]
    (cond (= c/no-symbol (.type-sym ast))
          (se/state-error (.constraint ast (-> ast .impl-sym .constraint .default-impl)))

          (flat-map (b/get-type-info (.type-sym ast))
                    (fn [c]
                      (let [type-num (c/type-num c)]
                        (either (map (get-in ast [.impl-sym .constraint .impl-fns type-num])
                                     (fn [impl-c]
                                       (se/state-error (.constraint ast impl-c))))
                                (b/compilation-error "Could not find impl for" (str "'" (.type-sym ast)
                                                                                  "' (" type-num ")")
                                                     "at" (ast/location (.type-sym ast))))))))))
