
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "45e2277"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))
;; (def path-to-core (str toccata-dir "/new-core.toc"))
(def path-to-core (str toccata-dir "/no-core.toc"))
(def core (c/ToccataCore path-to-core))
(def main (c/tag 'main))

(def type-counter (int-generator c/TypeCount))

(def err-out (agent (maybe 'err-out)))

(def lf "\n")
(def lflf "\n\n")

(defn status [& msg]
  (send err-out (fn [out-file?]
                  ;; (assert (instance? Maybe out-file?))

                  ;; (and out-file?
                  ;;      (maybe (apply print-err msg)))

                  (apply print-err msg)
                  ;; (map out-file?
                  ;;      (fn [out-file]
                  ;;        (fio/write out-file (str (to-str (interpose msg " ")) lf))
                  ;;        out-file))
                  )))

(defn wait-for-err-out []
  (let [p (promise)]
    (send err-out (fn [outfile]
                    (deliver p outfile)
                    outfile))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (flat-map se-nop
            (fn [_]
              (let [msg (to-str (interpose msg " "))]
                (se/throw msg)))))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 lf
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(def output (agent (maybe 'output)))

(defn code-out [& code]
  (send output (fn [out-file?]
                 (hylo (fn [x]
                         (cond (or (instance? String x)
                                   (instance? Integer x))
                               (do
                                 (print x)
                                 [])

                               x))
                       (fn [x]
                         (cond (instance? Sequence x)
                               x

                               (print x)))
                       code)
                 out-file?)))

(defn wait-for-output []
  (let [p (promise)]
    (send output (fn [outfile]
                   (deliver p outfile)
                   outfile))
    (extract p)))

(deftype Module [path index protocols namespaces types value-types]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol)
                             Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (let [core-prom (promise)]
    ;; (send modules (fn [mods]
    ;;                 (map (get mods core)
    ;;                      (partial deliver core-prom))
    ;;                 mods))
    (Module file-name module-index {}
            (cond (= module-index 0)
                  {}
                  {core core-mod})
            c/core-type-constraints
            (list {'empty-list (c/update-sym c/empty-list-constraint
                                             (c/tag 'empty-list))
                   'empty-vector (c/update-sym c/empty-vect-constraint
                                               (c/tag 'empty-vector))
                   'int-max (.max c/int-constraint int-max)
                   'int-min (.min c/int-constraint int-min)
                   'nothing (c/update-sym c/nothing-constraint
                                          (c/tag 'nothing))}))))
