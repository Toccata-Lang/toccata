
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f93f741"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))
(def path-to-core (str toccata-dir "/new-core.toc"))
(def core (c/ToccataCore path-to-core))

(def type-counter (int-generator c/TypeCount))

(def err-out (agent (maybe 'err-out)))

(def lf "\n")
(def lflf "\n\n")

(defn status [& msg]
  (send err-out (fn [out-file?]
                  ;; (assert (instance? Maybe out-file?))

                  ;; (and out-file?
                  ;;      (maybe (apply print-err msg)))

                  (apply print-err msg)
                  ;; (map out-file?
                  ;;      (fn [out-file]
                  ;;        (fio/write out-file (str (to-str (interpose msg " ")) lf))
                  ;;        out-file))
                  )))

(defn wait-for-err-out []
  (let [p (promise)]
    (send err-out (fn [outfile]
                    (deliver p outfile)
                    outfile))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (flat-map se-nop
            (fn [_]
              (let [msg (to-str (interpose msg " "))]
                (se/throw msg)))))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 lf
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype Module [path index namespaces types values var-count]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol)
                             Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls and static values
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; values          list of maps of symbols to ast's
  (assert (instance? (list-of HashMap) values))
  ;; var-count       stack of var counters
  (assert (instance? (list-of IntGenerator) var-count))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (Module file-name module-index
          (cond (= module-index 0)
                {}
                {core core-mod})
          c/core-type-constraints
          (list {'empty-list (-> (c/tag 'empty-list)
                                 (.constraint c/empty-list-constraint))
                 'empty-vector (-> (c/tag 'empty-vector)
                                   (.constraint c/empty-vect-constraint))
                 'int-max (-> (c/tag 'int-max)
                              (.constraint (.max c/int-constraint int-max)))
                 'int-min (-> (c/tag 'int-main)
                              (.constraint (.min c/int-constraint int-min)))
                 'nothing (-> (c/tag 'nothing)
                              (.constraint c/nothing-constraint))})
          (list (int-generator 0))))

(defn add-getter-val [sym vals-list]
  (assert (instance? c/TaggedSymbol sym))
  (assert (instance? (list-of HashMap) vals-list))
  (assert-result r (instance? (list-of HashMap) r))

  ;; 'sym' already has '.' at front
  (let [field-sym (c/Field sym)
        required-field (-> c/empty-reified
                           (.fields {field-sym c/top-type})
                           (.type-symbol (c/tag (str "field '" (rest (str sym)) "' required"))))
        getter-sym (c/tag (str sym "_getter"))
        setter-sym (c/tag (str sym "_setter"))
        arities {1 (c/fn-arity getter-sym
                               (c/seq-c [(c/multi [(c/param getter-sym 0)
                                                   required-field])])
                               (c/type-op c/get-from-op (c/param getter-sym 0)
                                          [field-sym]))
                 2 (c/fn-arity setter-sym
                               (c/seq-c [(c/multi [(c/param setter-sym 0)
                                                   required-field])
                                         (c/param setter-sym 1)])
                               (c/type-op c/set-to-op (c/param setter-sym 0)
                                          [[field-sym] (c/param setter-sym 1)]))}
        getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})]
    (cond (empty? vals-list)
          (list {sym (.constraint sym getter)})

          (get-in vals-list [0 sym])
          vals-list

          (map vals-list (fn [values]
                           (-> values
                               (dissoc sym)
                               (assoc sym (.constraint sym getter))))))))

(defn set-val-hist [sym val]
  (fn [vals-list]
    (assert (instance? List vals-list))

    (cond (empty? vals-list)
          (list {sym sym})

          (map vals-list (fn [values]
                           (-> values
                               (dissoc sym)
                               (assoc sym sym)))))))

(defn get-core-value [sym]
  (assert (instance? c/TaggedSymbol sym))

  ;; TODO: refactor this to make it pretty some day
  (se/new-se (fn [s]
               (assert (instance? Module s))

               (either (or (and (= 0 (.index s))
                                (map (get-in s [.values 0 sym])
                                     (fn [val]
                                       [val s])))
                           (map (get-in s [.namespaces core .values 0 sym])
                                (fn [val]
                                  [val s]))
                           (for [dot (first (str sym))
                                 _ (= "." dot)]
                             (let [field-sym (c/Field sym)
                                   type-sym (c/tag (str "field '" (rest (str sym)) "' required"))
                                   required-field (-> c/empty-reified
                                                      (.fields {field-sym c/top-type})
                                                      (.type-symbol type-sym))
                                   getter-sym (c/tag (str sym "_getter"))
                                   setter-sym (c/tag (str sym "_setter"))
                                   arities {1 (c/fn-arity getter-sym
                                                          (c/seq-c [(c/multi [(c/param getter-sym 0)
                                                                              required-field])])
                                                          (c/type-op c/get-from-op
                                                                     (c/param getter-sym 0)
                                                                     [field-sym]))
                                            2 (c/fn-arity setter-sym
                                                          (c/seq-c [(c/multi [(c/param setter-sym 0)
                                                                              required-field])
                                                                    (c/param setter-sym 1)])
                                                          (c/type-op c/set-to-op (c/param setter-sym 0)
                                                                     [[field-sym]
                                                                      (c/param setter-sym 1)]))}
                                   getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})
                                   sym (.constraint sym getter)
                                   new-s (either (or (and (= 0 (.index s))
                                                          (update s .values
                                                                  (set-val-hist sym sym)))

                                                     (update-in s [.namespaces core .values]
                                                                (set-val-hist sym sym)))
                                                 s)]
                               (cond (instance? Module s)
                                     '_
                                     (do
                                       (print-err 'wjoops _LINE_ s)
                                       (abort)))
                               [sym new-s])))
                       se/Failure))))

(defn get-value [sym]
  (assert (instance? c/TaggedSymbol sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (= sym c/no-symbol)
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (let [loc (ast/location sym)]
          ;; TODO: this does not look up namespaced symbols
          (comp (se/get-in-val [.values 0 sym])
                (get-core-value sym)
                (compilation-error "Undefined symbol:" (str "'" sym "'") "at" loc)))))

(defn get-proto-impl [sym type-num arity-rank]
  (se/try
    (flat-map (get-value sym)
              (fn [val]
                (either (map (get-in val [.constraint .impl-fns type-num .arities arity-rank])
                             se/state-error)
                        se/zero-se)))
    (fn [_]
      se/zero-se)))

(defn set-value [sym val]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? (any-of c/OptionalSym
                             ast/AST)
                     val))

  (cond (= c/no-symbol sym)
        (se/state-error val)

        (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ (ast/location val) val)
          se-nop)

        (map (se/update-val .values
                            (fn [values-list]
                              (either (map (first values-list)
                                           (fn [values]
                                             (-> values
                                                 (dissoc sym)
                                                 (assoc sym val)
                                                 (cons (rest values-list)))))
                                      (list {sym val}))))
             (fn [_]
               val))))

(deftype ModuleSetup [init cleanup]
  ;; init               strings to initialize the module
  (assert (instance? Vector init))
  ;; cleanup            strings to initialize the module
  (assert (instance? Vector cleanup)))

(deftype ConstantValues [numbers strings ;; symbols type-names encoded other
                         ]
  ;; numbers                static numbers
  (assert (instance? (map-of Integer String) numbers))
  ;; strings                static strings
  (assert (instance? (map-of String String) strings))
  ;; symbols                static symbols
  ;; (assert (instance? (map-of Symbol String) symbols))
  ;; type-names             map of type numbers to type names
  ;; (assert (instance? (map-of Integer String) type-names))
  ;; encoded                cache of values that have been statically encoded
  ;; (assert (instance? HashMap encoded))
  )

(def empty-constants (ConstantValues {} {}))

(deftype CodeContext [constants mod-setups]
  (assert (instance? ConstantValues constants))
  ;; mod-setups   map of filenames to ModuleSetup
  (assert (instance? HashMap mod-setups))
  )

(deftype StaticArity [arity arity-var]
  (assert (instance? ast/fn-arity-ast arity))
  (assert (instance? String arity-var))

  Stringable
  (string-list [_]
    (list "(b/StaticArity " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (fn [new-arity]
           (.arity x new-arity)))))

(def var-punct {"*" "_STAR_"
                "." ""
                "#" "_HASH_"
                "+" "_PLUS_"
                "?" "_QM_"
                "!" "_BANG_"
                "=" "_EQ_"
                "<" "_LT_"
                ">" "_GT_"})

(def C-var-punct (apply-to (fn [punct-char]
                             (either (get var-punct punct-char)
                                     ""))
                           (apply grmr/any (keys var-punct))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (apply-to (fn [start remaining]
                       (to-str (comp [start] remaining)))
                     (grmr/any grmr/alpha
                               (grmr/all (grmr/ignore "#")
                                         (grmr/always ""))
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_MINUS_"))
                               C-var-punct)
                     C-var-remaining))

(def C-var (rd/parser C-var))

(defn check-C-var [var-name alt-var]
  ;; TODO: put this in after the original works
  ;; (either (map (instance? Vector (C-var var-name))
  ;;              (fn [[c-var]]
  ;;                c-var))

  ;;         alt-var)
  (let [parse-result (C-var var-name)]

    (cond (instance? Vector parse-result)
          (let [[c-var] parse-result]
            c-var)

          alt-var)))

(def global-vars (int-generator 0))

(defn global-var
  ([arg-name]
   (global-var c/no-symbol arg-name))
  ([sym arg-name]
   (str "glbl" (check-C-var (str sym) arg-name)
        (extract global-vars))))
