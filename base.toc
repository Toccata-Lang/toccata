
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "cd0abb2"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))
(def path-to-core (str toccata-dir "/new-core.toc"))
(def core (c/ToccataCore path-to-core))

(def type-counter (int-generator c/TypeCount))

(def err-out (agent (maybe 'err-out)))

(def lf "\n")
(def lflf "\n\n")
(def invoke-sym (c/tag 'invoke))
(def apply-sym (c/tag 'apply))
(def CFn "CFn")
(def Arity "Arity")
(def Rslt "Rslt")
(def Fn "Fn")

(defn status [& msg]
  (send err-out (fn [out-file?]
                  ;; (assert (instance? Maybe out-file?))

                  ;; (and out-file?
                  ;;      (maybe (apply print-err msg)))

                  (apply print-err msg)
                  ;; (map out-file?
                  ;;      (fn [out-file]
                  ;;        (fio/write out-file (str (to-str (interpose msg " ")) lf))
                  ;;        out-file))
                  )))

(defn wait-for-err-out []
  (let [p (promise)]
    (send err-out (fn [outfile]
                    (deliver p outfile)
                    outfile))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (flat-map se-nop
            (fn [_]
              (let [msg (to-str (interpose msg " "))]
                (se/throw msg)))))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 lf
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype SymTable [path types values]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls and static values
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; values          list of maps of symbols to ast's
  (assert (instance? (list-of HashMap) values))

  Stringable
  (string-list [_] (list "<SymTable '" (str path) "'>")))

(deftype Module [file-name index namespaces var-count]
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol c/NoSymbol)
                             SymTable)
                     namespaces))
  ;; var-count       stack of var counters
  (assert (instance? (list-of IntGenerator) var-count))

  Stringable
  (string-list [_] (list "<Module '" (str file-name) "'>")))

(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (cond (= module-index 0)
        (Module core module-index
                {c/no-symbol (SymTable core
                                       c/core-type-constraints
                                       (list {'empty-list (-> (c/tag 'empty-list)
                                                              (.constraint c/empty-list-constraint))
                                              'empty-vector (-> (c/tag 'empty-vector)
                                                                (.constraint c/empty-vect-constraint))
                                              'int-max (-> (c/tag 'int-max)
                                                           (.constraint (.static c/int-constraint
                                                                                 int-max)))
                                              'int-min (-> (c/tag 'int-main)
                                                           (.constraint (.static c/int-constraint
                                                                                 int-min)))
                                              'nothing (-> (c/tag 'nothing)
                                                           (.constraint c/nothing-constraint))}))}
                (list (int-generator 0)))
        (Module file-name module-index
                {core (either (get-in core-mod [.namespaces c/no-symbol])
                              (SymTable core
                                        {}
                                        (list {})))
                 c/no-symbol (SymTable file-name
                                       {}
                                       (list {}))}
                (list (int-generator 0)))))

(defn report-type-stack [& msg]
  (map (se/get-in-val [.namespaces c/no-symbol .values])
       (fn [vts]
         (status 'type-depth (to-str (interpose msg " "))
                 (count vts)))))

(defn push-types []
  (se/update-in-val [.namespaces c/no-symbol .values]
                    (fn [vals-list]
                      (either (map (first vals-list)
                                   (fn [values]
                                     (conj vals-list values)))
                              (list {})))))

(defn pop-types []
  (se/update-in-val [.namespaces c/no-symbol .values] rest))

(defn nip-types []
  ;; Bringing the Forth to Toccata
  (se/update-in-val [.namespaces c/no-symbol .values]
                    (fn [vals-list]
                      (either (map (first vals-list)
                                   (fn [values]
                                     (cons values (drop vals-list 2))))
                              vals-list))))

(defn set-val-hist [sym val]
  (fn [vals-list]
    (assert (instance? List vals-list))

    (cond (empty? vals-list)
          (list {sym val})

          (map vals-list (fn [values]
                           (-> values
                               (dissoc sym)
                               (assoc sym val)))))))

(defn add-getter [sym s]
  (let [field-sym (c/Field sym)
        type-sym (c/tag (str "field '" (rest (str sym)) "' required"))
        required-field (-> c/empty-reified
                           (.fields {field-sym c/top-type})
                           (.type-symbol type-sym))
        getter-sym (c/tag (str sym "_getter"))
        setter-sym (c/tag (str sym "_setter"))
        arities {1 (c/fn-arity getter-sym
                               (c/seq-c [(c/multi [(c/param getter-sym 0)
                                                   required-field])])
                               (c/type-op c/get-from-op
                                          (c/param getter-sym 0)
                                          [field-sym]))
                 2 (c/fn-arity setter-sym
                               (c/seq-c [(c/multi [(c/param setter-sym 0)
                                                   required-field])
                                         (c/param setter-sym 1)])
                               (c/type-op c/set-to-op (c/param setter-sym 0)
                                          [[field-sym]
                                           (c/param setter-sym 1)]))}
        getter (c/ProtoImpls sym (.arities c/fn-constraint arities) {})
        sym (.constraint sym getter)
        new-s (either (update-in s [.namespaces (cond (= 0 (.index s))
                                                      c/no-symbol
                                                      core)
                                    .values]
                                 (set-val-hist sym sym))
                      s)]
    [sym new-s]))

(defn get-core-value [sym]
  (assert (instance? c/TaggedSymbol sym))

  ;; TODO: refactor this to make it pretty some day
  (se/new-se (fn [s]
               (assert (instance? Module s))

               (either (or (map (get-in s [.namespaces (cond (= 0 (.index s))
                                                             c/no-symbol
                                                             core)
                                           .values 0 sym])
                                (fn [val]
                                  [val s]))
                           (for [dot (first (str sym))
                                 _ (= "." dot)]
                             (add-getter sym s)))
                       se/Failure))))

(defn get-value [sym]
  (assert (instance? c/TaggedSymbol sym))

  (cond (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (= sym c/no-symbol)
        (do
          (print-err 'compiler-error _LINE_)
          (se/state-error c/top-type))

        (comp (cond (= c/no-symbol (.ns sym))
                    (comp (se/get-in-val [.namespaces (.ns sym) .values 0 sym])
                          (get-core-value sym))

                    (se/get-in-val [.namespaces (.ns sym) .values 0 sym]))
              (compilation-error "Undefined symbol:" (str "'" sym "'") "at" (ast/location sym)))))

(defn get-proto-impl [sym type-num arity-rank]
  (se/try
    (flat-map (get-value sym)
              (fn [val]
                (either (map (get-in val [.constraint .impl-fns type-num .arities arity-rank])
                             se/state-error)
                        se/zero-se)))
    (fn [_]
      se/zero-se)))

(defn set-value [sym val]
  (assert (instance? c/OptionalSym sym))
  (assert (instance? (any-of c/OptionalSym
                             ast/AST)
                     val))

  (cond (= c/no-symbol sym)
        (se/state-error val)

        (= (str sym) "")
        (do
          (print-err 'compiler-error _LINE_ (ast/location val) val)
          se-nop)

        ;; only allowed to update ProtoImpls for ns qualified symbols
        (or (= c/no-symbol (.ns sym))
            (instance? c/ProtoImpls (.constraint val)))
        (map (se/update-in-val [.namespaces (.ns sym) .values]
                               (fn [values-list]
                                 (either (map (first values-list)
                                              (fn [values]
                                                (-> values
                                                    (dissoc sym)
                                                    (assoc sym val)
                                                    (cons (rest values-list)))))
                                         (list {sym val}))))
             (fn [_]
               val))

        (se/state-error val)))

(defn add-impl-c [proto-impls type-num arg-count arity-c loc]
  (instance? c/ProtoImpls proto-impls)

  (either (map (get-in proto-impls [.default-impl .arities arg-count])
               (fn [dflt-arity]
                 (let [idxs (integer-gen 0)
                       new-params (-> (.param-consts dflt-arity)
                                      c/get-items
                                      (reduce [] (fn [params param]
                                                   (conj params (c/param (.arity-id arity-c)
                                                                         (new-int idxs))))))
                       ;; TODO: need to account for destructuring of params
                       dflt-arity (cond (= (str (.arity-id dflt-arity)) "")
                                        dflt-arity

                                        (c/reify-type-constraint dflt-arity
                                                                 (.arity-id dflt-arity)
                                                                 new-params loc))
                       new-arity-c (c/intersect arity-c dflt-arity)]
                   ;; (cond (and (= c/ListType type-num)
                   ;;            (= (.fn-sym proto-impls) 'vec))
                   ;;       (status 'proto-result _LINE_ loc
                   ;;               lflf 'def dflt-arity
                   ;;               lflf 'orig (get-in proto-impls [.default-impl .arities arg-count])
                   ;;               lflf 'arity arity-c
                   ;;               lflf 'new new-arity-c)

                   ;;       '_)
                   (cond (= c/bottom-type dflt-arity)
                         (compilation-error ;; 'site _LINE_ loc type-num arg-count
                                            ;; lflf 'dflt-arity dflt-arity
                                            ;; lflf 'params new-params
                                            ;; lflf
                                            (conf-ass _LINE_ dflt-arity loc))

                         (= new-arity-c c/bottom-type)
                         (compilation-error ;; 'impl _LINE_
                                            ;; lf 'def dflt-arity
                                            ;; lflf 'arity arity-c
                                            ;; lflf 'new new-arity-c
                                            ;; lflf
                                            (conf-ass _LINE_ new-arity-c loc))

                         ;; happy path
                         (se/state-error
                          (either (update-in proto-impls [.impl-fns type-num]
                                             (fn [fn-c]
                                               (assert (instance? c/FnConstraint fn-c))

                                               (assoc-in fn-c [.arities arg-count]
                                                         new-arity-c)))
                                  (assoc-in proto-impls [.impl-fns type-num]
                                            (.arities c/fn-constraint
                                                      {arg-count new-arity-c}))))))))
          (compilation-error "No prototype for" (str "'" (.fn-sym proto-impls) "'") "with"
                             (str arg-count) "arguments at" loc)))

(defn add-getter-impls [sym type-num getter-impl setter-impl loc]
  (for [getter-val (get-core-value sym)
        new-getter (add-impl-c (.constraint getter-val) type-num 1 getter-impl loc)
        new-getter (add-impl-c new-getter type-num 2 setter-impl loc)
        mod-idx (se/get-val .index)
        :let [sym (.constraint sym new-getter)]
        _ (se/update-in-val [.namespaces (cond (= 0 mod-idx)
                                               c/no-symbol
                                               core)
                             .values]
                            (set-val-hist sym sym))]
    sym))

(defn insert-invoke [type-num arity-c]
  (let [arity-rank (either (map (get-in arity-c [.param-consts])
                                (fn [params]
                                  (count (c/get-items params))))
                           0)]
    (se/update-in-val [.namespaces c/no-symbol .types]
                      (fn [types-info]
                        (map-vals types-info
                                  (fn [type-info]
                                    (either (for [_ (instance? c/ReifiedConstraint type-info)
                                                  _ (= (.type-number type-info) type-num)]
                                              (.invoke-fn type-info
                                                          (.arities c/fn-constraint
                                                                    {arity-rank arity-c})))

                                            type-info)))))))

(defn add-proto-impl [type-num fn-sym arg-count arity]
  (assert (instance? Integer type-num))
  (assert (instance? ast/fn-arity-ast arity))
  (assert-result r (instance? se/StateError r))

  (cond (= type-num c/UnknownType)
        (do
          (status 'bad-type-num _LINE_)
          (wait-for-err-out)
          (abort))
        '_)
  (let [loc (ast/location fn-sym)
        arity-c (.constraint arity)]
    (cond (= (str fn-sym) "")
          (do
            (status 'compiler-error _LINE_ (str "'" fn-sym "'") (ast/location fn-sym)
                    lflf arity-c)
            (wait-for-err-out)
            (abort))

          (comp (for [proto-val (get-value fn-sym)
                      :let [proto-impls (.constraint proto-val)]
                      _ (cond (get-in proto-impls [.impl-fns type-num .arities arg-count])
                              (compilation-error "An implementation for" (str "'" fn-sym "'")
                                                 "already exists\n"
                                                 "Redefinition attempted at" loc)
                              (for [new-proto (add-impl-c proto-impls type-num
                                                          arg-count arity-c loc)
                                    _ (se/update-in-val
                                       [.namespaces c/no-symbol .values]
                                       (set-val-hist fn-sym (.constraint proto-val new-proto)))]
                                new-proto))
                      _ (cond (= invoke-sym fn-sym)
                              (insert-invoke type-num arity-c)

                              se-nop)]
                  '_)
                (for [nss (get-core-value fn-sym)
                      _ (compilation-error 'wth _LINE_ fn-sym type-num)]
                  '_)))))

(defn remove-value-type [sym]
  (assert (instance? c/TaggedSymbol sym))
  (se/update-in-val [.namespaces c/no-symbol .values]
                    (fn [vals-list]
                      (either (map (first vals-list)
                                   (fn [values]
                                     (cons (dissoc values sym)
                                           (rest vals-list))))
                              vals-list))))

(defn recover-val [sym]
  (for [vals-list (se/get-in-val [.namespaces c/no-symbol .values])
        c (either (map (get-in vals-list [1 sym])
                       (fn [prev-val]
                         (set-value sym prev-val)))
                  (remove-value-type sym))]
    c))

(defn get-type-info [type-sym]
  (assert (instance? c/TaggedSymbol type-sym))

  ;; TODO: needs to handled namespaced type-sym
  ;; (or ;; (= (.file loc) core)
  ;;     ;; (= (.line loc) 0)
  ;;  (and ( = type-sym 'BitmapIndexedNode)
  ;;       (do
  ;;         (status 'get-type _LINE_ loc type-sym)
  ;;         (maybe '_))))
  (comp (cond (= c/no-symbol (.ns type-sym))
              (comp (se/get-in-val [.namespaces (.ns type-sym) .types type-sym])
                    (se/get-in-val [.namespaces core .types type-sym]))

              (se/get-in-val [.namespaces (.ns type-sym) .types type-sym]))
        ;; (flat-map se-nop
        ;;           (fn [_]
        ;;             ;; Look in the core module
        ;;             (let [core-prom (promise)]
        ;;               (send modules (fn [mods]
        ;;                               ;; (or ;; (= (.file loc) core)
        ;;                               ;;  ;; (= (.line loc) 0)
        ;;                               ;;  (and ( = type-sym 'BitmapIndexedNode)
        ;;                               ;;       (do
        ;;                               ;;         (status 'get-type _LINE_ loc type-sym lf
        ;;                               ;;                 (get-in mods [core .types (ast/untag type-sym)]))
        ;;                               ;;         (maybe '_))))
        ;;                               (either (or (for [core-mod (get mods core)
        ;;                                                 _ (instance? Promise core-mod)]
        ;;                                             (deliver core-prom se/zero-se))
        ;;                                           (map (get-in mods [core .types (ast/untag type-sym)])
        ;;                                                (fn [type-inf]
        ;;                                                  (deliver core-prom (se/state-error type-inf)))))
        ;;                                       (deliver core-prom se/zero-se))
        ;;                               mods))
        ;;               (extract core-prom))))
        (compilation-error "No type named" (str "'" type-sym "'")
                           "was found. Used at" (ast/location type-sym))))

(defn set-type-info [type-sym type-info]
  (se/assoc-in-val [.namespaces c/no-symbol .types type-sym]
                   type-info))

(deftype ConstantValues [numbers strings ;; symbols type-names encoded other
                         ]
  ;; numbers                static numbers
  (assert (instance? (map-of Integer String) numbers))
  ;; strings                static strings
  (assert (instance? (map-of String String) strings))
  ;; symbols                static symbols
  ;; (assert (instance? (map-of Symbol String) symbols))
  ;; type-names             map of type numbers to type names
  ;; (assert (instance? (map-of Integer String) type-names))
  ;; encoded                cache of values that have been statically encoded
  ;; (assert (instance? HashMap encoded))
  )

(def empty-constants (ConstantValues {} {}))

(deftype CodeContext [constants init]
  (assert (instance? ConstantValues constants))
  ;; init   nested vector of strings
  (assert (instance? Vector init))
  )

(deftype StaticArity [arity c-fn]
  (assert (instance? ast/fn-arity-ast arity))
  (assert (instance? String c-fn))

  Stringable
  (string-list [_]
    (list "(b/StaticArity " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (fn [new-arity]
           (.arity x new-arity)))))

(def var-punct {"*" "_STAR_"
                "." ""
                "#" "_HASH_"
                "+" "_PLUS_"
                "?" "_QM_"
                "!" "_BANG_"
                "=" "_EQ_"
                "<" "_LT_"
                ">" "_GT_"})

(def C-var-punct (apply-to (fn [punct-char]
                             (either (get var-punct punct-char)
                                     ""))
                           (apply grmr/any (keys var-punct))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (apply-to (fn [start remaining]
                       (to-str (comp [start] remaining)))
                     (grmr/any grmr/alpha
                               (grmr/all (grmr/ignore "#")
                                         (grmr/always ""))
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_MINUS_"))
                               C-var-punct)
                     C-var-remaining))

(def C-var (rd/parser C-var))

(defn check-C-var [var-name alt-var]
  ;; TODO: put this in after the original works
  ;; (either (map (instance? Vector (C-var var-name))
  ;;              (fn [[c-var]]
  ;;                c-var))

  ;;         alt-var)
  (let [parse-result (C-var var-name)]

    (cond (instance? Vector parse-result)
          (let [[c-var] parse-result]
            c-var)

          alt-var)))

(def global-vars (int-generator 0))
(def glbl "glbl")
(def glbl-len (count glbl))

(defn global-var
  ([arg-name]
   (global-var c/no-symbol arg-name))
  ([sym arg-name]
   (str glbl (check-C-var (str sym) arg-name)
        (extract global-vars))))
