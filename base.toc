
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "30b346e"))
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "dcba6be"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "b4d6ace"))
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "71dfbbe"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "d61aa1e"))

;; TODO: use 'either' here when the compiler supports it
(def toccata-dir (extract (or (sys/get-environment "TOCCATA_DIR")
                              (do
                                (print-err "Could not read environnment variable"
                                           "TOCCATA_DIR")
                                (abort)))))
;; (def path-to-core (str toccata-dir "/new-core.toc"))
(def path-to-core (str toccata-dir "/no-core.toc"))
(def core (c/ToccataCore path-to-core))

(def type-counter (int-generator c/TypeCount))

(def err-out (agent (maybe 'err-out)))

(def lf "\n")
(def lflf "\n\n")

(defn status [& msg]
  (send err-out (fn [out-file?]
                  ;; (assert (instance? Maybe out-file?))

                  ;; (and out-file?
                  ;;      (maybe (apply print-err msg)))

                  (apply print-err msg)
                  ;; (map out-file?
                  ;;      (fn [out-file]
                  ;;        (fio/write out-file (str (to-str (interpose msg " ")) lf))
                  ;;        out-file))
                  )))

(defn wait-for-err-out []
  (let [p (promise)]
    (send err-out (fn [outfile]
                    (deliver p outfile)
                    outfile))
    (extract p)))

(defn se-debug [& args]
  (se/new-se (fn [s]
               (apply status args)
               ['_ s])))

(def se-nop (se/new-se (fn [s]
                         ['_ s])))

(defn compilation-error [& msg]
  (flat-map se-nop
            (fn [_]
              (let [msg (to-str (interpose msg " "))]
                (se/throw msg)))))

(defn conf-ass [line failing-constraint loc]
  ;; (status 'conf-ass line)
  (to-str (list* "Conflicting assertions" (str " (" line ") ")
                 (either (= "" (.file loc))
                         (str " at " loc))
                 lf
                 (-> failing-constraint
                     ;; TODO: add file-name/line-number to empty paths
                     (c/format-path 0)))))

(deftype Module [path index namespaces types value-types values]
  ;; path             path to file containing the modules source code
  (assert (instance? c/FileName path))
  ;; index            this module's index
  (assert (instance? Integer index))
  ;; namespaces      imported namespaces
  (assert (instance? (map-of (any-of c/ToccataCore Symbol)
                             Module) namespaces))
  ;; types           map of symbols (type names) to type constraints
  ;; TODO: wrong. needs to include c/ProtoImpls and static values
  (assert (instance? (map-of c/TaggedSymbol c/ValueConstraint) types))
  ;; value-types     map of symbols (values) to type constraints
  ;; (assert (instance? (list-of (map-of Symbol c/ValueConstraint)) value-types))
  (assert (instance? List value-types))
  ;; values          map of symbos to ast's
  (assert (instance? HashMap values))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; modules holds a map from filenames to either a Module or a Promise
(def modules (agent {}))

(defn new-module [file-name module-index core-mod]
  (let [core-prom (promise)]
    ;; (send modules (fn [mods]
    ;;                 (map (get mods core)
    ;;                      (partial deliver core-prom))
    ;;                 mods))
    (Module file-name module-index
            (cond (= module-index 0)
                  {}
                  {core core-mod})
            c/core-type-constraints
            (list {'empty-list (c/update-sym c/empty-list-constraint
                                             (c/tag 'empty-list))
                   'empty-vector (c/update-sym c/empty-vect-constraint
                                               (c/tag 'empty-vector))
                   'int-max (.max c/int-constraint int-max)
                   'int-min (.min c/int-constraint int-min)
                   'nothing (c/update-sym c/nothing-constraint
                                          (c/tag 'nothing))})
            {})))

(deftype ModuleSetup [init cleanup]
  ;; init               strings to initialize the module
  (assert (instance? Vector init))
  ;; cleanup            strings to initialize the module
  (assert (instance? Vector cleanup)))

(deftype ConstantValues [numbers ;; strings symbols type-names encoded other
                         ]
  ;; numbers                static numbers
  (assert (instance? (map-of Integer String) numbers))
  ;; strings                static strings
  ;; (assert (instance? (map-of String String) strings))
  ;; symbols                static symbols
  ;; (assert (instance? (map-of Symbol String) symbols))
  ;; type-names             map of type numbers to type names
  ;; (assert (instance? (map-of Integer String) type-names))
  ;; encoded                cache of values that have been statically encoded
  ;; (assert (instance? HashMap encoded))
  )

(def empty-constants (ConstantValues {}))

(deftype CodeContext [constants mod-setups]
  (assert (instance? ConstantValues constants))
  ;; mod-setups   map of filenames to ModuleSetup
  (assert (instance? HashMap mod-setups))
  )

(deftype StaticArity [arity arity-var]
  (assert (instance? ast/fn-arity-ast arity))
  (assert (instance? String arity-var))

  Stringable
  (string-list [_]
    (list "(b/StaticArity " (str arity) ")"))

  Container
  (map [x f]
    (.arity x (f arity)))

  (map [x f embed]
    (map (f arity)
         (fn [new-arity]
           (.arity x new-arity)))))

(def var-punct {"*" "_STAR_"
                "." ""
                "#" "_HASH_"
                "+" "_PLUS_"
                "?" "_QM_"
                "!" "_BANG_"
                "=" "_EQ_"
                "<" "_LT_"
                ">" "_GT_"})

(def C-var-punct (apply-to (fn [punct-char]
                             (either (get var-punct punct-char)
                                     ""))
                           (apply grmr/any (keys var-punct))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (apply-to (fn [start remaining]
                       (to-str (comp [start] remaining)))
                     (grmr/any grmr/alpha
                               (grmr/all (grmr/ignore "#")
                                         (grmr/always ""))
                               (grmr/all (grmr/ignore "-")
                                         (grmr/always "_MINUS_"))
                               C-var-punct)
                     C-var-remaining))

(def C-var (rd/parser C-var))

(defn check-C-var [var-name alt-var]
  ;; TODO: put this in after the original works
  ;; (either (map (instance? Vector (C-var var-name))
  ;;              (fn [[c-var]]
  ;;                c-var))

  ;;         alt-var)
  (let [parse-result (C-var var-name)]

    (cond (instance? Vector parse-result)
          (let [[c-var] parse-result]
            c-var)

          alt-var)))

(def global-vars (int-generator 0))

(defn global-var
  ([arg-name]
   (global-var c/no-symbol arg-name))
  ([sym arg-name]
   (str "glbl_" (check-C-var (str sym "_") arg-name)
        "_" (extract global-vars))))
